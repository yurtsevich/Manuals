---
title: Даведнік па JavaScript
description: Даведнік па JavaScript па-беларуску
disqus_shortname: js-be
---

{% include base_path %}

<p><a href="https://learn.javascript.ru/">Современный учебник JavaScript</a><sup>ru</sup></p>

<p><a href="http://www.wintellect.com/devcenter/nstieglitz/5-great-features-in-es6-harmony">5 Great Features In EcmaScript 6</a></p>
<p><a href="https://es6cheatsheet.com/?utm_source=drip&utm_medium=email&__s=qs1syostphxzh61zhnjh">ES6 CheatSheet</a></p>
<p><a href="http://habrahabr.ru/post/252323/">ECMAScript 6</a></p>
<p><a href="https://codetower.github.io/es6-features/">ES6 Features</a></p>
<p><a href="http://habrahabr.ru/post/267639/">Тонкости модульной системы ECMAScript 2015 (ES6)</a></p>
<p><a href="http://es6-features.org/">ECMAScript 6 — New Features: Overview & Comparison</a>, <a href="https://ponyfoo.com/articles/es6">ES6 Overview in 350 Bullet Points</a></p>
<p><a href="https://ponyfoo.com/books/practical-es6/chapters#toc">Practical ES6</a></p>
<p><a href="https://github.com/dexteryy/spellbook-of-modern-webdev">Spellbook of Modern Web Dev</a></p>
<p><a href="https://code.tutsplus.com/tutorials/grokking-scope-in-javascript--cms-26259">Grokking Scope in JavaScript</a></p>
<p><a href="http://blog.avenuecode.com/lazy-loading-es2015-modules-in-the-browser/">Lazy-loading ES2015 modules in the browser</a></p>

<section>

  <h1 id="Links">Карысныя спасылкі</h1>
  <p>Блог і рэсурсы на <b>JavaScript.com</b>: <a href="https://www.javascript.com/">JavaScript.com</a></p>
  <p><a href="http://bestof.js.org/">bestof.js.org</a>&nbsp;&ndash; каталёг <i>JavaScript</i> кампанэнтаў (у шырокім сэнсе слова, ад бібліятэк да фрэймворкаў) па іх папулярнасьці на <i>GitHub</i>.</p>
  <p><i>JSbooks</i>, збор спасылак на вольныя кнігі па <i>JavaScript</i>: <a href="http://jsbooks.revolunet.com/">jsbooks.revolunet.com</a></p>
  <p><i>You Don't Know JS</i>, шэраг вольных кнігаў па <i>JavaScript</i>: <a href="https://github.com/getify/You-Dont-Know-JS">https://github.com/getify/You-Dont-Know-JS</a></p>
  <p>Тэндэнцыі ў сьвеце <i>JavaScript</i>: <a href="https://risingstars2016.js.org/">2016 JavaScript Rising Stars</a> і <a href="http://stateofjs.com/">The State of JavaScript in 2016</a></p>

  <h2 id="Links_Docs">Комплексная дакумэнтацыя</h2>
  <p><i>JavaScript</i> на <b><abbr title="Mozilla Developer Network">MDN</abbr></b>: <a href="https://developer.mozilla.org/en/JavaScript">https://developer.mozilla.org/en/JavaScript</a></p>
  <p><i>AJAX</i> на <b><abbr title="Mozilla Developer Network">MDN</abbr></b>: <a href="https://developer.mozilla.org/en/Ajax">https://developer.mozilla.org/en/Ajax</a></p>
  <p>«<i>Learn JavaScript</i>» на <b><abbr title="Mozilla Developer Network">MDN</abbr></b>: <a href="https://developer.mozilla.org/en-US/learn/javascript">https://developer.mozilla.org/en-US/learn/javascript</a></p>

  <h2 id="Links_Refs">Даведнікі і кнігі</h2>
  <p><i>Даведнік</i> на <b><abbr title="Mozilla Developer Network">MDN</abbr></b>: <a href="https://developer.mozilla.org/en/JavaScript/Guide">developer.mozilla.org/en/JavaScript/Guide</a></p>
  <p>«<i>JavaScript Garden</i>»: <a href="http://bonsaiden.github.com/JavaScript-Garden/">bonsaiden.github.com/JavaScript-Garden</a></p>
  <p>Інтэрактыўныя шпаргалкі на <b>OverAPI</b>: <a href="http://overapi.com/javascript">overapi.com/javascript</a> і <a href="http://overapi.com/jquery">overapi.com/jquery</a></p>
  <p>«<i>Learning JavaScript Design Patterns</i>»: <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/">addyosmani.com/resources/essentialjsdesignpatterns/book</a></p>
  <p>«<i>Eloquent JavaScript</i>»: <a href="http://eloquentjavascript.net/">eloquentjavascript.net/</a></p>
  <p><a href="http://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527">JavaScript: The Definitive Guide. Activate Your Web Pages</a> (шостае выданьне вядомай папяровай кнігі, напісанай <a href="http://www.amazon.com/David-Flanagan/e/B000APEZR4" title="Старонка, прысьвечаная Дэвіду Флэнэгэну на Amazon.com">Дэвідам Флэнэгэнам</a> ад выдавецтва <a href="http://oreilly.com/" title="Хатняя старонка выдавецтва O'Reilly">O'Reilly</a>&nbsp;&ndash; на мой погляд лепшая крыніца, з тых што мне трапляліся, паглыбленага вывучэньня <i>JavaScript</i>, але на жаль электроннага варыянту няма ў вольным доступе). Ці перакладзенае на расейскую мову выданьне гэтай кнігі: <a href="http://www.ozon.ru/context/detail/id/19677670/">ozon.ru</a>.</p>
  <p><a href="http://speakingjs.com/es5/index.html">Вольная кніга «<i>Speaking JavaScript</i>» аўтарства <i>Axel Rauschmayer</i></a></p>
  <p><a href="http://exploringjs.com/es6/index.html">Вольная кніга «<i>Exploring ES6</i>» аўтарства <i>Axel Rauschmayer</i></a></p>
  <p><a href="http://exploringjs.com/es2016-es2017/index.html">Вольная кніга «<i>Exploring ES2016 and ES2017</i>» аўтарства <i>Axel Rauschmayer</i></a></p>
  <p><a href="https://leanpub.com/setting-up-es6/read">Вольная кніга «<i>Setting up ES6</i>» аўтарства <i>Axel Rauschmayer</i></a></p>

  <h2 id="Links_Lessons">Урокі</h2>
  <p><i>Інтэрактыўныя ўрокі</i> для пачаткоўцаў на <b>CodeCademy.com</b>: <a href="http://www.codecademy.com/courses/javascript-intro/">http://www.codecademy.com/courses/javascript-intro</a></p>
  <p><i>Інтэрактыўныя ўрокі</i> для розных узроўняў на <b>CodeSchool.com</b>: <a href="https://www.codeschool.com/paths/javascript">https://www.codeschool.com/paths/javascript</a></p>
  <p>Сэрыя відэа-ўрокаў «<i>JavaScript з нуля</i>» на <b>Tuts+</b>: <a href="http://code.tutsplus.com/series/javascript-from-null--net-35330">http://code.tutsplus.com/series/javascript-from-null--net-35330</a></p>
  <p>Бясплатны 30-дзённы <i>відэа-курс</i> па <a href="#Frameworks_jQuery"><i>jQuery</i></a> на <b>Tuts+ Premium</b>: <a href="http://tutsplus.com/course/30-days-to-learn-jquery/">http://tutsplus.com/course/30-days-to-learn-jquery/</a></p>

  <h2 id="Links_Blogs">Блогі</h2>
  <p>Разьдзел <i>JavaScript</i> на <b>SmashingMagazine.com</b>: <a href="http://coding.smashingmagazine.com/tag/javascript/">http://coding.smashingmagazine.com/tag/javascript</a></p>
  <p>Разьдзелы <i>JavaScript &amp; AJAX</i> на <b>Net.Tuts+</b>: <a href="http://code.tutsplus.com/categories/javascript">JavaScript</a> і <a href="http://code.tutsplus.com/categories/ajax">AJAX</a></p>

  <h2 id="Links_Etc">Рознае</h2>
  <p>Калекцыя артыкулаў, кніг і відэа на тэму стварэньня, тэставаньня і падтрымкі вялікага коду на JavaScript: <a href="http://superherojs.com/">superherojs.com</a></p>
  <p>Крыніца, якая тлумачыць, як той ці іншы код на <i>jQuery</i> напісаць на чыстым <i>JavaScript</i>: <a href="http://youmightnotneedjquery.com/">YOU MIGHT NOT NEED JQUERY</a></p>
  <p><a href="https://plainjs.com/">PlainJS.com</a>&nbsp;&ndash; прыклады коду на чыстым <i>JavaScript</i> без неабходнасьці прыцягваць дадаткі.</p>
  <p><a href="https://github.com/NamPNQ/You-Dont-Need-Javascript?mc_cid=e1ff606a1a&mc_eid=5b4e3f8de1">You-Dont-Need-Javascript</a>&nbsp;&ndash; прыклады коду на чыстым <i>CSS</i> без неабходнасьці ўжываць <i>JavaScript</i>.</p>
  <p><a href="http://youmightnotneedjs.com/">You might not need JavaScript</a>&nbsp;&ndash; прыклады коду на чыстым <i>CSS</i> без неабходнасьці ўжываць <i>JavaScript</i>.</p>
</section>

<section>
  <h1 id="Overview">Агляд</h1>

  <h2 id="Overview_WhatIs">Што такое <i>JavaScript</i>?</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/A_re-introduction_to_JavaScript">re-Introduction</a></li>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/JavaScript_Overview">Guide</a></li>
    </ul>
  </div>
  <p><i>JavaScript</i>&nbsp;&ndash; гэта <a href="http://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%BE%D1%81%D1%81%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5" title="«Кроссплатформенное программное обеспечение» ў расейскай Вікіпэдыі">міжплатформавая</a>, <a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="«Объектно-ориентированный язык программирования» ў расейскай Вікіпэдыі">аб'ектна-арыентаваная</a>, кампактная мова праграмаваньня, якая прызначана як для самастойнага ўжываньня, так і для ўбудаваньня ў браўзэр.</p>
  <p>Ядро <i>JavaScript</i> утрымлівае <a href="#TypesValues">стандартныя тыпы</a>, <a href="#CoreObjects">базавыя аб'екты</a>, такія, як <a href="#CoreObjects_Array"><code class="language-js">Array</code></a>, <a href="#CoreObjects_Date"><code class="language-js">Date</code></a>, <a href="#TypesValues_Numbers_WorkingWith_MathObject"><code class="language-js">Math</code></a> і набор базавых элемэнтаў мовы, такіх, як <a href="#Operators">апэрацыі</a> і <a href="#Statements">інструкцыі</a>. Ядро мовы можа быць пашырана шляхам дадаваньня новых аб'ектаў.</p>
  <p><i>JavaScript</i> быў створаны інжынэрам карпарацыі <a href="http://en.wikipedia.org/wiki/Netscape" title="Старонка пра Netscape у ангельскай Вікіпэдыі">Netscape</a> <a href="http://ru.wikipedia.org/wiki/%D0%90%D0%B9%D0%BA,_%D0%91%D1%80%D0%B5%D0%BD%D0%B4%D0%B0%D0%BD" title="Старонка пра Брэндана ў расейскай Вікіпэдыі">Брэнданам Айкам</a> у 1995 годзе, і выдадзены як складнік <a href="http://en.wikipedia.org/wiki/Netscape_%28web_browser%29" title="«Netscape Web Browser» у ангельскай Вікіпэдыі">Netscape 2</a> на пачатку 1996 году. Першапачаткова плянавалася яго назваць <i>LiveScript</i>, але ў выніку дзіўнага маркетынгавага кроку, спрабуючы скарыстацца папулярнасьцю мовы <a href="../java/index.html"><i>Java</i></a>, быў пераназваны ў <i>JavaScript</i>. Нягледзячы на тое, што ў гэтых дзьвюх мовах ня вельмі шмат агульнага. Падабенства назваў гэтых моваў дагэтуль шмат каго бянтэжыць.</p>

  <h2 id="Overview_JavaScriptAndJava"><i>JavaScript</i> і <i>Java</i></h2>
  <p><i>JavaScript</i> і <a href="../java/index.html"><i>Java</i></a> падобныя ў некаторых аспэктах, але фундамэнтальна адрозьніваюцца ў іншых. Напрыклад, <i>JavaScript</i> ня мае статычнага тыпаваньня і строгай праверкі тыпаў, як у <a href="../java/index.html"><i>Java</i></a>, але пры гэтым вельмі падобны на яго сынтакс выразаў і інструкцыяў.</p>
  <p>У адрозьненьні ад <a href="../java/index.html"><i>Java</i></a> у <i>JavaScript</i> адбываецца дынамічнае вызначэньне тыпаў зьменных&nbsp;&ndash; у часе выкананьня праграмы, а не загадзя. У <i>JavaScript</i> выкарыстоўваецца прататыпная аб'ектная мадэль у адрозьненьні ад <a href="../java/index.html"><i>Java</i></a>, дзе выкарыстоўваецца больш звыклая для <a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="«Объектно-ориентированный язык программирования» ў расейскай Вікіпэдыі">аб'ектна-арыентаваных моваў</a> клясавая аб'ектная мадэль. У <i>JavaScript</i> зьменным можна прысвойваць функцыі, а таксама апошнія могуць быць парамэтрамі аб'ектаў.</p>
  <p>Форма ўжываньня <i>JavaScript</i> больш вольная, чым у <a href="../java/index.html"><i>Java</i></a>. Ня трэба загадзя і строга вызначаць усе зьменныя, клясы, мэтады. Ня трэба вызначаць ці пэўны мэтад зьяўляецца <code class="language-js">public</code>, <code class="language-js">private</code>, альбо <code class="language-js">protected</code>. Ня трэба рэалізоўваць інтэрфэйсы і вызначаць тыпы зьменных, парамэтраў і вяртаемых мэтадамі значэньняў.</p>
  <p>Больш падрабязна пра розьніцу паміж <i>JavaScript</i> і <a href="../java/index.html"><i>Java</i></a>, а таксама пра аб'ектную мадэль у <i>JavaScript</i> глядзіце разьдзел <a href="#ObjectModel">«Аб'ектная мадэль»</a>.</p>

  <h2 id="Overview_JavaScriptAndECMAScript"><i>JavaScript</i> і <i>ECMAScript</i></h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript">MDN</a></li>
    </ul>
  </div>
  <aside><sup>1</sup> Падрабязьней пра вэрсіі <i>JavaScript</i> і <i>ECMAScript</i>, а таксама іх суадносіны глядзіце ў ангельскай Вікіпэдыі: <a href="http://en.wikipedia.org/wiki/JavaScript#Version_history">JavaScript</a>, <a href="http://en.wikipedia.org/wiki/ECMAScript#Version_correspondence">ECMAScript</a>.
    <br /><br />
    З больш дакладнай табліцай рэалізацыі рознымі браўзэрамі сучасных стандартаў <i>ECMAScript</i> можна азнаёміцца <a href="http://kangax.github.io/compat-table/es6/">тут</a>.</aside>
  <p><a href="http://www.ecma-international.org/" title="Афіцыйны сайт Ecma International">Ecma International</a> працуе над стандартаванай вэрсіяй <i>JavaScript</i>, якая завецца <a href="http://en.wikipedia.org/wiki/ECMAScript" title="Пра ECMAScript у ангельскай Вікіпэдыі"><i>ECMAScript</i></a>. Стандарт <i>ECMAScript</i> задакумэнтаваны ў <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" title="ECMA-262 спэцыфікацыя">спэцыфікацыі <i>ECMA-262</i></a> (<i>ISO-16262</i>), першая рэдакцыя якой (па-анг. <i>Edition 1</i>), была зроблена на аснове <i>JavaScript</i> вэрсіі 1.1 (<i>Netscape Navigator 3.0</i>).</p>
  <table>
    <caption>Суадносіны паміж вэрсіямі <i>JavaScript</i> і <i>ECMAScript</i>, і якімі браўзэрамі яны падтрымліваюцца <sup>1</sup></caption>
    <thead>
    <tr>
      <th>Вэрсія <i>JavaScript</i></th>
      <th>Дата</th>
      <th>Адпавядае вэрсіі <i>ECMAScript</i></th>
      <th>Netscape</th>
      <th>Mozilla Firefox</th>
      <th>Internet Explorer</th>
      <th>Opera</th>
      <th>Safari</th>
      <th>Google Chrome</th>
    </tr>
    </thead>
    <tbody style="text-align: center;">
    <tr>
      <td>1.1</td>
      <td>Жнівень 1996&nbsp;г.</td>
      <td>Edition 1</td>
      <td>Navigator 3.0</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>1.2</td>
      <td>Чэрвень 1997&nbsp;г.</td>
      <td></td>
      <td>Navigator 4.0&ndash;4.05</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>1.3</td>
      <td>Кастрычнік 1998&nbsp;г.</td>
      <td>Edition 1</td>
      <td>Navigator 4.06&ndash;4.7x</td>
      <td></td>
      <td>4.0</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>1.4</td>
      <td></td>
      <td><i>Edition 1</i></td>
      <td>Server</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>1.5</td>
      <td>Лістапад 2000&nbsp;г.</td>
      <td><i>Edition 3</i></td>
      <td>Navigator 6.0</td>
      <td>1.0</td>
      <td>5.5&ndash;8</td>
      <td>6.0</td>
      <td>3.0&ndash;5</td>
      <td>1.0&ndash;10.0.666</td>
    </tr>
    <tr>
      <td>1.6</td>
      <td>Лістапад 2005&nbsp;г.</td>
      <td><i>Edition 3</i> + пашыраныя магчымасьці</td>
      <td></td>
      <td>1.5</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>1.7</td>
      <td>Кастрычнік 2006&nbsp;г.</td>
      <td><i>Edition 3</i> + пашыраныя магчымасьці</td>
      <td></td>
      <td>2.0</td>
      <td></td>
      <td></td>
      <td></td>
      <td>28.0.1500.95</td>
    </tr>
    <tr>
      <td>1.8</td>
      <td>Чэрвень 2008&nbsp;г.</td>
      <td><i>Edition 3</i> + пашыраныя магчымасьці</td>
      <td></td>
      <td>3.0</td>
      <td></td>
      <td>11.50</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>1.8.1</td>
      <td></td>
      <td><i>Edition 3</i> + пашыраныя магчымасьці</td>
      <td></td>
      <td>3.5</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>1.8.2</td>
      <td>Чэрвень 2009&nbsp;г.</td>
      <td><i>Edition 3</i> + пашыраныя магчымасьці</td>
      <td></td>
      <td>3.6</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>1.8.5</td>
      <td>Ліпень 2010&nbsp;г.</td>
      <td><i>Edition 5</i></td>
      <td></td>
      <td>4</td>
      <td>9</td>
      <td>11.60</td>
      <td>6.00</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>Чэрвень 2011&nbsp;г.</td>
      <td><i>Edition 5.1</i></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td><a href="http://www.infoworld.com/article/2937716/javascript/its-official-ecmascript-6-is-approved.html">Чэрвень 2015&nbsp;г.</a></td>
      <td><i>Edition&nbsp;6</i> альбо проста <i>ES6</i></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>У распрацоўцы</td>
      <td><i>Edition&nbsp;7</i> альбо проста <i>ES7</i></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    </tbody>
  </table>

</section>


<section>
  <h1 id="Lexic">Лексычная структура</h1>
  <p>Лексычная структура мовы праграмаваньня&nbsp;&ndash; гэта набор элемэнтарных правілаў, якія вызначаюць якім чынам пішуцца праграмы на гэтай мове. Яна вызначае від імёнаў зьменных, сымбалі, якія выкарыстоўваюцца для пазначэньня камэнтароў, як інструкцыі аддзяляюцца адна ад другой і іншае.</p>

  <h2 id="Lexic_Charachters">Набор сымбаляў</h2>
  <p>Пры напісаньні праграмаў <i>JavaScript</i> выкарыстоўваецца набор сымбаляў <a href="http://be-x-old.wikipedia.org/wiki/%D0%AE%D0%BD%D1%96%D0%BA%D0%BE%D0%B4" title="Пра Unicode у беларускай Вікіпэдыі">Unicode</a>. Гэтая 16-разрадная кадоўка забясьпечвае прадстаўленьне амаль усіх пісьмовых моваў.</p>

  <h2 id="Lexic_Casesensitive">Адчувальнасьць да рэгістру</h2>
  <p><i>JavaScript</i>&nbsp;&ndash; адчувальная да рэгістру мова праграмаваньня. Гэта значыць, што ключавыя словы, зьменныя, імёны функцыяў і іншыя ідэнтыфікатары заўсёды павінны ўтрымліваць аднолькавыя наборы малых і вялікіх літараў. Напрыклад, ключавое слова <code class="language-js">while</code> павінна заўсёды набірацца як «while», а не «While» альбо «WHILE». Аналягічна <code class="language-js">bar</code>, <code class="language-js">Bar</code> і <code class="language-js">BAR</code>&nbsp;&ndash; гэта імёны трох розных зьменных.</p>

  <h2 id="Lexic_Separators">Сымбалі-падзяляльнікі і пераводы радкоў</h2>
  <p><i>JavaScript</i> ігнаруе прагалы, знакі табулятара і пераводы радкоў, якія прысутнічаюць паміж лексэмамі праграмы. Таму іх можна зьмяшчаць у праграме без абмежаваньняў для фарматаваньня і наданьня праграме зручнага для чытаньня выгляду.</p>

  <h2 id="Lexic_EndingPointWithComma">Неабавязковыя кропка з коскай</h2>
  <p>У канцы інструкцыяў ў <i>JavaScript</i> звычайна зьмяшчаецца кропка з коскай. Абавязковымі яны зьяўляюцца, калі некалькі інструкцыяў месьцяцца на адным радку, для падзелу паміж імі. Калі ж кожная інструкцыя зьмяшчаецца на асобным радку, кропка з коскай не абавязковыя:</p>

  <pre><code class="language-js">
x = 3; y = 1;   // Кропка з коскай абавязкова паміж інструкцыямі на адным радку

x = 3;          // Калі інструкцыі месьцяцца на розных радках
y = 1;          // кропка з коскай можа зьмяшчацца

x = 3           // ... а можа і не зьмяшчацца
y = 1
</code></pre>

  <p>Пры гэтым, трэба заўважыць, што адзнакай добрага густу зьяўляецца яўнае пазначэньне кропкі з коскай заўсёды. Пры такім падыходзе амаль выключаецца, што сынтаксычны аналізатар <i>JavaScript</i> вас няправільна зразумее.</p>

  <h2 id="Lexic_Comments">Камэнтары</h2>
  <p><i>JavaScript</i> падтрымлівае як шматрадковы C-падобны камэнтар, у якім увесь тэкст паміж сымбалямі <code class="language-js">/*</code> і <code class="language-js">*/</code> разглядаецца як камэнтар. Так і аднарадковы С++-падобны камэнтар, у якім тэкст паміж сымбалямі <code class="language-js">//</code> і канцом радка разглядаецца як камэнтар. Ніжэй прыведзены карэктныя <i>JavaScript</i>-камэнтары:</p>

  <pre><code class="language-js">
// Аднарадковы камэнтар

/* С-падобны камэнтар */  // І яшчэ адзін камэнтар
/* С-падобны, шматрадковы
   камэнтар
*/
</code></pre>

  <h2 id="Lexic_Literals">Літаралы</h2>
  <p>Літаралы (элемэнтарныя значэньні)&nbsp;&ndash; гэта фіксаваныя значэньні, якія вы наўпрост (<i>літаральна</i>) прадстаўляеце праграме, то бок без ужываньня
    <a href="#TypesValues_Variables">зьменных</a>, <a href="#TypesValues_Constants">канстантаў</a>, <mark>выклікаў функцыяў</mark> і інш. Прыклады літаралаў:</p>

  <pre><code class="language-js">
15                  // Лік пятнаццаць
1.6                 // Лік адна цэлая і шэсьць дзесятых
'Hello, the world!' // Сымбальная чарада
"Hi!"               // Яшчэ адна сымбальная чарада
true                // Лягічнае значэньне
false               // Яшчэ адно лягічнае значэньне
null                // Пустое значэньне
</code></pre>

  <h2 id="Lexic_Identifiers">Ідэнтыфікатары</h2>
  <p>Ідэнтыфікатары&nbsp;&ndash; гэта імёны зьменных, канстантаў і функцыяў. Першым сымбалем ідэнтыфікатараў могуць быць літара альбо знак падкрэсьліваньня, а наступнымі сымбалямі ў дадатак да першых могуць быць яшчэ лічбы. Прыклады ідэнтыфікатараў:</p>

  <pre><code class="language-js">
my_var
v1234
_dummy
fooBar
</code></pre>

  <p>Але ідэнтыфікатары ня могуць супадаць з <a href="#Lexic_Keywords">ключавымі словамі</a> <i>JavaScript</i>, якія зарэзэрваваныя для адмысловых мэтаў.</p>

  <h2 id="Lexic_Keywords">Ключавыя словы</h2>
  <p>У <i>JavaScript</i> маецца шэраг ключавых словаў, якія зарэзэрваваныя для адмысловых мэтаў і ня могуць выкарыстоўвацца ў якасьці <a href="#Lexic_Identifiers">ідэнтыфікатараў</a>:</p>
  <table class="list" id="keywords">
    <caption>Ключавыя словы</caption>
    <tbody>
    <tr>
      <td><code class="language-js">break</code></td>
      <td><code class="language-js">else</code></td>
      <td><code class="language-js">instanceof</code></td>
      <td><code class="language-js">true</code></td>
    </tr>
    <tr>
      <td><code class="language-js">case</code></td>
      <td><code class="language-js">false</code></td>
      <td><code class="language-js">new</code></td>
      <td><code class="language-js">try</code></td>
    </tr>
    <tr>
      <td><code class="language-js">catch</code></td>
      <td><code class="language-js">finally</code></td>
      <td><code class="language-js">null</code></td>
      <td><code class="language-js">typeof</code></td>
    </tr>
    <tr>
      <td><code class="language-js">continue</code></td>
      <td><code class="language-js">for</code></td>
      <td><code class="language-js">return</code></td>
      <td><code class="language-js">var</code></td>
    </tr>
    <tr>
      <td><code class="language-js">default</code></td>
      <td><code class="language-js">function</code></td>
      <td><code class="language-js">switch</code></td>
      <td><code class="language-js">void</code></td>
    </tr>
    <tr>
      <td><code class="language-js">delete</code></td>
      <td><code class="language-js">if</code></td>
      <td><code class="language-js">this</code></td>
      <td><code class="language-js">while</code></td>
    </tr>
    <tr>
      <td><code class="language-js">do</code></td>
      <td><code class="language-js">in</code></td>
      <td><code class="language-js">throw</code></td>
      <td><code class="language-js">with</code></td>
    </tr>
    </tbody>
  </table>
  <p>Таксама маецца шэраг словаў, якія ў дадзены момант ядром мовы не выкарыстоўваюцца, але зарэзэрваваныя для магчымага будучага выкарыстаньня вэрсіяй ECMAScript Edition 3:</p>
  <table class="list" id="reserved">
    <caption>Словы, зарэзэрваваныя для будучага выкарыстаньня</caption>
    <tbody>
    <tr>
      <td><code class="language-js">abstract</code></td>
      <td><code class="language-js">double</code></td>
      <td><code class="language-js">goto</code></td>
      <td><code class="language-js">native</code></td>
      <td><code class="language-js">static</code></td>
    </tr>
    <tr>
      <td><code class="language-js">boolean</code></td>
      <td><code class="language-js">enum</code></td>
      <td><code class="language-js">implements</code></td>
      <td><code class="language-js">package</code></td>
      <td><code class="language-js">super</code></td>
    </tr>
    <tr>
      <td><code class="language-js">byte</code></td>
      <td><code class="language-js">export</code></td>
      <td><code class="language-js">import</code></td>
      <td><code class="language-js">private</code></td>
      <td><code class="language-js">synchronized</code></td>
    </tr>
    <tr>
      <td><code class="language-js">char</code></td>
      <td><code class="language-js">extends</code></td>
      <td><code class="language-js">int</code></td>
      <td><code class="language-js">protected</code></td>
      <td><code class="language-js">throws</code></td>
    </tr>
    <tr>
      <td><code class="language-js">class</code></td>
      <td><code class="language-js">final</code></td>
      <td><code class="language-js">interface</code></td>
      <td><code class="language-js">public</code></td>
      <td><code class="language-js">transient</code></td>
    </tr>
    <tr>
      <td><code class="language-js">const</code></td>
      <td><code class="language-js">float</code></td>
      <td><code class="language-js">long</code></td>
      <td><code class="language-js">short</code></td>
      <td><code class="language-js">volatile</code></td>
    </tr>
    <tr>
      <td><code class="language-js">debugger</code></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    </tbody>
  </table>
  <p>Акрамя гэтага, варта пазьбягаць ужываньня ідэнтыфікатараў, супадаючых з імёнамі глябальных зьменных ці функцыяў, якія прадвызначаны у <i>JavaScript</i>. У адваротным выпадку гэта можа прывесьці да памылак (калі атрыбут вызначаны як даступны толькі для чытаньня), альбо да непрадказальных вынікаў. У табліцы ніжэй прыведзеныя імёны такіх глябальных зьменных і функцыяў, якія вызначаны вэрсіяй ECMAScript Edition 3:</p>
  <table class="list" id="global">
    <caption>Глябальныя зьменныя і функцыі</caption>
    <tbody>
    <tr>
      <td><code class="language-js">arguments</code></td>
      <td><code class="language-js">encodeURI</code></td>
      <td><code class="language-js">Infinity</code></td>
      <td><code class="language-js">Object</code></td>
      <td><code class="language-js">String</code></td>
    </tr>
    <tr>
      <td><code class="language-js">Array</code></td>
      <td><code class="language-js">Error</code></td>
      <td><code class="language-js">isFinite</code></td>
      <td><code class="language-js">parseFloat</code></td>
      <td><code class="language-js">SyntaxError</code></td>
    </tr>
    <tr>
      <td><code class="language-js">Boolean</code></td>
      <td><code class="language-js">escape</code></td>
      <td><code class="language-js">isNaN</code></td>
      <td><code class="language-js">parseInt</code></td>
      <td><code class="language-js">TypeError</code></td>
    </tr>
    <tr>
      <td><code class="language-js">Date</code></td>
      <td><code class="language-js">eval</code></td>
      <td><code class="language-js">Math</code></td>
      <td><code class="language-js">RangeError</code></td>
      <td><code class="language-js">undefined</code></td>
    </tr>
    <tr>
      <td><code class="language-js">decodeURI</code></td>
      <td><code class="language-js">EvalError</code></td>
      <td><code class="language-js">NaN</code></td>
      <td><code class="language-js">ReferenceError</code></td>
      <td><code class="language-js">unescape</code></td>
    </tr>
    <tr>
      <td><code class="language-js">decodeURIcomponent</code></td>
      <td><code class="language-js">Function</code></td>
      <td><code class="language-js">Number</code></td>
      <td><code class="language-js">RegExp</code></td>
      <td><code class="language-js">URIError</code></td>
    </tr>
    </tbody>
  </table>
</section>

<section>
  <h1 id="TypesValues" data-content-item-open>Тыпы даных, значэньні і зьменныя</h1>
  <p>Тыпы значэньняў, якія могуць быць прадстаўлены і апрацаваны ў мове праграмаваньня, вядомы як <i>тыпы даных</i>, і адной з фундамэнтальных характарыстыкаў любой мовы праграмаваньня зьяўляецца набор тыпаў даных, якія ёю падтрымліваюцца. <i>JavaScript</i> дазваляе працаваць з трыма элемэнтарнымі тыпамі даных: <a href="#TypesValues_Numbers">лікамі</a>, <a href="#TypesValues_Strings">сымбальнымі чародамі</a> і <a href="#TypesValues_Booleans">лягічнымі значэньнямі</a>. Таксама маецца 2 адмысловых элемэнтарных значэньня: <a href="#TypesValues_null"><code class="language-js">null</code></a> і <a href="#TypesValues_undefined"><code class="language-js">undefined</code></a>.</p>
  <p>У дадатак да гэтых элемэнтарных тыпаў <i>JavaScript</i> падтрымлівае састаўны тып, вядомы як <i>аб'ект</i>. Аб'ект уяўляе зь сябе калекцыю значэньняў (альбо элемэнтарных, альбо іншых аб'ектаў). Гэта можа быць неўпарадкаваная калекцыя іменных, альбо ўпарадкаваныя калекцыя безназоўных, але пранумараваных значэньняў. У апошнім выпадку аб'ект называецца <i>масівам</i>.</p>
  <p>Таксама маецца яшчэ адзін адмысловы аб'ект&nbsp;&ndash; <i>функцыя</i>. Гэта аб'ект, зь якім злучаны код. Адпаведна, функцыя можа выклікацца для выкананьня гэтага коду.</p>
  <p>Акрамя масіваў і функцыяў у ядры мовы вызначана яшчэ шэраг адмысловых аб'ектаў. Яны ўяўляюць зь сябе не дадатковыя тыпы даных, але толькі новыя клясы аб'ектаў:</p>
  <ul>
    <li><code class="language-js">Date</code>&nbsp;&ndash; аб'екты, якія прадстаўляюць даты;</li>
    <li><code class="language-js">Error</code>&nbsp;&ndash; аб'екты, якія прадстаўляюць памылкі сынтаксісу і часу выкананьня;</li>
    <li><code class="language-js">RegExp</code>&nbsp;&ndash; аб'екты, якія прадстаўляюць рэгулярныя выразы;</li>
    <li><code class="language-js">Math</code>&nbsp;&ndash; дапаможны аб'ект для выкананьня арытмэтычных апэрацыяў.</li>
    <li><code class="language-js">Boolean</code>, <code class="language-js">Number</code>, <code class="language-js">String</code>&nbsp;&ndash; аб'екты-абгорткі элемэнтарных значэньняў.</li>
  </ul>

  <h2 id="TypesValues_Wrappers">Аб'екты-абгорткі</h2>
  <p>Перад тым, як перайсьці непасрэдна да тыпаў даных, спынімся спачатку на аб'ектах-абгортках. Напрыклад, разгледзім тыповую апэрацыю з сымбальнымі чародамі:</p>

  <pre><code class="language-js">
var s = "Нейкая сымбальная чарада";
var last_word = s.substring(s.lastIndexOf(" ") + 1, s.length);
</code></pre>

  <p>Можа падацца, што <code class="language-js">s</code>&nbsp;&ndash; гэта аб'ект і мы выклікаем яго мэтады і зьвяртаемся да яго атрыбутаў. Аднак гэта ня так, <code class="language-js">s</code>&nbsp;&ndash; гэта элемэнтарная сымбальная чарада. Чаму ж тады ў вышэйпрыведзеным прыкладзе выкарыстоўваецца аб'ектная натацыя?</p>
  <p>Справа ў тым, што для кожнага з трох элемэнтарных тыпаў даных вызначаны адпаведны аб'ект-абгортка. Для лікаў гэта аб'ект <code class="language-js">Number</code>, для сымбальных чародаў&nbsp;&ndash; <code class="language-js">String</code>, для лягічных значэньняў&nbsp;&ndash; <code class="language-js">Boolean</code>. Гэтыя абгорткі ўтрымліваюць тое ж самае значэньне элемэнтарных тыпаў, якое абгортваюць, але дадаткова вызначаюць атрыбуты і мэтады, якія могуць выкарыстоўвацца для маніпуляцыяў з гэтым элемэнтарным значэньнем.</p>
  <p><i>JavaScript</i> можа гнутка пераўтвараць адзін тып у іншы. Калі мы выкарыстоўваем чараду ў аб'ектным кантэксьце, то бок калі спрабуем зьвярнуцца да атрыбуту ці мэтаду чарады, <i>JavaScript</i> стварае ўнутры сябе аб'ект-абгортку для гэтай чарады. Менавіта гэты аб'ект забясьпечвае зьвяртаньне да сваіх атрыбутаў і мэтадаў, таксама ён часовы і будзе ўтылізаваны сыстэмай, як толькі патрэба ў ім адпадзе. Напрыклад:</p>

  <pre><code class="language-js">
var len = s.length;
</code></pre>

  <p>Тут <code class="language-js">s</code> застаецца сымбальнай чарадой. Ствараецца часовы аб'ект <code class="language-js">String</code>, які дазволіць зьвярнуцца да атрыбуту <code class="language-js">length</code>, а затым будзе ўтылізаваны, ніякім чынам не зьмяніўшы сыходнае значэньне зьменнай <code class="language-js">s</code>.</p>
  <p>Аб'екты-абгорткі можна ствараць і яўным чынам пры дапамозе апэратару <code class="language-js">new</code>:</p>

  <pre><code class="language-js">
var S = new String("Hello World"); // Аб'ект String
</code></pre>

  <p>Аўтаматычнае пераўтварэньне чародаў у аб'екты <code class="language-js">String</code> мае і зваротны напрамак&nbsp;&ndash; аб'екты <code class="language-js">String</code> там, дзе патрэбна, аўтаматычна будуць пераўтвораны ў адпаведныя сымбальныя чароды.</p>
  <p>Напрыканцы адзначым, што любыя чароды, лікі ці лягічныя значэньні могуць быць пераўтвораны ў адпаведны аб'ект-абгортку з дапамогай канструктару Object():</p>

  <pre><code class="language-js">
var number_wrapper = new Object(3);
</code></pre>

  <h2 id="TypesValues_Numbers">Лікі</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/A_re-introduction_to_JavaScript#.D0.A7.D0.B8.D1.81.D0.BB.D0.B0">re-Introduction</a></li>
    </ul>
  </div>
  <p>У <i>JavaScript</i> усе лікі (і цэлыя, і рэчаісныя) прадстаўляюцца адно праз 64-бітавыя рэчаісныя значэньні падвойнай дакладнасьці ў фармаце, вызначаным стандартам <a href="http://en.wikipedia.org/wiki/IEEE_754-2008" title="Апісаньне стандарту IEEE 754 у ангельскай Вікіпэдыі">IEEE 754</a>. Гэты фармат здольны прадстаўляць лікі ў дыяпазоне ад &plusmn;1,7976931348623157&#215;10<sup>308</sup> да &plusmn;5&#215;10<sup>-324</sup>. У <i>JavaScript</i> існуе базавы аб'ект-абгортка для лікаў: <a href="#TypesValues_Numbers_Wrapper"><code class="language-js">Number</code></a>. Лік, які ўтрымліваецца наўпрост у кодзе <i>JavaScript</i>-праграмы, называецца лікавым літаралам.</p>

  <h3 id="TypesValues_Numbers_Integers">Цэлыя літаралы</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Grammar_and_Types#Литерал_целого_числа">Guide</a></li>
    </ul>
  </div>
  <p>Цэлыя дзесятковыя лікі запісваюцца як пасьлядоўнасьць лічбаў:</p>

  <pre><code class="language-js">
0
3
10000000
</code></pre>

  <p>Лікавы фармат <i>JavaScript</i> дазваляе дакладна прадстаўляць усе цэлыя лікі ў дыяпазоне ад –9&nbsp;007&nbsp;199&nbsp;254&nbsp;740&nbsp;992 (–2<sup>53</sup>) да 9&nbsp;007&nbsp;199&nbsp;254&nbsp;740&nbsp;992 (2<sup>53</sup>) уключна. Для цэлых значэньняў па-за гэтым дыяпазонам можа губляцца дакладнасьць для малодшых разрадаў. Варта таксама адзначыць, што некаторыя цэлыя апэрацыі ў <i>JavaScript</i> (напрыклад пабітавыя апэрацыі) выконваюцца з 32-разраднымі цэлымі, якія прымаюць значэньні ў дыяпазоне ад –2&nbsp;147&nbsp;483&nbsp;648 (–2<sup>31</sup>) да 2&nbsp;147&nbsp;483&nbsp;647 (2<sup>31</sup>–1)</p>
  <p>Акрамя дзесятковай формы цэлыя можна яшчэ запісваць у шаснаццацірычнай&nbsp;&ndash; сымбалі <code class="language-js">0x</code> ці <code class="language-js">0X</code>, за якімі ідзе пасьлядоўнасьць шаснаццацірычных лічбаў:</p>

  <pre><code class="language-js">
0xff
0xCAFE911
</code></pre>

  <p>Некаторыя рэалізацыі <i>JavaScript</i> падтрымліваюць і васьмірычную форму запісу цэлых лікаў. Але ўжываць яе не пажадана, таму што гэта прывядзе да нечаканых вынікаў на рэалізацыях <i>JavaScript</i>, якія такую форму не падтрымліваюць.</p>

  <h3 id="TypesValues_Numbers_Floats">Рэчаісныя літаралы</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Grammar_and_Types#Литерал_числа_с_плавающей_точкой">Guide</a></li>
    </ul>
  </div>
  <p>Рэчаісны лік можа ўтрымліваць наступныя часткі:</p>
  <ul>
    <li>дзесятковую цэлую частку (пасьлядоўнасьць дзесятковых лічбаў), перад якой можа стаяць знак <code class="language-js">+</code> ці <code class="language-js">-</code>;</li>
    <li>рэчаісную кропку;</li>
    <li>фракцыю (пасьлядоўнасьць дзесятковых лічбаў);</li>
    <li>экспанэнту (сымбаль <code class="language-js">e</code> ці <code class="language-js">E</code>, за якім можа стаяць знак <code class="language-js">+</code> ці <code class="language-js">-</code>, і пасьлядоўнасьць дзесятковых лічбаў).</li>
  </ul>
  <p>Рэчаісны літарал абавязкова павінен утрымліваць прынамсі адну лічбу і альбо рэчаісную кропку, альбо экспанэнту. Схематычна фармат рэчаісных літаралаў можа прадставіць наступным чынам:</p>

  <pre><code class="language-js">
[digits][.digits][(E|e)[(+|-)]digits]
</code></pre>

  <p>Прыклады рэчаісных літаралаў:</p>

  <pre><code class="language-js">
3.14
2345.789
.3333333333333333333
6e23
1.4738223E-32
</code></pre>

  <h3 id="TypesValues_Numbers_Wrapper">Аб'ект-абгортка</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Numbers_and_dates#Number_object">Guide</a></li>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number">Reference</a></li>
    </ul>
  </div>
  <p>Для лікавых элемэнтарных значэньняў існуе <a href="#TypesValues_Wrappers">аб'ект-абгортка</a> <code class="language-js">Number</code>.</p>

  <h4 id="TypesValues_Numbers_Wrapper_Props">Атрыбуты</h4>
  <p>Аб'ект <code class="language-js">Number</code> утрымлівае лікавыя канстанты для прадстаўленьня мінімальных і максымальных значэньняў, ня-лікаў і бясконцасьцяў:</p>
  <ul>
    <li><code class="language-js">MAX_VALUE</code>&nbsp;&ndash; найбольшы дадатны лік, які можа быць прадстаўлены ў <i>JavaScript</i> (прыкладна 1,79e+308). Значэньні, большыя за гэтае, будуць прадстаўленыя як <a href="#TypesValues_Numbers_Wrapper_Props_PositiveInfinity">дадатная бясконцасьць</a>. Найменшы адмоўны лік, які можа быць прадстаўлены,&ndash; гэта <code class="language-js">-MAX_VALUE</code>. Значэньні, меншыя за гэтае, будуць прадстаўленыя як <a href="#TypesValues_Numbers_Wrapper_Props_NegativeInfinity">адмоўная бясконцасьць</a>.</li>
    <li><code class="language-js">MIN_VALUE</code>&nbsp;&ndash; найменшы але ня роўны 0 дадатны лік, які можа быць прадстаўлены ў <i>JavaScript</i> (прыкладна 5e-324). Значэньні, меншыя за гэтае, будуць прадстаўленыя як 0. Найбольшы адмоўны лік, які можа быць прадстаўлены,&ndash; гэта <code class="language-js">-MIN_VALUE</code>.</li>
    <li><a name="TypesValues_Numbers_Wrapper_Props_PositiveInfinity"><code class="language-js">POSITIVE_INFINITY</code></a>&nbsp;&ndash; адмысловае значэньне, якое прадстаўляе дадатную бясконцасьць, якая ўтвараецца пры перапаўненьні (пры перавышэньні максымальна магчымага значэньня).</li>
    <li><a name="TypesValues_Numbers_Wrapper_Props_NegativeInfinity"><code class="language-js">NEGATIVE_INFINITY</code></a>&nbsp;&ndash; адмысловае значэньне, якое прадстаўляе адмоўную бясконцасьць, якая ўтвараецца пры перапаўненьні (значэньні менш мінімальна магчымага адмоўнага).</li>
    <li><a name="TypesValues_Numbers_Wrapper_Props_NaN"><code class="language-js">NaN</code></a>&nbsp;&ndash; адмысловае значэньне «ня-лік», якое прадстаўляе, напрыклад, вынікі некарэктных арытмэтычных апэрацыяў (як то дзяленьне на нуль <sup><a href="#Ref_DevisionByZero">2</a></sup>). Тое ж самае, што і базавы аб'ект <a href="#TypesValues_Numbers_NaN"><code class="language-js">NaN</code></a>.</li>
  </ul>

  <h5 id="TypesValues_Numbers_Wrapper_Props_Examples">Прыклады</h5>
  <p>Доступ да гэтых значэньняў адбываецца заўсёды цераз прадвызначаны глябальны аб'ект <code class="language-js">Number</code> як у прыкладзе ніжэй, а не праз аб'екты <code class="language-js">Number</code>, якія вы ствараеце самі:</p>

  <pre><code class="language-js">
var aNumber = (-Number.MAX_VALUE) * 2;
if (aNumber == Number.NEGATIVE_INFINITY) {
  aNumber = -Number.MAX_VALUE;  // aNumber утрымлівае значэньне, якое немагчыма
                                // выкарыстоўваць у арытмэтычных апэрацыях, таму
                                // прызначаем яму аналягічнае, але карэктнае значэньне.
}
aNumber = aNumber / 0;          // вынікам будзе Number.NaN
</code></pre>

  <h4 id="TypesValues_Numbers_Wrapper_Methods">Мэтады</h4>
  <p>Таксама <a href="#ObjectModel">прататып аб'екта</a> (<mark>магчыма ўдакладніць спасылку да даччынага разьдзелу</mark>) <code class="language-js">Number</code> вызначае шэраг мэтадаў, якія даступны да ўсіх аб'ектаў <code class="language-js">Number</code>:</p>
  <ul>
    <li><code class="language-js">toExponential</code>&nbsp;&ndash; вяртае сымбальную чараду, якая прадстаўляе дадзены лік, у экспанэнцыяльнай натацыі. У якасьці парамэтру можа перадавацца колькасьць лічбаў пасьля рэчаіснай кропкі. Калі парамэтар не пазначаны, будзе адлюстравана столькі лічбаў пасьля рэчаіснай кропкі, колькі патрэбна. Прыклады:

      <pre><code class="language-js">
var num=77.1234;

alert("num.toExponential() is " + num.toExponential());        // адлюструе 7.71234e+1
alert("num.toExponential(4) is " + num.toExponential(4));      // адлюструе 7.7123e+1
alert("num.toExponential(2) is " + num.toExponential(2));      // адлюструе 7.71e+1
alert("77.1234.toExponential() is " + 77.1234.toExponential());// адлюструе 7.71234e+1
alert("77 .toExponential() is " + 77 .toExponential());        // адлюструе 7.7e+1
</code></pre>

    </li>
    <li><code class="language-js">toFixed</code>&nbsp;&ndash; вяртае сымбальную чараду, якая прадстаўляе дадзены лік, у натацыі з фіксаванай кропкай. У якасьці парамэтру можа перадавацца колькасьць лічбаў пасьля рэчаіснай кропкі (ад 0 да 20). Калі парамэтар не пазначаны, лічбы пасьля рэчаіснай кропкі будуць адкінутыя ўвогуле. Прыклады:

      <pre><code class="language-js">
var n = 12345.6789;

n.toFixed();            // вярне "12346": ня проста адкіне дроб,
                      // але акругліць значэньне
n.toFixed(1);           // вярне "12345.7": таксама акругліць значэньне
n.toFixed(6);           // вярне "12345.678900": дадасьць нулі
(1.23e+20).toFixed(2);  // вярне "123000000000000000000.00"
(1.23e-10).toFixed(2);  // вярне "0.00"
2.34.toFixed(1);        // вярне "2.3"
-2.34.toFixed(1);       // вярне -2.3: не чарада, але лік, з-за парадку
                      // апрацоўкі апэрацыяў
(-2.24).toFixed(1);     // вярне "-2.3": пасьля абгортваньня
                      // ў дужкі - сымбальная чарада
</code></pre>
    </li>
    <li><code class="language-js">toLocaleString</code>&nbsp;&ndash; вяртае сымбальную чараду, якая прадстаўляе дадзены лік, з улікам лякальных асаблівасьцяў. Прыклад:

      <pre><code class="language-js">
var number = 3500;
console.log(number.toLocaleString()); // адлюструе "3,500" у ангельскай лякалі
</code></pre>

    </li>
    <li><code class="language-js">toPrecision</code>&nbsp;&ndash; вяртае сымбальную чараду, якая прадстаўляе дадзены лік, альбо ў экспанэнцыяльнай натацыі, альбо ў натацыі з фіксаванай кропкай у залежнасьці ад неабходнай дакладнасьці. У якасьці парамэтру можа перадавацца неабходная дакладнасьць&nbsp;&ndash; колькасьць вартасных лічбаў. Калі парамэтар не пазначаны, мэтад вядзе сябе гэтак сама, як мэтад <a href="#TypesValues_Numbers_Wrapper_Methods_toString"><code class="language-js">toString</code></a>. Калі ў якасьці парамэтру будзе ўжыта ня цэлае значэньне, яно будзе акруглена. Пасьля агругленьня, калі значэньне парамэтру будзе выходзіць за межы дыяпазону ад 1 да 100, будзе згенэравана <a href="#CoreObjects_RangeError"><code class="language-js">RangeError</code></a>. Прыклады:

      <pre><code class="language-js">
var num = 5.123456;
console.log("num.toPrecision() is " + num.toPrecision());   // адлюструе 5.123456
console.log("num.toPrecision(5) is " + num.toPrecision(5)); // адлюструе 5.1235
console.log("num.toPrecision(2) is " + num.toPrecision(2)); // адлюструе 5.1
console.log("num.toPrecision(1) is " + num.toPrecision(1)); // адлюструе 5
</code></pre>

    </li>
    <li><a name="TypesValues_Numbers_Wrapper_Methods_toString"><code class="language-js">toString</code></a>&nbsp;&ndash; вяртае сымбальнае прадстаўленьне дадзенага ліку. У якасьці парамэтру можа перадавацца базіс ліку для адлюстраваньня (ад 2 да 36). Калі парамэтар не пазначаны, бярэцца базіс 10. Калі парамэтар знаходзіцца па-за межамі дыяпазону ад 2 да 36, будзе згенэравана памылка. Прыклады:

      <pre><code class="language-js">
var count = 10;
console.log(count.toString());   // адлюструе "10"
console.log((17).toString());    // адлюструе "17"

var x = 7;
console.log(x.toString(2));      // адлюструе дваічнае "111"
</code></pre>

    </li>
    <li><code class="language-js">valueOf</code>&nbsp;&ndash; вяртае прымітыўнае лікавае прадстаўленьне дадзенага лікавага аб'екта.</li>
  </ul>

  <h3 id="TypesValues_Numbers_NaN">Аб'ект <code class="language-js">NaN</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/NaN">Reference</a></li>
    </ul>
  </div>
  <aside id="Ref_DevisionByZero"><sup>2</sup> Трэба заўважыць, што вынікам <a href="#TypesValues_Numbers_Wrapper_Props_NaN"><code class="language-js">Number.NaN</code></a> будзе толькі дзяленьне <code class="language-js">0/0</code>, а, напрыклад, <code class="language-js">1/0</code> верне <a href="#TypesValues_Numbers_Wrapper_Props_PositiveInfinity">дадатную бясконцасьць</a>.</aside>
  <p>Акрамя <a href="#TypesValues_Numbers_Wrapper">аб'екта-абгортцы</a> існуе адмысловы аб'ект для прадстаўленьня некарэктных лікавых значэньняў,&nbsp;&ndash; напрыклад, вынік дзяленьня на нуль <sup>2</sup>. Тое ж самае, што і <a href="#TypesValues_Numbers_Wrapper_Props_NaN"><code class="language-js">Number.NaN</code></a>.</p>

  <h3 id="TypesValues_Numbers_WorkingWith">Праца з лікамі</h3>
  <p>Для выкананьня арытмэтычных дзеяў над лікамі ў <i>JavaScript</i> існуюць <a href="#Operators_Arithmetic">арытмэтычныя апэрацыі</a>: <code class="language-js">+</code> для складаньня, <code class="language-js">-</code> для адніманьня, <code class="language-js">*</code> для памнажэньня, <code class="language-js">/</code> для дзяленьня і <code class="language-js">%</code> для вызначэньня астачы цэлалікавага дзяленьня.</p>

  <h4 id="TypesValues_Numbers_WorkingWith_MathObject">Аб'ект <code class="language-js">Math</code></h4>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Numbers_and_dates#Math_object">Guide</a></li>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math">Reference</a></li>
    </ul>
  </div>
  <p>Акрамя арытмэтычных апэрацыяў <i>JavaScript</i> падтрымлівае выкананьне болей складаных матэматычных апэрацыяў пры дапамозе вялікай колькасьці матэматычных функцыяў. Для зручнасьці гэтыя функцыі сабраныя ў адзін дапаможны аб'ект <code class="language-js">Math</code>.</p>

  <h5>Атрыбуты</h5>
  <ul>
    <li><code class="language-js">E</code>&nbsp;&ndash; аснова натуральнага лягарытму (прыкладна 2,718).</li>
    <li><code class="language-js">LN2</code>&nbsp;&ndash; натуральны лягарытм 2 (прыкладна 0,693).</li>
    <li><code class="language-js">LN10</code>&nbsp;&ndash; натуральны лягарытм 10 (прыкладна 2,303).</li>
    <li><code class="language-js">LOG2E</code>&nbsp;&ndash; лягарытм E па аснове 2 (прыкладна 1,442).</li>
    <li><code class="language-js">LOG10E</code>&nbsp;&ndash; лягарытм E па аснове 10 (прыкладна 0,434).</li>
    <li><code class="language-js">PI</code>&nbsp;&ndash; значэньне π (прыкладна 3,14159).</li>
    <li><code class="language-js">SQRT1_2</code>&nbsp;&ndash; квадратны корань 1/2 (прыкладна 0,707).</li>
    <li><code class="language-js">SQRT2</code>&nbsp;&ndash; квадратны корань 2 (прыкладна 1,414).</li>
  </ul>

  <h5>Мэтады</h5>
  <table>
    <thead>
    <tr>
      <th width="80px">Мэтад(-ы)</th>
      <th>Апісаньне</th>
      <th width="40%">Прыклад</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code class="language-js">abs</code></td>
      <td>Вяртае абсалютнае значэньне аргумэнту.</td>
      <td><code class="language-js">Math.abs(-5); //=> 5</code></td>
    </tr>
    <tr>
      <td><code class="language-js">acos</code> <br /> <code class="language-js">asin</code> <br /> <code class="language-js">atan</code> <br /> <code class="language-js">atan2</code></td>
      <td>Зваротныя трыганамэтрычныя функцыі. Вяртаюць значэньні ў радыянах.</td>
      <td><code class="language-js">Math.acos(1); //=> 3.141592653589793</code></td>
    </tr>
    <tr>
      <td><code class="language-js">ceil</code></td>
      <td>Вяртае найменшы цэлы лік, большы ці роўны аргумэнту.</td>
      <td><code class="language-js">Math.ceil(45.25); //=> 46</code> <br /> <code class="language-js">Math.ceil(-45.25); //=> -45</code></td>
    </tr>
    <tr>
      <td><code class="language-js">cos</code> <br /> <code class="language-js">sin</code> <br /> <code class="language-js">tan</code></td>
      <td>Прамыя трыганамэтрычныя функцыі. Вяртаюць значэньні ў радыянах.</td>
      <td><code class="language-js">Math.cos(Math.PI); //=> -1</code></td>
    </tr>
    <tr>
      <td><code class="language-js">exp</code></td>
      <td>Падвышае значэньне <code class="language-js">E</code> да перададзенай ступені.</td>
      <td><code class="language-js">Math.exp(2); //=> 7.389</code></td>
    </tr>
    <tr>
      <td><code class="language-js">floor</code></td>
      <td>Вяртае найбольшы цэлы лік, меншы ці роўны аргумэнту.</td>
      <td><code class="language-js">Math.ceil(45.95); //=> 45</code> <br /> <code class="language-js">Math.ceil(-45.95); //=> -46</code></td>
    </tr>
    <tr>
      <td><code class="language-js">log</code></td>
      <td>Вяртае значэньне натуральнага лягарытму ад аргумэнту.</td>
      <td><code class="language-js">Math.log(10); //=> 2.302585092994046</code> <br />
        <code class="language-js">Math.log(0); //=> -Infinity</code> <br />
        <code class="language-js">Math.log(-1); //=> NaN</code> <br />
        <code class="language-js">Math.log(100)/Math.LN10 // log<sub>10</sub>(100)</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">max</code> <br /> <code class="language-js">min</code></td>
      <td>Вяртаюць адпаведна найбольшае й найменшае сярод сваіх аргумэнтаў (адвольная колькасьць).</td>
      <td><code class="language-js">Math.min(1,3); //=> 1</code><br />
        <code class="language-js">Math.max(1,8,3) //=> 8</code><br />
        <code class="language-js">Math.min() //=> Infinity</code><br />
        <code class="language-js">Math.max() //=> -Infinity</code><br />
        <code class="language-js">Math.max(1, "a") //=> NaN</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">pow</code></td>
      <td>Вяртае значэньне першага свайго аргумэнту, падвышанае ў ступень другога свайго аргумэнту.</td>
      <td><code class="language-js">Math.pow(7,2) //=> 49 (7<sup>2</sup>)</code></td>
    </tr>
    <tr>
      <td><code class="language-js">random</code></td>
      <td>Вяртае выпадковае рэчаіснае значэньне ў дыяпазоне ад 0 (уключна) да 1 (ня ўключна).</td>
      <td></td>
    </tr>
    <tr>
      <td><code class="language-js">round</code></td>
      <td>Вяртае бліжэйшае цэлае значэньне па правілам скругленьня.</td>
      <td><code class="language-js">Math.round(25.49) //=> 25</code> <br />
        <code class="language-js">Math.round(25.5) //=> 26</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">sqrt</code></td>
      <td>Вяртае значэньне квадратнага кораню аргумэнту.</td>
      <td><code class="language-js">Math.sqrt(9) //=> 3</code></td>
    </tr>
    </tbody>
  </table>
  <p>У дадатак да вышэйпералічаных мэтадаў разгледзім некалькі сытуацыяў, якія выходзяць за межы магчымасьцяў гэтых мэтадаў, але зьяўляюцца даволі распаўсюджанымі.</p>
  <p>Па-першае, лягарытмы адвольных значэньняў па аснове 2 і 10.</p>

  <pre><code class="language-js">
Math.log(100)/Math.LN10 // лягарытм 100 па аснове 10
Math.log(512)/Math.LN2 // лягарытм 512 па аснове 2
</code></pre>

  <p>Далей, каб атрымаць выпадковае рэчаіснае значэньне ў <strong>адвольным дыяпазоне</strong> можна скарыстацца ўласнай функцыяй:</p>

  <pre><code class="language-js">
function getRandomArbitrary(min, max) {
return Math.random() * (max - min) + min;
}
</code></pre>

  <p>Каб атрымаць выпадковае <strong>цэлае</strong> значэньне ў адвольным дыяпазоне можна скарыстацца наступнай функцыяй:</p>

  <pre><code class="language-js">
function getRandomInt(min, max) {
  Math.floor(Math.random() * (max - min + 1)) + min;
}
</code></pre>

  <h3 id="TypesValues_Numbers_ParsingStrings">Утварэньне з чародаў</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat">parseFloat</a></li>
    </ul>
  </div>
  <p>Для пераўтварэньня сымбальных чародаў у лікі існуюць дапаможныя функцыі верхняга ўзроўню: <code class="language-js">parseInt</code> і <code class="language-js">parseFloat</code>, для цэлых і рэчаісных лікаў адпаведна. Напрыклад, вынікам усіх наступных выразаў будзе рэчаісны лік 3,14:</p>

  <pre><code class="language-js">
parseFloat("3.14");
parseFloat("314e-2");
parseFloat("0.0314E+2");
parseFloat("3.14more non-digit characters");  // працэс сканаваньня чарады пры вызначэньні
                                              // ліку, які ў ёй утрымліваецца сканчваецца
                                              // на першым сымбалі, які ня можа уваходзіць
                                              // у лікавы літарал
</code></pre>

  <p>А наступны прыклад верне <a href="#TypesValues_Numbers_NaN"><code class="language-js">NaN</code></a>:</p>

  <pre><code class="language-js">
parseFloat("FF2");
</code></pre>

  <p>Вынікам усіх наступных выразаў будзе цэлы лік 15:</p>

  <pre><code class="language-js">
// першы парамэтар мэтаду parseInt - чарада для пераўтварэньня, другі - базіс ліку.

parseInt(" 0xF", 16);   // вядучыя прагалы ў першым парамэтры ігнаруюцца
parseInt(" F", 16);
parseInt("17", 8);
parseInt(021, 8);       // калі першы парамэтар - ня сымбальная чарада,
                        // ён пераўтвараецца ў яе
parseInt("015", 10);    // вядучыя нулі таксама ігнаруюцца
parseInt(15.99, 10);    // дробная частка адкідаецца, лік не акругляецца
parseInt("FXX123", 16); // працэс сканаваньня сканчваецца на першым некарэктным сымбалі
parseInt("1111", 2);
parseInt("15*3", 10);
parseInt("15e2", 10);
parseInt("15px", 10);
parseInt("12", 13);
</code></pre>

  <p>Наступныя прыклады вернуць <a href="#TypesValues_Numbers_NaN"><code class="language-js">NaN</code></a>:</p>

  <pre><code class="language-js">
parseInt("Hello", 8); // Зусім ня лік
parseInt("546", 2);   // Некарэктныя лічбы для дваічнага ліку
</code></pre>

  <h3 id="TypesValues_Numbers_Checking">Праверкі</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/isNaN">isNaN</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite">isFinite</a></li>
    </ul>
  </div>
  <p>Для праверкі ці зьяўляецца пэўнае значэньне лікам існуе функцыя <code class="language-js">isNaN</code>, таксама верхняга ўзроўню. Гэтую функцыю трэба выкарыстоўваць з пэўнай асьцярогай, асабліва, калі правяраемым значэньнем можа быць ня лік&nbsp;&ndash; у гэтым выпадку значэньне будзе спачатку пераўтворана ў лік, які ўжо ў сваю чаргу будзе пераданы ў функцыю:</p>

  <pre><code class="language-js">
isNaN(NaN);       // true
isNaN(true);      // false: значэньне true, як і false будзе пераўтворана ў адпаведна
                  // 1 і 0, якія ў сваю чаргу зьяўляюцца карэктнымі лікамі
isNaN(undefined); // true
isNaN(null);      // false: null будзе пераўтворана ў 0, а гэта карэктны лік
isNaN({});        // true
isNaN(37);        // false
isNaN("37");      // false: чарада "37" пераўтворыцца ў лік 37
isNaN("37.37");   // false: чарада "37.37" пераўтворыцца ў лік 37.37
isNaN("");        // false: пустая чарада пераўтворыцца ў 0
isNaN("blabla")   // true: спроба пераўтварыць чараду "blabla" у лік ня будзе
                  // пасьпяховай, гэта спроба верне NaN
</code></pre>

  <p>Для праверкі ці зьяўляецца значэньне пэўным лікам (не бясконцасьцю) існуе функцыя верхняга ўзроўню <code class="language-js">isFinite</code>. Калі ў якасьці аргумэнту ёй перададзеныя <a href="#TypesValues_Numbers_NaN"><code class="language-js">NaN</code></a>, <a href="#TypesValues_Numbers_Wrapper_Props_PositiveInfinity">дадатная</a> ці <a href="#TypesValues_Numbers_Wrapper_Props_NegativeInfinity">адмоўная бясконцасьць</a>, яна верне <code class="language-js">false</code>, у астатніх выпадках&nbsp;&ndash; <code class="language-js">true</code>.</p>

  <h2 id="TypesValues_Strings">Сымбальныя чароды</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/A_re-introduction_to_JavaScript#Строки">re-Introduction</a></li>
    </ul>
  </div>
  <p>Сымбальная чарада ўяўляе зь сябе пасьлядоўнасьць літар, лічбаў, знакаў пунктуацыі і іншых <i><a href="http://be-x-old.wikipedia.org/wiki/%D0%AE%D0%BD%D1%96%D0%BA%D0%BE%D0%B4" title="Пра Unicode у беларускай Вікіпэдыі">Unicode</a></i>-сымбаляў і зьяўляецца тыпам даных <i>JavaScript</i> для прадстаўленьня тэкстаў. Зьвярніце ўвагу, што ў <i>JavaScript</i> няма сымбальнага тыпу даных, як <code class="language-js">char</code> у мовах праграмаваньня <i>C</i>, <i>C++</i> альбо <i>Java</i>. Адзінкавы сымбаль прадстаўляецца праз чараду адзінкавай даўжыні.</p>

  <h3 id="TypesValues_Strings_Literals">Літаралы</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Grammar_and_types#Строковый_литерал">Guide</a></li>
    </ul>
  </div>
  <p>Сымбальныя літаралы ў <i>JavaScript</i>&nbsp;&ndash; гэта пасьлядоўнасьці з 0 ці больш <i><a href="http://be-x-old.wikipedia.org/wiki/%D0%AE%D0%BD%D1%96%D0%BA%D0%BE%D0%B4" title="Пра Unicode у беларускай Вікіпэдыі">Unicode</a></i>-сымбаляў (у кадоўцы <i><a href="https://en.wikipedia.org/wiki/UTF-16" title="Пра UTF-16 у ангельскай Вікіпэдыі">UTF-16</a></i>), зьмешчаная паміж двума знакамі апострафа альбо двукосься. Большая колькасьць <i>Unicode</i>-сымбаляў могуць быць прадстаўленыя пры дапамозе 16-бітавых значэньняў і, адпаведна, ім адпавядае адзін элемэнт чарады. Тым жа <i>Unicode</i>-сымбалям, якія ня могуць быць прадстаўленыя 16-бітавымі значэньнямі, адпавядаюць 2 пасьлядоўных элемэнта чарады (так званая «сурагатная пара»). Даўжынёй чарады зьяўляецца колькасьць 16-бітавых значэньняў, якія яна ўтрымлівае. Адпаведна, улічваючы папярэдняе правіла, даўжыня чарады можа не адпавядаць колькасьці <i>Unicode</i>-сымбаляў гэтай чарады.</p>

  <pre><code class="language-js">
var p = "π";  // π зьяўляецца сымбалем, які прадстаўляецца 16-бітавым значэньнем 0x03c0
var e = "e";  // e зьяўляецца сымбалем, які прадстаўляецца 17-бітавым значэньнем 0x1d452
p.length      // =&gt; 1: p утрымлівае 1 16-бітавы элемэнт
e.length      // =&gt; 2: у адпаведнасьці з кадоўкай UTF-16 e складаецца з 2-х 16-бітавых
              // значэньняў: "\ud835\udc52"
</code></pre>

  <p>Пустая чарада мае даўжыню 0. Доступ да сымбаляў чарады адбываецца пры дапамозе індэксу, пачынаючы з 0.</p>
  <p>Для пазначэньня сымбальнай чарады ў праграме патрэбны тэкст абгортваецца двукосьсем ці адзіночнымі апострафамі. Пры гэтым у чарадзе, якая абгортваецца двукосьсем, могуць сустракацца сымбалі апострафаў. І, адпаведна, у чарадзе, якая абгортваецца апострафамі, могуць сустракацца сымбалі двукосься. Сымбальная чарада таксама можа ўтрымліваць <i>escape</i>-пасьлядоўнасьці, <i>backslash</i> за якім ідзе пэўны сымбаль,&nbsp;&ndash; для прадстаўленьня ня-тэкставых ці адмысловых сымбаляў, а таксама для прадстаўленьня любых сымбаляў праз іх <i>Unicode</i>-значэньне.</p>

  <pre><code class="language-js">
""  // Пустая чарада
'testing'
"3.14"
'name="myform"'
"Wouldn't you prefer O'Reilly's book?"
"This string\nhas two lines"
"π is the ratio of a circle's circumference to its diameter"
</code></pre>

  <table>
    <caption><i>escape</i>-пасьлядоўнасьці ў <i>JavaScript</i></caption>
    <thead>
    <tr>
      <th width="20%">Пасьлядоўнасьць</th>
      <th>Сымбаль, які прадстаўляецца</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>\O</td>
      <td>NUL-сымбаль (\u0000)</td>
    </tr>
    <tr>
      <td>\b</td>
      <td><i>Backspace</i> (\u0008)</td>
    </tr>
    <tr>
      <td>\t</td>
      <td>Гарызантальная табуляцыя (\u0009)</td>
    </tr>
    <tr>
      <td>\n</td>
      <td>Сымбаль новага радка (\u000A)</td>
    </tr>
    <tr>
      <td>\v</td>
      <td>Вертыкальная табуляцыя (\u000B)</td>
    </tr>
    <tr>
      <td>\f</td>
      <td><i>Form feed</i> (\u000C)</td>
    </tr>
    <tr>
      <td>\r</td>
      <td>Сымбаль вяртаньня карэткі (\u000D)</td>
    </tr>
    <tr>
      <td>\"</td>
      <td>Сымбаль двукосься (\u0022)</td>
    </tr>
    <tr>
      <td>\'</td>
      <td>Апостраф (\u0027)</td>
    </tr>
    <tr>
      <td>\\</td>
      <td><i>Backslash</i> (\u005C)</td>
    </tr>
    <tr>
      <td>\x<i>XX</i></td>
      <td>Сымбаль з кадоўкі <i>Latin-1</i>, які прадстаўляецца двума 16-рычнымі лічбамі</td>
    </tr>
    <tr>
      <td>\u<i>XXXX</i></td>
      <td><i>Unicode</i>-сымбаль, які прадстаўляецца чатырма 16-рычнымі лічбамі</td>
    </tr>
    </tbody>
  </table>

  <h3 id="TypesValues_Strings_Wrapper">Аб'ект-абгортка</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String">Reference</a></li>
    </ul>
  </div>
  <p>Для сымбальных чародаў існуе <a href="#TypesValues_Wrappers">аб'ект-абгортка</a> <code class="language-js">String</code>. Для вызначэньня даўжыні чарады выкарыстоўваецца яго атрыбут <code class="language-js">length</code>:</p>

  <pre><code class="language-js">
s.length;
</code></pre>

  <p>Акрамя вышэйазначанага атрыбуту маецца шчэ шэраг мэтадаў:</p>

  <pre><code class="language-js">
var s = "hello, world"; // Пачынаем з пэўнага тэксту.

// Доступ да сымбаляў:
s.charAt(0);            // =&gt; "h": першы сымбаль чарады.
s[0];                   // =&gt; "h": тое ж, што і папярэдні выраз.
s.charAt(s.length-1);   // =&gt; "d": апошні сымбаль чарады.

// Лічбавы код сымбаляў:
s.charCodeAt(0);        // =&gt; 104: Unicode-значэньне літары h

// Доступ да часткі чарады:
s.substring(1,4);       // =&gt; "ell": частка чарады паміж сымбаляў з пазначанымі
                        // індэксамі, уключаючы сымбаль з індэксам, які вызначаецца
                        // першым аргумэнтам.
s.slice(1,4);           // =&gt; "ell": тое ж, што і папярэдні выраз.
s.slice(-3);            // =&gt; "rld": апошнія 3 сымбаля
s.substr(2,3);          // =&gt; "llo": падчарада з трох сымбаляў, пачынаючы з індэксу 2

// Месцазнаходжаньне сымбаляў:
s.indexOf("l");         // =&gt; 2: месцазнаходжаньне першай літары l.
s.lastIndexOf("l");     // =&gt; 10: месцазнаходжаньне апошняй літары l.
s.indexOf("l", 3);      // =&gt; 3: месцазнаходжаньне першай літары "l",
                        // пачынаючы з індэксу 3

// Падзел чарады на часткі:
s.split(", ");          // =&gt; ["hello", "world"]: вяртае часткі зыходнай чарады, на якія
                        // яна падзяляецца пазначаным сымбалем

// Мадыфікацыя зыходнай чарады:
s.replace("h", "H");    // =&gt; "Hello, world": зьмяняе сымбалі, прадстаўленыя першым
                        // аргумэнтам на тыя, якія прадстаўлены другім аргумэнтам
s.toUpperCase();        // =&gt; "HELLO, WORLD": зьмяняе ўсе малыя літары на вялікія
s.toLowerCase();        // =&gt; "hello, world": зьмяняе ўсе вялікія літары на малыя</code></pre>

  <h3 id="TypesValues_Strings_WorkingWith">Праца з чародамі</h3>
  <p>Адной з убудаваных магчымасьцяў працы з чародамі ў дадатак да магчымасьцяў, якія прадстаўляе аб'ект-абгортка, зьяўляецца <i>канкатэнацыя</i>&nbsp;&ndash; аб'яднаньне двух чародаў:</p>

  <pre><code class="language-js">
msg = "Hello, " + "world";      // У выніку атрымліваем "Hello, world"
greeting = "Welcome to my blog," + " " + name;
</code></pre>

  <p>Для параўнаньня чародаў ня трэба выкарыстоўваць адмысловыя функцыі (як у мовах <i>C</i> альбо <i>Java</i>), дастаткова скарыстацца <a href="#Operators_Comparison">апэрацыямі параўнаньня</a>:</p>

  <pre><code class="language-js">
var a = "a";
var b = "b";
if (a &lt; b) // true
  print(a + " менш за " + b);
else if (a &gt; b)
  print(a + " больш за " + b);
else
  print(a + " і " + b + " роўныя.");
</code></pre>

  <h3 id="TypesValues_Strings_Transformations">Пераўтварэньні ў лікі і наадварот</h3>
  <p>Лікі ў чароды і наадварот могуць пераўтварацца ядром мовы аўтаматычна ў залежнасьці ад кантэксту. У прыкладзе ніжэй лік будзе аўтаматычна пераўтвораны ў чараду:</p>

  <pre><code class="language-js">
var n = 100;
var s = n + " білетаў на канцэрт."; // У выніку зьменная s атрымае
                                    // значэньне "100 білетаў на канцэрт."
</code></pre>

  <p>А ў наступным прыкладзе чароды будуць аўтаматычна пераўтвораны ў лікі:</p>

  <pre><code class="language-js">
var product = "21" * "2";   // У выніку зьменная product атрымае лікавае значэньне 42
</code></pre>

  <h2 id="TypesValues_Booleans">Лягічныя значэньні</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/A_re-introduction_to_JavaScript#Другие_типы">re-Introduction</a></li>
    </ul>
  </div>
  <p>Лікавыя і сымбальныя тыпы даных маюць вялікую ці бясконцую колькасьць магчымых значэньняў. Лягічны тып даных, наадварот, мае толькі 2 магчымых значэньні, якія прадстаўляюцца літараламі <code class="language-js">true</code> (<i>праўда</i>, ці <i>ісьціна</i>) і <code class="language-js">false</code> (<i>няпраўда</i>). Лягічныя значэньні кажуць аб праўдзівасьці чаго-небудзь і ўяўляюць зь сябе звычайна вынік параўнаньня, напрыклад:</p>

  <pre><code class="language-js">
x == 5
</code></pre>

  <p>Гэты выраз правярае ці роўнае значэньне зьменнай <code class="language-js">x</code> ліку 5. Калі так, тады вынікам гэтага параўнаньня будзе значэньне <code class="language-js">true</code>. Калі зьменная <code class="language-js">x</code> ня роўная 5, вынікам параўнаньня будзе значэньне <code class="language-js">false</code>.</p>
  <p>Лягічныя значэньні звычайна выкарыстоўваюцца ў <a href="#Statements">інструкцыях</a>, як <a href="#Statements_Conditional_if...else"><code class="language-js">if...else</code></a>, які выконвае адно дзеяньне, калі лягічнае значэньне роўнае <code class="language-js">true</code>, і іншае дзеяньне, калі лягічнае значэньне роўнае <code class="language-js">false</code>:</p>

  <pre><code class="language-js">
if (a == 4) {
  b = b + 1;
} else {
  a = a + 1;
}
</code></pre>

  <p>Тут выконваецца праверка ці роўнае значэньне зьменнай <code class="language-js">a</code> ліку 4. Калі так, тады да значэньня зьменнай <code class="language-js">b</code> дадаецца 1, у адваротным выпадку 1 дадаецца да значэньня зьменнай <code class="language-js">a</code>.</p>

  <h3 id="TypesValues_Booleans_Wrapper">Аб'ект-абгортка</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Boolean">Reference</a></li>
    </ul>
  </div>
  <p>Для лягічных значэньняў, гэтаксама як і для лікаў з чародамі, існуе свой аб'ект-абгортка&nbsp;&ndash; <code class="language-js">Boolean</code>. Ён утрымлівае толькі адзін атрыбут&nbsp;&ndash; <code class="language-js">value</code>, які вяртае лягічнае значэньне абгорнутае аб'ектам.</p>
  <p>Аб'ект <code class="language-js">Boolean</code> трэба выкарыстоўваць з вялікай асьцярогай, напрыклад не выкарыстоўваць яго ў лягічных выразах (глядзі наступны разьдзел).</p>

  <h3 id="TypesValues_Booleans_Transformations">Пераўтварэньні лягічных значэньняў</h3>
  <p>Калі лягічнае значэньне выкарыстоўваецца ў лікавым кантэксьце, тады значэньне <code class="language-js">true</code> пераўтвараецца ў лік 1, а <code class="language-js">false</code>&nbsp;&ndash; у 0. Калі лягічнае значэньне выкарыстоўваецца ў сымбальным кантэксьце, тады значэньне <code class="language-js">true</code> пераўтвараецца ў чараду <code class="language-js">"true"</code>, а <code class="language-js">false</code>&nbsp;&ndash; у чараду <code class="language-js">"false"</code>.</p>
  <p>Трэба заўважыць, што значэньні іншых тыпаў таксама могуць выкарыстоўвацца ў лягічным кантэксьце. Наступныя значэньні хаця і не зьяўляюцца лягічнымі інтэрпрэтуюцца як «няпраўда» (<code class="language-js">false</code>):</p>
  <ul>
    <li><code class="language-js">0</code></li>
    <li><a href="#TypesValues_Numbers_NaN"><code class="language-js">NaN</code></a></li>
    <li><code class="language-js">""</code> (пустая <a href="#TypesValues_Strings">чарада</a>)</li>
    <li><a href="#TypesValues_null"><code class="language-js">null</code></a></li>
    <li><a href="#TypesValues_undefined"><code class="language-js">undefined</code></a></li>
  </ul>
  <p>Усе астатнія значэньні будуць інтэрпрэтавацца як <code class="language-js">true</code>. <strong>Заўважце, што аб'ект <code class="language-js">Boolean</code>, які ўтрымлівае лягічнае значэньне <code class="language-js">false</code>, не падпадае ані пад адно з пералічаных вышэй значэньняў, якія трактуюцца як <code class="language-js">false</code>, таму будзе трактаваны як <code class="language-js">true</code>.</strong></p>

  <h2 id="TypesValues_null">Значэньне <code class="language-js">null</code></h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/null">Glossary</a></li>
    </ul>
  </div>
  <p><code class="language-js">null</code>&nbsp;&ndash; гэта <a href="#Lexic_Keywords">ключавое слова</a> ў <i>JavaScript</i>, якое пазначае адсутнасьць значэньня (напрыклад, у зьменнай, не важна элемэнтарнага ці аб'ектнага тыпу).</p>
  <p><code class="language-js">null</code>&nbsp;&ndash; гэта нармальная альбо чаканая адсутнасьць значэньня ў зьменнай, у адрозьненьні ад <a href="#TypesValues_undefined"><code class="language-js">undefined</code></a>. Калі пэўную зьменную трэба абнуліць альбо перадаць у функцыю пустое значэньне, трэба скарыстацца менавіта значэньнем <code class="language-js">null</code>.</p>

  <h2 id="TypesValues_undefined">Значэньне <code class="language-js">undefined</code></h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Undefined">Glossary</a></li>
    </ul>
  </div>
  <p>У <i>JavaScript</i> маецца яшчэ адно адмысловае значэньне <code class="language-js">undefined</code>, якое таксама пазначае адсутнасьць значэньня, але гэта яшчэ больш глыбокі ўзровень адсутнасьці значэньня&nbsp;&ndash; яно азначае, што зьменнай ўвогуле ніколі не прысвойвалася ніякае значэньне. Яно атрымліваецца, калі мы зьвяртаемся да неіснуючага атрыбуту аб'екта альбо неіснуючага элемэнту масіву, і вяртаецца функцыямі, якія не вяртаюць значэньняў.</p>

  <p><code class="language-js">undefined</code>&nbsp;&ndash; гэта нечаканая альбо памылка-падобная адсутнасьць значэньня ў зьменнай. Звычайна яно выкарыстоўваецца у праграме наўпрост толькі пры выкананьні нейкіх праверак, каб прадухіліць нечаканыя сытуацыі.</p>

  <aside class="usage_indicator usage_new"><code class="language-js">Symbol</code>&nbsp;&ndash; новы тып даных, упершыню ўведзены ў <a href="#Overview_JavaScriptAndECMAScript">ES6</a></aside>
  <h2 id="TypesValues_Symbol">Нязьменныя значэньні <code class="language-js">Symbol</code></h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Reference</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/symbol">Glossary</a></li>
    </ul>
  </div>
  <p><code class="language-js">Symbol</code>&nbsp;&ndash; гэта элемэнтарны тып даных, чые экзэмпляры ўнікальныя і нязьменныя (<i>immutable</i>). Каб стварыць новы элемэнтарны сымбаль, трэба ўжыць у кодзе выраз <code class="language-js">Symbol()</code> з магчымым пазначэньнем яго тэкставага апісаньня:</p>

  <pre><code class="language-js">
var sym1 = Symbol();
var sym2 = Symbol("foo");
var sym3 = Symbol("foo");

Symbol("foo") === Symbol("foo"); // false
</code></pre>

  <p>Заўважце, што 2 экзэмпляры сымбальнага тыпу будуць заўсёды адрозьнівацца, нават калі пры іх стварэньні былі перададзеныя аднолькавыя апісаньні.</p>

  <h2 id="TypesValues_Conversions">Пераўтварэньні тыпаў</h2>
  <p>Як мы ўжо бачылі вышэй <i>JavaScript</i> ня ўскладвае занадта вялікіх патрабаваньняў да тыпу значэньняў, калі апэруе імі. Напрыклад, што тычыцца лягічнага тыпу, мы <a href="#TypesValues_Booleans_Transformations">адзначалі вышэй</a>, што якое б мы значэньне ня выкарысталі ў кантэксьце, у якім чакаецца лягічны тып, <i>JavaScript</i> аўтаматычна пераўтворыць яго менавіта ў лягічны тып. Тое ж самае тычыцца іншых тыпаў, напрыклад:</p>

  <pre><code class="language-js">
10 + " objects"   // =&gt; "10 objects". Лік 10 будзе аўтаматычна пераўтвораны ў чараду
"7" * "4"         // =&gt; 28: абедзьве чарады будуць аўтаматычна пераўтвораны ў лікі
var n = 1 - "x";  // =&gt; NaN: чарада "x" ня можа быць пераўтворана ў лік
n + " objects"    // =&gt; "NaN objects": лік NaN будзе пераўтвораны ў чараду "NaN"
</code></pre>

  <p>У табліцы ніжэй прыведзены правілы аўтаматычнага пераўтварэньня тыпаў:</p>
  <table>
    <caption>Пераўтварэньні тыпаў</caption>
    <thead>
    <tr>
      <th rowspan="2">Зыходнае значэньне</th>
      <th colspan="4">Аўтаматычнае пераўтварэньне ў:</th>
    </tr>
    <tr>
      <th>Чараду</th>
      <th>Лік</th>
      <th>Лягічнае значэньне</th>
      <th>Аб'ект</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code class="language-js">undefined</code></td>
      <td><code class="language-js">"undefined"</code></td>
      <td><code class="language-js">NaN</code></td>
      <td><code class="language-js">false</code></td>
      <td>будзе кінута памылка <code class="language-js">TypeError</code></td>
    </tr>
    <tr>
      <td class="underlined"><code class="language-js">null</code></td>
      <td class="underlined"><code class="language-js">"null"</code></td>
      <td class="underlined"><code class="language-js">0</code></td>
      <td class="underlined"><code class="language-js">false</code></td>
      <td class="underlined">будзе кінута памылка <code class="language-js">TypeError</code></td>
    </tr>
    <tr>
      <td><code class="language-js">true</code></td>
      <td><code class="language-js">"true"</code></td>
      <td><code class="language-js">1</code></td>
      <td></td>
      <td><code class="language-js">new Boolean(true)</code></td>
    </tr>
    <tr>
      <td class="underlined"><code class="language-js">false</code></td>
      <td class="underlined"><code class="language-js">"false"</code></td>
      <td class="underlined"><code class="language-js">0</code></td>
      <td class="underlined"></td>
      <td class="underlined"><code class="language-js">new Boolean(false)</code></td>
    </tr>
    <tr>
      <td><code class="language-js">""</code> (пустая чарада)</td>
      <td></td>
      <td><code class="language-js">0</code></td>
      <td><code class="language-js">false</code></td>
      <td><code class="language-js">new String("")</code></td>
    </tr>
    <tr>
      <td><code class="language-js">"1.2"</code> (утрымлівае лік)</td>
      <td></td>
      <td><code class="language-js">1.2</code></td>
      <td><code class="language-js">true</code></td>
      <td><code class="language-js">new String("1.2")</code></td>
    </tr>
    <tr>
      <td class="underlined"><code class="language-js">"one"</code> (утрымлівае ня лік)</td>
      <td class="underlined"></td>
      <td class="underlined"><code class="language-js">NaN</code></td>
      <td class="underlined"><code class="language-js">true</code></td>
      <td class="underlined"><code class="language-js">new String("one")</code></td>
    </tr>
    <tr>
      <td><code class="language-js">0</code></td>
      <td><code class="language-js">"0"</code></td>
      <td></td>
      <td><code class="language-js">false</code></td>
      <td><code class="language-js">new Number(0)</code></td>
    </tr>
    <tr>
      <td><code class="language-js">-0</code></td>
      <td><code class="language-js">"-0"</code></td>
      <td></td>
      <td><code class="language-js">false</code></td>
      <td><code class="language-js">new Number(-0)</code></td>
    </tr>
    <tr>
      <td><code class="language-js">NaN</code></td>
      <td><code class="language-js">"NaN"</code></td>
      <td></td>
      <td><code class="language-js">false</code></td>
      <td><code class="language-js">new Number(NaN)</code></td>
    </tr>
    <tr>
      <td><code class="language-js">Infinity</code></td>
      <td><code class="language-js">"Infinity"</code></td>
      <td></td>
      <td><code class="language-js">true</code></td>
      <td><code class="language-js">new Number(Infinity)</code></td>
    </tr>
    <tr>
      <td><code class="language-js">-Infinity</code></td>
      <td><code class="language-js">"-Infinity"</code></td>
      <td></td>
      <td><code class="language-js">true</code></td>
      <td><code class="language-js">new Number(-Infinity)</code></td>
    </tr>
    <tr>
      <td class="underlined"><code class="language-js">1</code> (канечны лік, ня нуль)</td>
      <td class="underlined"><code class="language-js">"1"</code></td>
      <td class="underlined"></td>
      <td class="underlined"><code class="language-js">true</code></td>
      <td class="underlined"><code class="language-js">new Number(1)</code></td>
    </tr>
    <tr>
      <td><code class="language-js">{}</code> (любы аб'ект)</td>
      <td></td>
      <td></td>
      <td><code class="language-js">true</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code class="language-js">[]</code> (пусты масіў)</td>
      <td><code class="language-js">""</code></td>
      <td><code class="language-js">0</code></td>
      <td><code class="language-js">true</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code class="language-js">[9]</code> (адзіны лікавы элемэнт)</td>
      <td><code class="language-js">"9"</code></td>
      <td><code class="language-js">9</code></td>
      <td><code class="language-js">true</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code class="language-js">['a']</code> (любы іншы масіў)</td>
      <td>вынік мэтаду <code class="language-js">join()</code></td>
      <td><code class="language-js">NaN</code></td>
      <td><code class="language-js">true</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code class="language-js">function(){}</code> (любая функцыя)</td>
      <td>вынік мэтаду <code class="language-js">join()</code></td>
      <td><code class="language-js">NaN</code></td>
      <td><code class="language-js">true</code></td>
      <td></td>
    </tr>
    </tbody>
  </table>

  <h3 id="TypesValues_Conversions_Equality">Пераўтварэньні і роўнасьць</h3>
  <p>З-за таго, што <i>JavaScript</i> гнутка пераўтварае адны тыпы ў іншыя, яго <a href="#Operators_Comparison">апэрацыя роўнасьці</a> <code class="language-js">==</code> таксама гнуткая ў вызначэньні ці роўныя яе апэранды. Напрыклад, усе наступныя параўнаньні вяртаюць <code class="language-js">true</code>:</p>

  <pre><code class="language-js">
null == undefined   // Гэтыя значэньні трактуюцца як роўныя.
"0" == 0            // Чарада пераўтвараецца ў лік перад параўнаньнем.
0 == false          // Лягічнае значэньне пераўтвараецца ў лік перад параўнаньнем.
"0" == false        // Абодва апэранды пераўтвараюцца ў лікі перад параўнаньнем.
</code></pre>

  <h3 id="TypesValues_Conversions_ObjectsToPrimitives">Пераўтварэньні аб'ектаў у элемэнтарныя тыпы</h3>
  <p>Гэтую тэму пакінем па-за межамі дадзенага даведніку. Пры жаданьні можна зьвярнуцца да адпаведнага разьдзелу 3.8.3 шостага выданьня кнігі <a href="http://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527"><i>David Flanagan. «JavaScript. The Definitive Guide. Activate Your Web Pages».</i></a></p>

  <h2 id="TypesValues_MutableObjectsAndImmutablePrimitives">Зьменныя аб'екты і нязьменныя элемэнтарныя значэньні</h2>
  <p>У <i>JavaScript</i> існуе прынцыповае адрозьненьне паміж элемэнтарнымі тыпамі і аб'ектамі (уключаючы масівы і функцыі). Значэньні элемэнтарных тыпаў нязьменныя. Праілюструем гэта на прыкладзе з чарадой:</p>

  <pre><code class="language-js">
var s = "hello";  // Прысвоім чарадзе пэўны тэкст
s.toUpperCase();  // Дадзены выклік вяртае "HELLO",
                  // АЛЕ зьменена была КОПІЯ зыходнай чарады
s                 // =&gt; "hello": Зыходная чарада пры гэтым засталася бяз зьменаў
</code></pre>

  <p>Аб'екты ж у <i>JavaScript</i> могуць зьмяняцца:</p>

  <pre><code class="language-js">
var o = { x:1 };    // Пачнём зь нейкага аб'екта
o.x = 2;            // Зьменім яго шляхам зьмены яго атрыбуту
o.y = 3;            // Яшчэ раз зьменім шляхам дабаўленьня новага атрыбуту

var a = [1,2,3]     // Масівы таксама зьменныя
a[0] = 0;           // Зьменім значэньне пэўнага элемэнту масіву
a[3] = 4;           // Дададзім новы элемэнт да масіву
</code></pre>

  <p>Яшчэ аб'екты параўноўваюцца не па значэньні. Нават калі 2 аб'екты маюць адзін і той жа набор атрыбутаў і усе яны маюць аднолькавыя значэньні, гэтыя аб'екты ня будуць лічыцца роўнымі:</p>

  <pre><code class="language-js">
var o = {x:1}, p = {x:1};   // Два аб'екты з аднолькавымі атрыбутамі
o === p                     // =&gt; false: розныя аб'екты ніколі ня будуць роўнымі
var a = [], b = [];         // Два пустых масіва
a === b                     // =&gt; false: тое ж тычыцца і масіваў, 2 розных масіваў
                            // ня будуць роўныя, нават утрымліваючы аднолькавыя элемэнты
</code></pre>

  <p>Аб'екты яшчэ завуцца спасылачным тыпам (у адрозьненьні ад элемэнтарных тыпаў), таму што значэньні аб'ектаў&nbsp;&ndash; гэта спасылкі на аб'екты. Таму 2 спасылкі толькі тады роўныя, калі спасылаюцца на адзін і той жа аб'ект:</p>

  <pre><code class="language-js">
var a = [];   // Зьменная a спасылаецца на пусты масіў.
var b = a;    // Цяпер b спасылаецца на той жа самы масіў.
b[0] = 1;     // Зьменім масіў, на які спасылаецца b.
a[0]          // =&gt; 1: гэтая зьмена відна і праз спасылку a.
a === b       // =&gt; true: зьменныя a і b спасылаюцца на адзін і той жа аб'ект,
              // таму яны роўныя.
</code></pre>

  <p>З прыкладу вышэй відаць, што прысваеньне зьменнай нейкага аб'екта ня робіць копіі гэтага аб'екта, а захоўвае ў зьменнай спасылкі на гэты аб'ект. Калі ж вы жадаеце зрабіць менавіта копію, тады трэба яўным чынам скапіяваць кожны з атрыбутаў зыходнага аб'екта (масіву):</p>

  <pre><code class="language-js">
var a = ['a','b','c'];              // Масіў, копію якога мы жадаем зрабіць
var b = [];                         // Іншы масіў, у які мы жадаем зьмясьціць копію зыходнага
for(var i = 0; i < a.length; i++) { // Для кожнага індэксу масіву a[]
  b[i] = a[i];                      // Зьмяшчаем копію элемэнту масіву a у масіў b
}
</code></pre>

  <p>Гэткім жа чынам, пры жаданьні параўнаць 2 аб'екты ці масівы, трэба пасьлядоўна параўнаць усе іх атрыбуты/элемэнты.</p>

  <h2 id="TypesValues_Variables">Зьменныя</h2>
  <p>Зьменная&nbsp;&ndash; гэта імя, злучанае са значэньнем. Кажуць, што значэньне ўтрымліваецца ці захоўваецца ў зьменнай. Зьменныя дазваляюць захоўваць даныя ў праграме і працаваць зь імі. Напрыклад, наступны радок коду прысвойвае значэньне <code class="language-js">2</code> зьменнай зь імем <code class="language-js">i</code>:</p>

  <pre><code class="language-js">
i = 2;
</code></pre>

  <p>А ў наступным прыкладзе значэньне <code class="language-js">3</code> дадаецца да значэньня зьменнай зь імем <code class="language-js">i</code>, а вынік прысвойваецца зьменнай зь імем <code class="language-js">sum</code>:</p>

  <pre><code class="language-js">
sum = 3 + i;
</code></pre>

  <p><i>JavaScript</i> не зьяўляецца строга тыпізаванай мовай, таму адна і тая ж зьменная ў розныя часы можа захоўваць значэньні розных тыпаў:</p>

  <pre><code class="language-js">
i = "дзесяць";
i = 10;
</code></pre>

  <p>У <i>Java</i>, <i>C</i>, <i>C++</i> ці іншай тыпізаванай мове праграмаваньня такі код немагчымы, таму што ў гэтых мовах зьменная можа ўтрымліваць значэньні толькі пэўнага тыпу, які быў зададзены пры яе аб'яўленьні.</p>

  <aside class="usage_indicator usage_new"><code class=" language-js">let</code>&nbsp;– новы спосаб аб'яўляць зьменныя, упершыню ўведзены ў <a href="#Overview_JavaScriptAndECMAScript">ES6</a></aside>
  <h3 id="TypesValues_Variables_Declaration">Аб'яўленьні</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var">var</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">let</a></li>
    </ul>
  </div>
  <p>Перад выкарыстаньнем зьменную трэба аб'явіць. Гэта робіцца пры дапамозе <a href="#Lexic_Keywords">ключавых словаў</a> <code class="language-js">var</code> альбо <code class="language-js">let</code>.</p>

  <pre><code class="language-js">
var i;    // можна
var j;    // паасобку

var i, j; // а можна аб'яднаць у адно аб'яўленьне праз коску

// А можна адначасова з ініцыяцыяй
var message = "hello";
var i = 0, j = 0, k = 0;

function letTest() {
  var x = 1;    // зьменная узроўню функцыі
  if (true) {
    let x = 2;  // зьменная узроўню блёка
  }
}
</code></pre>

  <p>Калі пры аб'яўленьні зьменнай не прысвойваецца значэньне, яна будзе ўтрымліваць значэньне <a href="#TypesValues_undefined"><code class="language-js">undefined</code></a> да таго часу, пакуль ня будзе яўным чынам праініцыяваная.</p>

  <h3 id="TypesValues_Variables_Scope">Вобласьць бачнасьці</h3>
  <p>Вобласьць бачнасьці (<i>scope</i>) зьменнай&nbsp;&ndash; гэта частка коду праграмы, у якой гэтая зьменнай аб'яўлена і, адпаведна, бачная. <i>Глябальныя</i> зьменныя маюць глябальную вобласьць бачнасьці і бачны ў любым месцы <i>JavaScript</i>-праграмы. Вобласьцю бачнасьці зьменных, якія былі аб'яўлены ўнутры функцыі, зьяўляецца цела гэтай функцыі. У апошнім выпадку пра зьменную кажуць, што яна <i>лякальная</i>. Парамэтры функцыі таксама лічацца лякальнымі зьменнымі і бачны толькі ў межах сваёй функцыі.</p>
  <p>Унутры цела функцыі лякальная зьменная мае перавагу перад глябальнай з такім жа імем. Такім чынам, аб'явіўшы ў функцыі зьменную зь імем як у нейкай глябальнай зьменнай, вы згубіце доступ да той глябальнай зьменнай:</p>

  <pre><code class="language-js">
var scope = "global";   // Аб'яўляем глябальную зьменную

function checkscope() {
  var scope = "local";  // Аб'яўляем лякальную зьменную з такім жа імем
  return scope;         // Вяртаецца значэньне лякальнай зьменнай. Пасьля аб'яўленьня
                        // лякальнай зьменнай мы не маем доступу да глябальнай.
}
checkscope()            // =&gt; "local"
</code></pre>

  <p>Вызначэньні функцыяў могуць быць укладзенымі адна ў адну. Кожная функцыя мае сваю ўласную лякальную вобласьць бачнасьці, такім чынам у дадзеным выпадку будуць некалькі ўкладзеных абласьцей бачнасьці:</p>

  <pre><code class="language-js">
var scope = "global scope";     // Глябальная зьменная

function checkscope() {
  var scope = "local scope";    // Лякальная зьменная

  function nested() {
    var scope = "nested scope"; // Больш глыбокі (укладзены) ўзровень лякальнасьці
    return scope;               // Вяртаецца лякальная зьменная самага ўкладзенага ўзроўню
  }

  return nested();
}

checkscope();                   // =&gt; "nested scope"
</code></pre>

  <p>Той факт, што зьменныя, яб'яўленыя пры дапамозе <code class="language-js">var</code>, бачны ўва ўсёй функцыі незалежна ад месцу іх аб'яўленьня, азначае што яны могуць быць бачны да свайго аб'яўленьня:</p>

  <pre><code class="language-js">
var scope = "global";

function f() {
  console.log(scope);   // Надрукуе "undefined", не "global"
  var scope = "local";  // У гэтым месцы зьменнай прысвойваецца значэньне,
                        // але вызначана яна ўсюды ў функцыі.
  console.log(scope);   // Надрукуе "local"
}
</code></pre>

  <p>Кажуць, што аб'яўленьні лякальных зьменных у <i>JavaScript</i> як бы «усплываюць» да верху функцыі. Вызначэньне функцыі ў папярэднім прыкладзе эквівалентнае наступнаму:</p>

  <pre><code class="language-js">
var scope = "global";

function f() {
  var scope;          // Аб'яўляем лякальную зьменную
  console.log(scope); // Яна існуе, але яшчэ ня мае значэньня, таму надрукуецца "undefined"
  scope = "local";    // Прысвойваем ёй значэньне
  console.log(scope); // Будзе надрукавана "local"
}
</code></pre>

  <p>Са зьяўленьнем у <i>ES6</i> ключавога слова <code class="language-js">let</code> у <i>JavaScript</i> зьявілася і блёчная вобласьць бачнасьці:</p>

  <pre><code class="language-js">
function varTest() {
  var x = 1;
  if (true) {
    var x = 2;        // Тая ж самая зьменная!! Пры дапамозе <i>var</i> немагчыма аб'явіць зьменную блёчнай бачнасьці
    console.log(x);   // 2
  }
  console.log(x);     // 2
}

function letTest() {
  let x = 1;
  if (true) {
    let x = 2;        // Іншая зьменная, <i>let</i> дазваляе аб'явіць зьменную блёчнай бачнасьці
    console.log(x);   // 2
  }
  console.log(x);     // 1
}
</code></pre>

  <aside class="usage_indicator usage_new"><a href="#Overview_JavaScriptAndECMAScript">ES6</a> упершыню ўвёў магчымасьць аб'яўляць канстанты ў <i>JavaScript</i></aside>
  <h2 id="TypesValues_Constants">Канстанты</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">Reference</a></li>
    </ul>
  </div>
  <p>Пачынаючы з <a href="#Overview_JavaScriptAndECMAScript">ES6</a> у <i>JavaScript</i> можна аб'явіць нязьменную (канстантную) імянную велічыню. Канстантныя велічыні маюць блёчную вобласьць бачнасьці, як і зьменныя, аб'яўленыя пры дапамозе <code class="language-js">let</code>.</p>

  <pre><code class="language-js">
const MY_FAV = 7;
MY_FAV = 20;            // Будзе кінутая памылка выкананьня
console.log("my favorite number is: " + MY_FAV);  // Выведзе 7

const MY_FAV = 20;      // Пры спробе пера-вызначыць канстанту з тым же імем будзе ізноў кінутая памылка
var MY_FAV = 20;        // Як і пры спробе аб'явіць зьменную з тым жа імем
let MY_FAV = 20;        // ... альбо такім чынам - ізноў памылка

// У канстантаў блёчная вобласьць бачнасьці...
if (MY_FAV === 7) {
    const MY_FAV = 20;  // ...таму такое аб'яўленьне ня выкліча памылкі - іншая вобласьць бачнасьці

    console.log("my favorite number is " + MY_FAV);  // Выведзе 20
}

console.log("my favorite number is " + MY_FAV); // На гэтым узроўні MY_FAV усё яшчэ 7

const FOO;  // Будзе кінутая памылка - ня было прадстаўлена значэньне для канстанты

const MY_OBJECT = {"key": "value"}; // Канстантамі могуць быць і аб'екты...
MY_OBJECT = {"OTHER_KEY": "value"}; // ...які нельга пера-вызначыць (будзе кінутая памылка)...
MY_OBJECT.key = "otherValue";       // ...але яго атрыбуты зьмяняць можна
                                    // Калі патрэбна замарозіць і атрыбуты можна скарыстацца Object.freeze()

const MY_ARRAY = [];  // Тое ж самае і з канстантнымі масівамі
MY_ARRAY.push("A");   // Да яго можна дадаваць элемэнты
MY_ARRAY = ["B"];     // Але нельга пера-вызначаць (будзе кінутая памылка)
</code></pre>

  <p>Каб яб'явіць канстантнае значэньне ў <i>ES5</i>, трэба было рабіць наступны <i>workaround</i>:</p>

  <pre><code class="language-js">
// ES5 ня мае магчымасьці аб'явіць канстанту ўбудаванымі сродкамі мовы, але можна яе імітаваць:
function fakeConstant() {
  return 'Я - псэўдаканстанта';
}

console.log(fakeConstant());  // "Я - псэўдаканстанта"
</code></pre>

</section>

<section>
  <h1 id="Expressions">Выразы</h1>
  <p>Выразы ў <i>JavaScript</i>&nbsp;&ndash; гэта «фразы», якія інтэрпрэтатар <i>JavaScript</i> можа апрацаваць, каб атрымаць нейкае значэньне. Напрыклад, канстанта, якая наўпрост пазначана ў кодзе, ці зьменная&nbsp;&ndash; гэта прыклады найпрасьцейшых выразаў. Больш складаныя выразы будуюцца з простых, звычайна пры дапамозе апэрацыяў. Апэрацыя бярэ значэньні сваіх апэрандаў і на іх аснове вылічвае новае значэньне.</p>

  <p>Базавыя выразы&nbsp;&ndash; гэта тыя, якія не ўключаюць у свой склад іншыя, больш простыя выразы. Базавымі выразамі зьяўляюцца канстанты, убудаваныя наўпрост у код праграмы, ці іншымі словамі <a href="#Lexic_Literals">літаралы</a>, <a href="#TypesValues_Variables">зьменныя</a> і некаторыя <a href="#Lexic_Keywords">ключавыя словы</a> Напрыклад:</p>

  <pre><code class="language-js">
// Літаралы:
1.23        // Вызначае лікавы літарал
"hello"     // Вызначае тэкставы літарал
/pattern/   // Вызначае літарал рэгулярных выразаў

// Ключавыя словы:
true        // Вызначае лягічнае значэньне "ісьціна"
false       // Вызначае лягічнае значэньне "хлусьня"
null        // Вызначае значэньне-null
this        // Вызначае значэньне спасылкі на цяперашні аб'ект

// Зьменныя:
sum         // Вызначае значэньне зьменнай sum
undefined   // Вызначае значэньне глябальнай зьменнай undefined
</code></pre>

  <p>Выразы вызначэньня <a href="#CoreObjects_Array">масіваў</a> і <a href="#CoreObjects_Object">аб'ектаў</a> вяртаюць адпаведна створаныя масівы і аб'екты:</p>

  <pre><code class="language-js">
[]        // Выраз вызначае і вяртае пусты масіў
[2,3]     // Выраз вызначае і вяртае двумерны масіў 2 на 3

{ x:2.3, y:-1.2 }   // Выраз вызначае і вяртае аб'ект з двума лікавымі атрыбутамі
</code></pre>

  <p>Існуюць таксама выразы вызначэньня <a href="#CoreObjects_Function">функцыяў</a>:</p>

  <pre><code class="language-js">
// Вызначаецца функцыя, якая вылічвае квадрат свайго адзінага аргумэнту
var square = function(x) { return x * x; }
</code></pre>

  <p>Выразы доступу да атрыбутаў аб'ектаў:</p>

  <pre><code class="language-js">
y.x             // Выраз доступу да атрыбуту х аб'екта y
</code></pre>

  <p>Выразы выкліку функцыяў:</p>

  <pre><code class="language-js">
func(0)         // Выраз выкліку функцыі func з лікавым аргумэнтам 0
</code></pre>

  <p>Выразы стварэньня аб'ектаў:</p>

  <pre><code class="language-js">
new Point(2,3)  // Стварае аб'ект Point і выклікае адмысловую
                // функцыю-канструктар для яго ініцыіраваньня
</code></pre>

</section>

<section>
  <h1 id="Operators" data-content-item-open>Апэрацыі</h1>
  <p>Апэрацыі можна ўжыць да аднаго ці да некалькіх <a href="#Expressions">выразаў</a> (яны завуцца апэрандамі ў такім кантэксьце), каб на аснове іх значэньняў атрымаць новыя састаўныя выразы (значэньні). Знак роўнасьці <code class="language-js">=</code>&nbsp;&ndash; гэта апэрацыя прысваеньня, а ўжытая разам са сваімі апэрандамі <code class="language-js">k = 0</code>&nbsp;&ndash; гэта ўжо выраз прысваеньня.</p>

  <h2 id="Operators_Assignments">Прысваеньня</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators">Reference</a></li>
    </ul>
  </div>
  <p>Апэрацыі прысваеньня даволі інтуітыўна зразумелыя, але варта спыніцца на некаторых асаблівасьцях. Гэтыя апэрацыі зьяўляюцца права-асацыятыўнымі, а значэньнем выразу прысваеньня зьяўляецца правы апэранд апэрацыі. Таму дазваляецца наступнае:</p>

  <pre><code class="language-js">
i = j = k = 0;      // прысвоіць усім 3 зьменным значэньне 0
x = (i = (k = 0));  // эквівалентна папярэдняму з пазнакай парадку прысваеньня
</code></pre>

  <p>Таксама апэрацыі прысваеньня можна выкарыстоўваць у складаных выразах кшталту:</p>

  <pre><code class="language-js">
(a = b) == 0;       // спачатку значэньне b будзе прысвоена зьменнай a, а потым
                    // значэньне зьменнай a будзе параўнана з 0
</code></pre>

  <h3 id="ExpressionsAndOperators_Assignments_Shortened">Скарочаныя формы прысваеньняў</h3>
  <p>Скарочаныя формы прысваеньняў камбінуюць прысваеньне з іншай апэрацыяй:</p>

  <pre><code class="language-js">
a OP= b
</code></pre>

  <p>дзе <code class="language-js">OP</code> гэта пэўная апэрацыя, што эквівалентна:</p>

  <pre><code class="language-js">
a = a OP b
</code></pre>

  <p>Поўны сьпіс гэных апэрацыяў:</p>
  <table style="width: 400px;">
    <thead>
    <tr>
      <th>Апэрацыя</th>
      <th>Прыклад</th>
      <th>Эквівалент</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code class="language-js">+=</code></td>
      <td><code class="language-js">a += b</code></td>
      <td><code class="language-js">a = a + b</code></td>
    </tr>
    <tr>
      <td><code class="language-js">-=</code></td>
      <td><code class="language-js">a -= b</code></td>
      <td><code class="language-js">a = a - b</code></td>
    </tr>
    <tr>
      <td><code class="language-js">*=</code></td>
      <td><code class="language-js">a *= b</code></td>
      <td><code class="language-js">a = a * b</code></td>
    </tr>
    <tr>
      <td><code class="language-js">/=</code></td>
      <td><code class="language-js">a /= b</code></td>
      <td><code class="language-js">a = a / b</code></td>
    </tr>
    <tr>
      <td><code class="language-js">%=</code></td>
      <td><code class="language-js">a %= b</code></td>
      <td><code class="language-js">a = a % b</code></td>
    </tr>
    <tr>
      <td><code class="language-js">&lt;&lt;=</code></td>
      <td><code class="language-js">a &lt;&lt;= b</code></td>
      <td><code class="language-js">a = a &lt;&lt; b</code></td>
    </tr>
    <tr>
      <td><code class="language-js">&gt;&gt;=</code></td>
      <td><code class="language-js">a &gt;&gt;= b</code></td>
      <td><code class="language-js">a = a &gt;&gt; b</code></td>
    </tr>
    <tr>
      <td><code class="language-js">&gt;&gt;&gt;=</code></td>
      <td><code class="language-js">a &gt;&gt;&gt;= b</code></td>
      <td><code class="language-js">a = a &gt;&gt;&gt; b</code></td>
    </tr>
    <tr>
      <td><code class="language-js">&amp;=</code></td>
      <td><code class="language-js">a &amp;= b</code></td>
      <td><code class="language-js">a = a &amp; b</code></td>
    </tr>
    <tr>
      <td><code class="language-js">|=</code></td>
      <td><code class="language-js">a |= b</code></td>
      <td><code class="language-js">a = a | b</code></td>
    </tr>
    <tr>
      <td><code class="language-js">^=</code></td>
      <td><code class="language-js">a ^= b</code></td>
      <td><code class="language-js">a = a ^ b</code></td>
    </tr>
    </tbody>
  </table>

  <aside class="usage_indicator usage_new"><a href="#Overview_JavaScriptAndECMAScript">ES6</a> упершыню ўвёў паняцьце састаўнога прысваеньня ў <i>JavaScript</i></aside>
  <h2 id="Operators_DestructuringAssignments">Састаўнога прысваеньня</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Reference</a></li>
      <li><a href="http://wesbos.com/destructuring-objects/">WesBos 1</a></li>
      <li><a href="http://wesbos.com/destructuring-renaming/">WesBos 2</a></li>
      <li><a href="http://wesbos.com/destructuring-default-values/">WesBos 3</a></li>
    </ul>
  </div>
  <p><i>ES6</i> увёў магчымасьць састаўнога прысваеньня, альбо даслоўна «прысваеньня з рэ-структураваньнем» (<i>destructuring assignment</i>). Калі простымі словамі, гэта магчымасьць выняць некалькі значэньняў з масіву альбо аб'екту ў новыя асообныя зьменныя за адну апэрацыю:</p>

  <pre><code class="language-js">
const person = {
  first: 'Алесь',
  last: 'Загорскі',
  country: 'Беларусь',
  city: 'Нясьвіж',
  twitter: '@было_б_забаўна'
};

// Калі нам патрэбна было б выняць значэньні імені і прозьвішча ў асобныя зьменныя,
// да зьяўленьня ES6 трэба было б рабіць наступным чынам:
const first = person.first;
const last = person.last;

// А са зьяўленьнем ES6 можна такім чынам:
const { first, last } = person;
</code></pre>

  <h3 id="Operators_DestructuringAssignments_SwapValues">Абмен значэньнямі</h3>
  <p>Не зусім відавочная магчымасьць, якую прадстаўляе апэрацыя састаўнога прысваеньня, гэта абмен значэньняў паміж дзьвюма зьменнымі без неабходнасьці аб'яўленьня трэцяй:</p>

  <pre><code class="language-js">
var a = 1;
var b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1
</code></pre>

  <h3 id="Operators_DestructuringAssignments_Arrays">Прыстасоўна да масіваў</h3>
  <p>Састаўныя прысваеньні могуць ужывацца прыстасоўна да масіваў:</p>

  <pre><code class="language-js">
var foo = ["one", "two", "three"];

var [one, two, three] = foo;
console.log(one);   // "one"
console.log(two);   // "two"
console.log(three); // "three"

// --- Прысваеньне асобна ад аб'яўленьня ---
var a, b;

[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2

// --- Рэ-структураваньне выніку функцыі ---
function f() {
  return [1, 2];
}

var [a, b] = f();
console.log(a); // 1
console.log(b); // 2
</code></pre>

  <h4 id="Operators_DestructuringAssignments_Arrays_Defaults">Змоўчныя значэньні</h4>
  <p>Робячы састаўное прысваеньне значэньняў масіву, можна пазначаць змоўчныя велічыні, якія будуць ужытыя, калі ў масіве няма адпаведнага элемэнту:</p>

  <pre><code class="language-js">
var a, b;

[a=5, b=7] = [1];
console.log(a); // 1 (яўна прысвоенае)
console.log(b); // 7 (змоўчнае)
</code></pre>

  <p><strong>УВАГА!</strong> Змоўчнае значэньне будзе ўжытае толькі ў выпадку поўнай адсутнасьці элемэнту масіву, альбо калі ён мае значэньне <code class="language-js">undefined</code>. Калі ж адпаведны элемэнт прысутнічае і мае значэньні кшталту <code class="language-js">0</code>, <code class="language-js">false</code>, <code class="language-js">null</code>, то будзе ужытае адно з гэтых значэньняў:</p>

  <pre><code class="language-js">
var a, b;

[a=5, b=7] = [1, null];
console.log(a); // 1
console.log(b); // null (змоўчнае ня будзе ўжытае, таму што адпаведны элемэнт масіву прысутнічае і не undefined)
</code></pre>

  <p>Таму гэта зусім ня тое ж самае, што стары мэханізм пазначаць змоўчныя значэньні:</p>

  <pre><code class="language-js">
const mySpeed = 0; // Той жа эфэкт будзе ў выпадку значэньняў false, null ці undefined
const speed = mySpeed || 760;
console.log(speed); // 760!
</code></pre>

  <h4 id="Operators_DestructuringAssignments_Arrays_IgnoringValues">Ігнараваньне значэньняў</h4>
  <p>Ігнараваць пэўныя значэньні масіву можна наступным чынам:</p>

  <pre><code class="language-js">
function f() {
  return [1, 2, 3];
}

var [a, , b] = f();
console.log(a); // 1
console.log(b); // 3
</code></pre>

  <h4 id="Operators_DestructuringAssignments_Arrays_RestExpression">Прысваеньне астачы масіву</h4>
  <p>Акрамя прысваеньня асобных значэньняў адной са зьменных можна прысвоіць усю «астачу» масіву:</p>

  <pre><code class="language-js">
var [a, ...b] = [1, 2, 3];
console.log(a); // 1
console.log(b); // [2, 3]
</code></pre>

  <h4 id="Operators_DestructuringAssignments_Arrays_RealLifeExample">Рэальны прыклад</h4>
  <p>Прыклад як можа ўжывацца апэрацыя састаўнога прысваеньня прыстасоўна да масіваў у рэальным жыцьці:</p>

  <pre><code class="language-js">
var url = "https://developer.mozilla.org/en-US/Web/JavaScript";

var parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url);
console.log(parsedURL); // [
                        //  "https://developer.mozilla.org/en-US/Web/JavaScript",
                        //  "https",
                        //  "developer.mozilla.org",
                        //  "en-US/Web/JavaScript"
                        // ]

var [, protocol, fullhost, fullpath] = parsedURL;

console.log(protocol); // "https"
</code></pre>

  <h3 id="Operators_DestructuringAssignments_Objects">Прыстасоўна да аб'ектаў</h3>
  <p>Састаўныя прысваеньні могуць ужывацца таксама прыстасоўна да аб'ектаў:</p>

  <pre><code class="language-js">
var o = {p: 42, q: true};

var {p, q} = o;
console.log(p); // 42
console.log(q); // true

// --- Тое ж самае прысваеньне, але асобна ад аб'яўленьня ---
var o = {p: 42, q: true};
var p, q;

({p, q} = o);   // Зьвярніце ўвагу на круглыя дужкі вакол усяго выразу, бязь іх апэрацыя ня будзе працаваць.
</code></pre>

  <h4 id="Operators_DestructuringAssignments_Objects_Renaming">Прысваеньне з перайменаваньнем</h4>
  <p>Значэньні атрыбутаў аб'екта могуць быць вынятыя ў зьменныя з адрознымі імёнамі:</p>

  <pre><code class="language-js">
var o = {p: 42, q: true};

var {p: foo, q: bar} = o;
console.log(foo); // 42
console.log(bar); // true
</code></pre>

  <h4 id="Operators_DestructuringAssignments_Objects_DefaultValues">Змоўчныя значэньні</h4>
  <p>Робячы састаўное прысваеньне значэньняў аб'екта, можна пазначаць змоўчныя велічыні, якія будуць ужытыя, калі ў аб'екце няма адпаведнага атрыбуту:</p>

  <pre><code class="language-js">
var {a=10, b=5} = {a: 3};

console.log(a); // 3 (яўна прысвоенае)
console.log(b); // 5 (змоўчнае)
</code></pre>

  <p><strong>УВАГА!</strong> Як было ўжо пазначана ў <a href="#Operators_DestructuringAssignments_Arrays_Defaults">аналягічным разьдзеле, прысьвечаным масівам</a>, змоўчныя значэньні састаўных прысваеньняў будуць ужытыя толькі калі адпаведнага атрыбуту ўвогуле не існуе ў аб'екце альбо ён мае значэньне <code class="language-js">undefined</code>. Калі ж атрыбут прысутнічае і мае напрыклад значэньне <code class="language-js">null</code> альбо <code class="language-js">0</code> ці <code class="language-js">false</code>, то будзе ужытае менавіта адно з гэтых значэньняў.</p>

  <h4 id="Operators_DestructuringAssignments_Objects_DefaultParameters">Змоўчныя значэньні парамэтраў функцыі</h4>
  <p>Адносна змоўчных значэньняў асобна разгледзім магчымасьць задаваць змоўчныя значэньні парамэтрам функцый:</p>

  <pre><code class="language-js">
// ES5 вэрсія
function drawES5Chart(options) {
  options = options === undefined ? {} : options;
  var size = options.size === undefined ? 'big' : options.size;
  var cords = options.cords === undefined ? { x: 0, y: 0 } : options.cords;
  var radius = options.radius === undefined ? 25 : options.radius;
  console.log(size, cords, radius);
  // now finally do some chart drawing
}

drawES5Chart({
  cords: { x: 18, y: 30 },
  radius: 30
});

// ES6 вэрсія
function drawES6Chart({size = 'big', cords = { x: 0, y: 0 }, radius = 25} = {}) {
  console.log(size, cords, radius);
  // do some chart drawing
}

drawES6Chart({
  cords: { x: 18, y: 30 },
  radius: 30
});
</code></pre>

  <h4 id="Operators_DestructuringAssignments_Objects_NestedObjectsAndArrays">Укладзеныя аб'екты і масівы</h4>
  <p>Састаўныя прысваеньні можна ўжываць і да ўкладзеных аб'ектаў ці масіваў:</p>

  <pre><code class="language-js">
const wes = {
  first: 'Wes',
  last: 'Bos',
  links: {
    social: {
      twitter: 'https://twitter.com/wesbos',
      facebook: 'https://facebook.com/wesbos.developer',
    },
    web: {
      blog: 'https://wesbos.com'
    }
  }
};

const { twitter, facebook } = wes.links.social;
console.log(twitter, facebook); // Выведзе значэньні дзьвюх зьменных
</code></pre>

  <p>Альбо больш складаны прыклад:</p>

  <pre><code class="language-js">
var metadata = {
  title: "Scratchpad",
  translations: [
    {
      locale: "de",
      localization_tags: [ ],
      last_edit: "2014-04-14T08:43:37",
      url: "/de/docs/Tools/Scratchpad",
      title: "JavaScript-Umgebung"
    }
  ],
  url: "/en-US/docs/Tools/Scratchpad"
};

var { title: englishTitle, translations: [{ title: localeTitle }] } = metadata;

console.log(englishTitle); // "Scratchpad"
console.log(localeTitle);  // "JavaScript-Umgebung"
</code></pre>

  <h4 id="Operators_DestructuringAssignments_Objects_InLoops">Ужываньне ў цыклах</h4>

  <pre><code class="language-js">
var people = [
  {
    name: "Mike Smith",
    family: {
      mother: "Jane Smith",
      father: "Harry Smith",
      sister: "Samantha Smith"
    },
    age: 35
  },
  {
    name: "Tom Jones",
    family: {
      mother: "Norah Jones",
      father: "Richard Jones",
      brother: "Howard Jones"
    },
    age: 25
  }
];

for (var {name: n, family: { father: f } } of people) {
  console.log("Name: " + n + ", Father: " + f);
}

// "Name: Mike Smith, Father: Harry Smith"
// "Name: Tom Jones, Father: Richard Jones"
</code></pre>



  <h2 id="Operators_Comparison">Параўнаньня</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">Reference</a></li>
    </ul>
  </div>
  <p>Апэрацыі праверкі ці першы аргумэнт роўны/няроўны другому і праверкі адносінаў большы/меншы паміж імі. Табліца ніжэй утрымлівае апісаньне апэрацыяў параўнаньня, прымаючы, што ў праграме маюцца наступныя аб'яўленьні:</p>

  <pre><code class="language-js">
var var1 = 3, var2 = 4;
</code></pre>

  <table>
    <thead>
    <tr>
      <th>Апэрацыя</th>
      <th>Апісаньне</th>
      <th style="width: 250px;">Прыклады, якія вяртаюць <code class="language-js">true</code></th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code class="language-js">==</code></td>
      <td><em>Роўнасьць</em>. Вяртае <code class="language-js">true</code>, калі апэранды роўныя адзін другому.</td>
      <td>
        <code class="language-js">3 == var1</code> <br />
        <code class="language-js">"3" == var1</code> <br />
        <code class="language-js">3 == '3'</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">!=</code></td>
      <td><em>Няроўнасьць</em>. Вяртае <code class="language-js">true</code>, калі апэранды ня роўныя адзін другому.</td>
      <td>
        <code class="language-js">var1 != 4</code> <br />
        <code class="language-js">var2 != "3"</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">===</code></td>
      <td><em>Строгая роўнасьць</em>. Вяртае <code class="language-js">true</code>, калі апэранды роўныя адзін другому і маюць аднолькавы тып.</td>
      <td>
        <code class="language-js">3 === var1</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">!==</code></td>
      <td><em>Строгая няроўнасьць</em>. Вяртае <code class="language-js">true</code>, калі апэранды ня роўныя адзін другому і/ці маюць адрозныя тыпы.</td>
      <td>
        <code class="language-js">var1 !== "3"</code> <br />
        <code class="language-js">3 !== '3'</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">&gt;</code></td>
      <td><em>Больш</em>. Вяртае <code class="language-js">true</code>, калі левы апэранд большы за правы.</td>
      <td>
        <code class="language-js">var2 &gt; var1</code> <br />
        <code class="language-js">"12" &gt; 2</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">&gt;=</code></td>
      <td><em>Больш ці роўна</em>. Вяртае <code class="language-js">true</code>, калі левы апэранд большы ці роўны праваму.</td>
      <td>
        <code class="language-js">var2 &gt;= var1</code> <br />
        <code class="language-js">var1 &gt;= 3</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">&lt;</code></td>
      <td><em>Менш</em>. Вяртае <code class="language-js">true</code>, калі левы апэранд меншы за правы.</td>
      <td>
        <code class="language-js">var1 &lt; var2</code> <br />
        <code class="language-js">"12" &lt; "2"</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">&lt;=</code></td>
      <td><em>Менш ці роўна</em>. Вяртае <code class="language-js">true</code>, калі левы апэранд меншы ці роўны праваму.</td>
      <td>
        <code class="language-js">var1 &lt;= var2</code> <br />
        <code class="language-js">var2 &lt;= 5</code>
      </td>
    </tr>
    </tbody>
  </table>

  <h2 id="Operators_Arithmetic">Арытмэтычныя</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators">Reference</a></li>
    </ul>
  </div>
  <p>Арытмэтычныя апэрацыі падзяляюцца на ўнарныя (з удзелам аднаго апэранду) і бінарныя (з удзелам 2 апэрандаў).</p>

  <h3 id="ExpressionsAndOperators_Arithmetic_Unary">Унарныя</h3>
  <table>
    <thead>
    <tr>
      <th>Апэрацыя</th>
      <th>Апісаньне</th>
      <th style="width: 200px;">Прыклады</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code class="language-js">+</code></td>
      <td><em>Унарны плюс</em>. Пераўтварае апэранд у лік (ці <a href="#TypesValues_Numbers_NaN"><code class="language-js">NaN</code></a>) і вяртае вынік. Калі ж апэрандам зьяўляецца лік, ня робіць нічога.</td>
      <td>
        <code class="language-js">+"2"; //=> 2 </code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">-</code></td>
      <td><em>Унарны мінус</em>. Пераўтварае апэранд у лік, калі патрэбна, і зьмяняе яго знак на адваротны.</td>
      <td>
        <code class="language-js">-2; //=> -2 </code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">++</code></td>
      <td><em>Інкрымэнт</em>. Павялічвае апэранд (які павінны быць <i>lvalue</i>) на адзінку.</td>
      <td>
        <code class="language-js">a++; //=> a = a + 1 </code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">--</code></td>
      <td><em>Дэкрымэнт</em>. Памяншае апэранд (які павінны быць <i>lvalue</i>) на адзінку.</td>
      <td>
        <code class="language-js">a--; //=> a = a - 1 </code>
      </td>
    </tr>
    </tbody>
  </table>
  <p>Значэньне, якое вяртаюць апэрацыі інкрымэнту і дэкрымэнту, залежыць ад пазыцыі апэрацыі адносна апэранду. Калі апэрацыя зьмяшчаецца перад апэрандам, будзе вернута паменшанае ці павялічанае на адзінку значэньне апэранду. Калі ж апэрацыя зьмешчана пасьля апэранду, будзе вернута нязьменнае значэньне апэранду:</p>

  <pre><code class="language-js">
var i = 1, j = ++i; // абедзьве зьменныя i, j роўныя 2
var i = 1, j = i++; // i роўная 2, j роўная 1
</code></pre>

  <h3 id="Operators_Arithmetic_Binary">Бінарныя</h3>
  <table style="width: 450px;">
    <thead>
    <tr>
      <th>Апэрацыя</th>
      <th>Апісаньне</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code class="language-js">+</code></td>
      <td><em>Складаньне</em>.</td>
    </tr>
    <tr>
      <td><code class="language-js">-</code></td>
      <td><em>Адыманьне</em>.</td>
    </tr>
    <tr>
      <td><code class="language-js">*</code></td>
      <td><em>Памнажэньне</em>.</td>
    </tr>
    <tr>
      <td><code class="language-js">/</code></td>
      <td><em>Дзяленьне</em>.</td>
    </tr>
    <tr>
      <td><code class="language-js">%</code></td>
      <td><em>Знаходжаньне астачы цэлалікавага дзяленьня</em>.</td>
    </tr>
    </tbody>
  </table>

  <h2 id="Operators_Bitwise">Бітавыя</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">Reference</a></li>
    </ul>
  </div>
  <p>Гэтыя апэрацыі ажыцьцяўляюць маніпуляцыі з бітамі лікаў у іх бінарным прадстаўленьні:</p>
  <table>
    <thead>
    <tr>
      <th>Апэрацыя</th>
      <th>Апісаньне</th>
      <th style="width: 300px;">Прыклады</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code class="language-js">&amp;</code></td>
      <td><em>Бітавы AND</em>. Ужывае лягічную апэрацыю AND да ўсіх адпаведных бітаў кожнага з апэрандаў.</td>
      <td>
        <code class="language-js">0x1234 &amp; 0x00FF //=> 0x0034</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">|</code></td>
      <td><em>Бітавы OR</em>. Ужывае лягічную апэрацыю OR да ўсіх адпаведных бітаў кожнага з апэрандаў.</td>
      <td>
        <code class="language-js">0x1234 | 0x00FF //=> 0x12FF</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">^</code></td>
      <td><em>Бітавы выключны OR (XOR)</em>. Ужывае лягічную апэрацыю XOR да ўсіх адпаведных бітаў кожнага з апэрандаў.</td>
      <td>
        <code class="language-js">0xFF00 ^ 0xF0F0 //=> 0x0FF0</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">~</code></td>
      <td><em>Бітавы NOT</em>. Ужывае лягічную апэрацыю NOT да бітаў <strong>адзінага</strong> свайго апэранду. Знак апэрацыі зьмяшчаецца перад апэрандам.</td>
      <td>
        <code class="language-js">~0x0F //=> 0xFFFFFFF0</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">&lt;&lt;</code></td>
      <td><em>Бітавы зрух улева</em>. Зрушвае біты свайго першага апэранду ўлева на колькасьць бітавых пазыцыяў, пазначаных у другім апэрандзе, які павінен быць у межах ад 0 да 31. Пры зруху на адзін біт улева старэйшы (самы левы) біт губляецца, а месца вызваленага малодшага (самага правага) запаўняецца 0. Апэрацыя бітавага зруху ўлева на 1 біт эквівалентна памнажэньню адпаведнага цэлага ліку на 2, зрух на 2 біты&nbsp;&ndash; памнажэньню на 4 і г.д. (2 у адпаведнай ступені)</td>
      <td>
        <code class="language-js">0x000F &lt;&lt; 4  //=> 0x00F0</code>
        <p>што эквівалентна:</p>
        <code class="language-js">15 * 2<sup>4</sup> //=> 15 * 16 = 240</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">&gt;&gt;</code></td>
      <td><em>Бітавы зрух управа з захаваньнем знаку</em>. Зрушвае біты свайго першага апэранду ўправа на колькасьць бітавых пазыцыяў, пазначаных у другім апэрандзе, які павінен быць у межах ад 0 да 31. Пры зруху на адзін біт управа малодшы (самы правы) біт губляецца, а месца вызваленага старэйшага (самага левага) запаўняецца 0 ці 1 у залежнасьці ад знаку першапачатковага ліку (0 у выпадку дадатнага ліку і 1 у выпадку адмоўнага ліку). Апэрацыя бітавага зруху дадатнага ліку ўправа на 1 біт эквівалентна дзяленьню адпаведнага цэлага ліку на 2 з адкіданьнем дробнай часткі, зрух на 2 біты&nbsp;&ndash; дзяленьню на 4 і г.д. (2 у адпаведнай ступені).</td>
      <td>
        <code class="language-js">0x00FF &gt;&gt; 4  //=> 0x000F</code>
        <p>што эквівалентна:</p>
        <code class="language-js">255 / 2<sup>4</sup> //=> 255 / 16 = 15</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-js">&gt;&gt;&gt;</code></td>
      <td><em>Бітавы зрух управа без захаваньня знаку</em>. Аналягічны бітаваму зруху ўправа з захаваньнем знаку, але адрозьніваецца тым, што на месца вызваленых бітаў зьлева падстаўляецца заўсёды 0.</td>
      <td>
        <code class="language-js">−1 &gt;&gt; 4 //=> −1</code>
        <p>але:</p>
        <code class="language-js">−1 &gt;&gt;&gt; 4 //=> 0x0FFFFFFF</code>
      </td>
    </tr>
    </tbody>
  </table>

  <h2 id="Operators_Logical">Лягічныя</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators">Reference</a></li>
    </ul>
  </div>
  <p>Лягічныя апэрацыі ажыцьцяўляюць апэрацыі булевай альгебры над сваімі (звычайна лягічнага тыпу) апэрандамі:</p>
  <table>
    <thead>
    <tr>
      <th>Апэрацыя</th>
      <th>Апісаньне</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code class="language-js">&amp;&amp;</code></td>
      <td><em>Лягічны AND</em>. Вяртае першы з сваіх апэрандаў, калі той можа быць пераўтвораны ў значэньне <code class="language-js">false</code>, альбо другі апэранд у адваротным выпадку. Адпаведна, калі ўжываецца да апэрандаў лягічнага тыпу, верне <code class="language-js">true</code> калі абодва апэранда маюць значэньне <code class="language-js">true</code>, інакш верне <code class="language-js">false</code>.</td>
    </tr>
    <tr>
      <td><code class="language-js">||</code></td>
      <td><em>Лягічны OR</em>. Вяртае першы з сваіх апэрандаў, калі той можа быць пераўтвораны ў значэньне <code class="language-js">true</code>, альбо другі апэранд у адваротным выпадку. Адпаведна, калі ўжываецца да апэрандаў лягічнага тыпу, верне <code class="language-js">true</code> калі хаця б адзін з апэрандаў мае значэньне <code class="language-js">true</code>, калі ж абодва маюць значэньне <code class="language-js">false</code>, вынікам будзе таксама <code class="language-js">false</code>.</td>
    </tr>
    <tr>
      <td><code class="language-js">!</code></td>
      <td><em>Лягічны NOT</em>. Верне <code class="language-js">false</code>, калі адзіны яго апэранд можа быць пераўтвораны ў <code class="language-js">true</code>, інакш верне <code class="language-js">true</code>.</td>
    </tr>
    </tbody>
  </table>

  <h3 id="Operators_Logical_Examples">Прыклады</h3>

  <pre><code class="language-js">
true  && true;     // true  && true  => true
true  && false;    // true  && false => false
false && true;     // false && true  => false
false && (3 == 4); // false && false => false
"Cat" && "Dog";    // true  && true  => "Dog"
false && "Cat";    // false && true  => false
"Cat" && false;    // true  && false => false

true  || true;     // true  || true  => true
false || true;     // false || true  => true
true  || false;    // true  || false => true
false || (3 == 4); // false || false => false
"Cat" || "Dog";    // true  || true  => "Cat"
false || "Cat";    // false || true  => "Cat"
"Cat" || false;    // true  || false => "Cat"

!true;             // !true  => false
!false;            // !false => true
!"Cat";            // !true  => false
</code></pre>

  <h2 id="Operators_Object">Аб'ектныя</h2>

  <h3 id="Operators_Object_PropertyAccess">Доступу да атрыбутаў</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors">Reference</a></li>
    </ul>
  </div>
  <p>Апэрацыя доступу да атрыбутаў дазваляе атрымаць ці прысвоіць значэньне атрыбуту аб'екта альбо элемэнту масіву. Існуе 2 варыянты гэтай апэрацыі. У першым зь іх імя атрыбуту ідзе праз кропку пасьля ідэнтыфікатару аб'екта, у другім&nbsp;&ndash; заключана ў прамавугольныя дужкі пасьля ідэнтыфікатару:</p>

  <pre><code class="language-js">
object_name.attribute_name
object_name["attribute_name"]
</code></pre>

  <h3 id="Operators_Object_delete"><code class="language-js">delete</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete">Reference</a></li>
    </ul>
  </div>
  <p>Апэрацыя выдаляе атрыбут аб'екта ці элемэнт масіву.</p>

  <pre><code class="language-js">
var o = { x: 1, y: 2};    // Аб'яўляем аб'ект
delete o.x;               // Выдаляем адзін зь ягоных атрыбутаў
"x" in o;                 // => false: атрыбут не існуе

var a = [1,2,3];          // Аб'яўляем масіў
delete a[2];              // Выдаляем яго апошні элемэнт
a.length;                 // => 2: масіў утрымлівае цяпер 2 элемэнты
</code></pre>

  <p>Калі апэрацыя выкананая пасьпяхова, яна выдаляе атрыбут у аб'екта. Але, калі ў ланцугу прататыпаў аб'екта існуе атрыбут з такім жа імем, ён будзе успадкаваны аб'ектам адтуль.</p>
  <p>Апэрацыя ня можа быць ужытая да <a href="#TypesValues_Variables">зьменных</a>, функцый, а таксама да пэўных атрыбутаў <a href="#CoreObjects">базавых аб'ектаў</a>.</p>


  <h3 id="Operators_Object_get"><code class="language-js">get</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">Reference</a></li>
    </ul>
  </div>
  <p>Калі значэньне нейкага атрыбуту аб'екта павінна разьлічвацца дынамічна, яго можна не аб'яўляць наўпрост, а скарыстацца мэханізмам гэтэраў:</p>

  <pre data-line="3,8"><code class="language-js">
var obj = {
  log: ['test'],
  get latest() {
    if (this.log.length == 0) return undefined;
    return this.log[this.log.length - 1];
  }
}
console.log(obj.latest); // Will return "test".
</code></pre>

  <h3 id="Operators_Object_in"><code class="language-js">in</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in">Reference</a></li>
    </ul>
  </div>
  <p>Апэрацыя служыць для праверкі ці існуе пэўны атрыбут у аб'екце ці пэўны элемэнт масіву:</p>

  <pre><code class="language-js">
// Масівы
var trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees        // Верне true
3 in trees        // Верне true
6 in trees        // Верне false
"bay" in trees    // Верне false (прыстасоўна да масіваў трэба пазначаць індэкс элемэнту,
                  // які трэба праверыць, а не яго яго значэньне)
"length" in trees // Верне true (length &ndash; гэта атрыбут аб'екта Array)
Symbol.iterator in trees // Верне true (масівы перабіраюцца, працуе толькі ў ES6+)

// Прадвызначаныя аб'екты
"PI" in Math      // Верне true

// Уласныя аб'екты
var mycar = {make: "Honda", model: "Accord", year: 1998};
"make" in mycar   // Верне true
"model" in mycar  // Верне true
</code></pre>

  <p>Справа ад знака апэрацыі павінен стаяць аб'ект, элемэнтарныя тыпы ня могуць зьмяшчацца:</p>

  <pre><code class="language-js">
var color1 = new String("green");
"length" in color1 // Верне true

var color2 = "coral";
// Будзе кінутая памылка (color2 &ndash; гэта не аб'ект тыпу String)
"length" in color2
</code></pre>

  <p>Калі элемэнт масіву ці атрыбут аб'екта быў папярэдне выдалены пры дапамозе апэрацыі <a href="#Operators_Object_delete"><code class="language-js">delete</code></a>, апэрацыя <code class="language-js">in</code> зразумела верне <code class="language-js">false</code> пры праверцы гэтага элемэнту/атрыбуту. Калі элемэнту масіва альбо атрыбуту аб'екта прысвоіць значэньне <code class="language-js">undefined</code>, тады апэрацыя <code class="language-js">in</code> верне <code class="language-js">true</code>:</p>

  <pre><code class="language-js">
var mycar = {make: "Honda", model: "Accord", year: 1998};
mycar.make = undefined;
"make" in mycar;  // Верне true
</code></pre>

  <p>Апэрацыя правярае ўсю герархію аб'екта, таму верне <code class="language-js">true</code> пры праверцы атрыбуту, які яўна не быў вызначаны ў аб'екце, але ўспадкаваў яго ад бацькоўскіх аб'ектаў (<i>prototype chain</i>):</p>

  <pre><code class="language-js">
"toString" in {}; // Верне true
</code></pre>


  <h3 id="Operators_Object_instanceof"><code class="language-js">instanceof</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof">Reference</a></li>
    </ul>
  </div>
  <p>Правярае ці зьяўляецца левы апэранд аб'ектам клясы, якая прадстаўленая правым апэрандам. Больш дакладна з тэхнічнага пункту гледжаньня&nbsp;&ndash; ці знаходзіцца значэньне атрыбуту <code class="language-js">prototype</code> правага апэранду (клясы, ці функцыі іншымі словамі) у прататыпным ланцугу левага апэранду:</p>

  <pre><code class="language-js">
// defining constructors
function C() {}
function D() {}

var o = new C();

// true, because: Object.getPrototypeOf(o) === C.prototype
o instanceof C;

// false, because D.prototype is nowhere in o's prototype chain
o instanceof D;

o instanceof Object; // true, because:
C.prototype instanceof Object // true

C.prototype = {};
var o2 = new C();

o2 instanceof C; // true

// false, because C.prototype is nowhere in
// o's prototype chain anymore
o instanceof C;

D.prototype = new C(); // add C to [[Prototype]] linkage like'inheritance'
var o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true
</code></pre>

  <p>Ніжэй пададзены прыклад, які паказвае, што аб'екты клясаў <code class="language-js">String</code> і <code class="language-js">Date</code> зьяўляюцца таксама і аб'ектамі клясы <code class="language-js">Object</code>, ад якой яны насьледуюць. Ён таксама паказвае выключныя выпадкі, калі аб'ект створаны праз літаралы (функцыянальны <code class="language-js">{...}</code> і радковы):</p>

  <pre><code class="language-js">
var simpleStr = 'This is a simple string';
var myString  = new String();
var newStr    = new String('String created with constructor');
var myDate    = new Date();
var myObj     = {};

simpleStr instanceof String; // returns false, checks the prototype chain, finds undefined
myString  instanceof String; // returns true
newStr    instanceof String; // returns true
myString  instanceof Object; // returns true

myObj instanceof Object;    // returns true, despite an undefined prototype
({})  instanceof Object;    // returns true, same case as above

myString instanceof Date;   // returns false

myDate instanceof Date;     // returns true
myDate instanceof Object;   // returns true
myDate instanceof String;   // returns false
</code></pre>

  <p>І яшчэ адзін больш набліжаны да жыцьця прыклад:</p>

  <pre><code class="language-js">
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
var mycar = new Car('Honda', 'Accord', 1998);
var a = mycar instanceof Car;    // returns true
var b = mycar instanceof Object; // returns true
</code></pre>

  <h3 id="Operators_Object_new"><code class="language-js">new</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">Reference</a></li>
    </ul>
  </div>
  <p>Апэрацыя стварае новы аб'ект карыстальніцкай альбо убудаванай клясы:</p>

  <pre><code class="language-js">
function Car() {}
car1 = new Car();

console.log(car1.color);    // undefined

Car.prototype.color = null;
console.log(car1.color);    // null

car1.color = 'black';
console.log(car1.color);   // black
</code></pre>

  <h3 id="Operators_Object_set"><code class="language-js">set</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set">Reference</a></li>
    </ul>
  </div>
  <p>І аналягічна, калі ўстаноўка значэньня павінна быць дынамічнай, можна скарыстацца мэханізмам сэтэраў:</p>

  <pre data-line="2,8,11"><code class="language-js">
var language = {
  set current(name) {
    this.log.push(name);
  },
  log: []
}

language.current = 'EN';
console.log(language.log); // ['EN']

language.current = 'FA';
console.log(language.log); // ['EN', 'FA']
</code></pre>

  <h3 id="Operators_Object_this"><code class="language-js">this</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">Reference</a></li>
    </ul>
  </div>
  <p>У <i>JavaScript</i>, як і ў бальшыні іншых аб'ектна-арыентаваных мовах праграмаваньня, ключавое слова <code class="language-js">this</code> служыць для таго, каб можна было спасылацца знутры функцыі да аб'екта, які гэтую функцыю утрымлівае. Але існуе некалькі ўласьцівых <i>JavaScript</i> асаблівасьцяў, на якіх варта спыніцца. Каб вызначыць, на што спасылаецца <code class="language-js">this</code>, трэба кіравацца наступным альгарытмам:</p>
  <ul>
    <li>Калі выклік функцыі адбыўся пры дапамозе <a href="#CoreObjects_Function_Methods_apply"><code class="language-js">apply</code></a>, <a href="#CoreObjects_Function_Methods_bind"><code class="language-js">bind</code></a> ці <a href="#CoreObjects_Function_Methods_call"><code class="language-js">call</code></a>, <code class="language-js">this</code> будзе роўны першаму аргумэнту, які быў перададзены <code class="language-js">apply</code>/<code class="language-js">bind</code>/<code class="language-js">call</code>. Калі ж першым аргумэнтам быў перададзены <code class="language-js">null</code> ці <code class="language-js">undefined</code>, <code class="language-js">this</code> будзе спасылацца на глябальны аб'ект (<code class="language-js">window</code> у выпадку браўзэра).

      <pre><code class="language-js">
var myObject = {
  sayHello : function() {
    console.log('Hi! My name is ' + this.myName);
  },

  myName : 'Rebecca'
};

var secondObject = {
  myName : 'Colin'
};

myObject.sayHello();                  // Вывядзе ў лог 'Hi! My name is Rebecca'
myObject.sayHello.call(secondObject); // Вывядзе ў лог 'Hi! My name is Colin'
</code></pre>

    </li>
    <li>Калі выклік функцыі адбыўся ў якасьці апрацоўшчыка падзеі (не знутры апрацоўшчыка падзеі, а менавіта як апрацоўшчык падзеі), тады <code class="language-js">this</code> будзе спасылацца на аб'ект, для якога гэтая падзея спрацавала.

    <pre><code class="language-js">
function bluify(e) {
  this.style.backgroundColor = '#A5D9F3'; // Пры кліку на пэўным элемэнце зробіць
}                                         // яго колер блакітным
// Атрымліваем сьпіс усіх элемэнтаў дакумэнту
var elements = document.getElementsByTagName('*');

// ... і дадаем да іх у якасьці апрацоўшчыку клікаў функцыю bluify
for(var i = 0 ; i < elements.length ; i++){
  elements[i].addEventListener('click', bluify, false);
}
</code></pre>

    </li>
    <li>Калі функцыя выклікана як мэтад аб'екта, тады <code class="language-js">this</code> будзе спасылацца на гэты аб'ект.</li>
    <li>Інакш <code class="language-js">this</code> будзе спасылацца на глябальны аб'ект.</li>
  </ul>

  <h3 id="Operators_Object_typeof"><code class="language-js">typeof</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">Reference</a></li>
    </ul>
  </div>
  <p>Апэрацыя вяртае тэкставае значэньне тыпу свайго апэранду:</p>

  <pre><code class="language-js">
// Numbers
typeof 37 === 'number';
typeof 3.14 === 'number';
typeof(42) === 'number';
typeof Math.LN2 === 'number';
typeof Infinity === 'number';
typeof NaN === 'number'; // Despite being "Not-A-Number"
typeof Number(1) === 'number'; // but never use this form!

// Strings
typeof '' === 'string';
typeof "bla" === 'string';
typeof (typeof 1) === 'string'; // typeof always returns a string
typeof String('abc') === 'string'; // but never use this form!

// Booleans
typeof true === 'boolean';
typeof false === 'boolean';
typeof Boolean(true) === 'boolean'; // but never use this form!

// Symbols
typeof Symbol() === 'symbol'
typeof Symbol('foo') === 'symbol'
typeof Symbol.iterator === 'symbol'


// Undefined, null
typeof undefined === 'undefined';
typeof declaredButUndefinedVariable === 'undefined';
typeof undeclaredVariable === 'undefined';
typeof null === 'object';

// Objects
typeof {a: 1} === 'object';

// use Array.isArray or Object.prototype.toString.call
// to differentiate regular objects from arrays
typeof [1, 2, 4] === 'object';

typeof new Date() === 'object';

// The following is confusing. Don't use!
typeof new Boolean(true) === 'object';
typeof new Number(1) === 'object';
typeof new String('abc') === 'object';

// Functions
typeof function() {} === 'function';
typeof class C {} === 'function';
typeof Math.sin === 'function';
</code></pre>

  <h2 id="Operators_Special">Асаблівыя</h2>

  <h3 id="Operators_Special_Conditional">Умоўная</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">Reference</a></li>
    </ul>
  </div>
  <p>Гэта адзіная тэрнарная (якая прымае 3 апэранды) апэрацыя ў <i>JavaScript</i>. Яна зазвычай ужываецца як больш кароткая форма <a href="#Statements_Conditional_if...else">ўмоўнай інструкцыі</a>:</p>

  <pre><code class="language-js">
x > 0 ? x : -x      // Вяртаецца абсалютнае значэньне x
</code></pre>

  <p>Апэрандамі гэтай апэрацыі могуць быць любыя тыпы. Спачатку вылічваецца першы апэранд (да знака пытальніка) і інтэрпрытуецца як <a href="#TypesValues_Booleans">лягічнае значэньне</a>, калі яно вернае&nbsp;&ndash; тады вылічваецца і вяртаецца другі апэранд (пасьля знака пытальніка і перад двукроп'ем), калі ня вернае&nbsp;&ndash; вылічваецца і вяртаецца трэці апэранд (пасьля двукроп'я). Вылічваецца заўсёды толькі адзін з двух апошніх апэрандаў&nbsp;&ndash; альбо другі, альбо трэці.</p>
  <p>Хаця таго ж самага эфэкту можна дасягнуць пры дапамозе <a href="#Statements_Conditional_if...else">ўмоўнай інструкцыі</a>, тэрнарная апэрацыя зьяўляецца больш кампактнай. Грувасткая ўмоўная інструкцыя:</p>

  <pre><code class="language-js">
greeting = "hello ";
if (username) {
  greeting += username;
} else {
  greeting += "there";
}
</code></pre>

  <p>І значна больш кампактная тэрнарная апэрацыя:</p>

  <pre><code class="language-js">
greeting = "hello " + (username ? username : "there");
</code></pre>

  <h3 id="Operators_Special_Comma">Апэрацыя-коска</h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator">Reference</a></li>
    </ul>
  </div>
  <p>Гэтая апэрацыя вылічвае свае апэранды (зьлева направа) і вяртае значэньне апошняга зь іх. Яе прызначэньне&nbsp;&ndash; даць магчымасьць уставіць некалькі выразаў у месца, дзе чакаецца толькі адзін <a href="#Expressions">выраз</a>. Найбольш выкарыстоўваецца ўнутры <a href="#Statements_Loops_for">інструкцыі цыкла</a>:</p>

  <pre><code class="language-js">
for (var i=0, j=10; i < j; i++, j--) {
  console.log(i+j);
}
</code></pre>

  <p>Інструкцыя цыкла чакае адзін выраз пасьля другой кропкі з коскай, але мы можам уставіць 2 выразы, падзяліўшы іх коскай: <code class="language-js">i++, j--</code>.</p>

  <h3 id="Operators_Special_void"><code class="language-js">void</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void">Reference</a></li>
    </ul>
  </div>
  <p>Гэтая апэрацыя вылічвае свой апэранд, а затым вяртае <code class="language-js"><a href="#TypesValues_undefined">undefined</a></code>. Адзін з магчымых спосабаў выкарыстаньня&nbsp;&ndash; імгненны выклік функцыі пры яе аб'яўленьні:</p>

  <pre><code class="language-js">
void function fun() {
    // цела функцыі
}();
</code></pre>

  <p>У гэтым выпадку <a href="#Lexic_Keywords">ключавое слова</a> <code class="language-js">function</code> трактуецца не як аб'яўленьне функцыі, а як выраз для выкананьня. У выніку функцыя <code class="language-js">fun</code> будзе не проста аб'яўленая, але і адразу ж выкананая.</p>
</section>

<section>
  <h1 id="Statements" data-content-item-open>Інструкцыі</h1>
  <p>Калі <a href="#Expressions">выразы</a>&nbsp;&ndash; гэта фразы <i>JavaScript</i>, дык інструкцыі&nbsp;&ndash; гэта сказы (альбо каманды) <i>JavaScript</i>. Калі ў звычайнай мове сказы падзяляюцца адзін ад другога кропкай, дык інструкцыі ў <i>JavaScript</i> падзяляюцца адна ад другой кропкай з коскай. Выразы разьлічваюцца, каб атрымаць нейкае значэньне, а інструкцыі выконваюцца, каб зрабіць нейкае дзеяньне.</p>

  <h2 id="Statements_Expressions">Інструкцыі-выразы</h2>
  <p>Найбольш простымі інструкцыямі зьяўляюцца выразы, якія маюць пабочнае дзеяньне, напрыклад&nbsp;&ndash; выраз прысваеньня. Ён ня толькі вылічвае нейкае значэньне, але і прысвойвае яго аднаму са сваіх апэрандаў:</p>

  <pre><code class="language-js">
greeting = "Hello " + name;
i *= 3;
</code></pre>

  <p>Таксама выразы інкрымэнту і дэкрымэнту, выкліку функцый і падобныя маюць пабочныя эфэкты і могуць зьяўляюцца адначасова інструкцыямі.</p>

  <h2 id="Statements_EmptyAndCompound">Пустыя і састаўныя</h2>
  <p>Інструкцыя можа быць пустой, калі ў месцы, дзе чакаецца інструкцыя зьмяшчаецца кропка з коскай і больш нічога:</p>

  <pre><code class="language-js">
for(i = 0; i < a.length; a[i++] = 0) ;  // пасьля закрываючай дужкі чакаецца інструкцыя
                                        // якая будзе выконвацца n-разоў у цыклі, але мы
                                        // не зьмясьцілі там ніякага выразу і адразу
                                        // паставілі кропку з коскай
</code></pre>

  <p>ці састаўной, калі некалькі інструкцыяў спалучаюцца ў адзін блёк лягічна злучаных інструкцыяў пры дапамозе фігурных дужак (усё ад адкрываючай да закрываючай дужак уключна завецца састаўной інструкцыяй):</p>

  <pre><code class="language-js">
// У целе цыкла адбываецца і ініцыіраваньне элемэнтаў масіву, і вывад у лог
for (i = 0; i < a.length; i++) {
    a[i] = i;
    console.log("value of a[" + i +"] = " + i);
}
</code></pre>

  <h2 id="Statements_Declarations">Аб'яўленьняў</h2>

  <h3 id="Statements_Declarations_class"><code class="language-js">class</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class">Reference</a></li>
    </ul>
  </div>
  <p><a href="#Lexic_Keywords">Ключавое слова</a> <code class="language-js">class</code> служыць для вызначэньня клясаў з пазначаным імем, выкарыстоўваючы прататыпнае насьледаваньне. Яно таксама можа быць выкарыстана ў выглядзе <a href="#Expressions">выразу</a>:</p>

  <pre><code class="language-js">
var MyClass = class [className] [extends] {  // Выраз (кляса прызначаецца зьменнай)
  // class body
};

class name [extends] {                       // Інструкцыя
  // class body
}
</code></pre>

  <p>Прыклад:</p>

  <pre><code class="language-js">
var Foo = class {
  constructor() {}
  bar() {
    return 'Hello World!';
  }
};

var instance = new Foo();
instance.bar(); // "Hello World!"
Foo.name; // "Foo"
</code></pre>

  <p>Выраз і інструкцыя вызначэньня клясы падобныя адна на другую, але ў выпадку выразу імя клясы можна (але не абавязкова) апускаць. Калі імя клясы ў выразе пазначана, яно (імя) будзе даступнае толькі ў целе самой гэтай клясы:</p>

  <pre><code class="language-js">
var Foo = class NamedFoo {
  constructor() {}
  whoIsThere() {
    return NamedFoo.name;
  }
}
var bar = new Foo();
bar.whoIsThere(); // "NamedFoo"
NamedFoo.name; // ReferenceError: NamedFoo is not defined
Foo.name; // "NamedFoo"
</code></pre>

  <p>У прыкладзе ніжэй мы вызначаем клясу <code class="language-js">Polygon</code>, а потым пашыраем яе вызначаючы клясу <code class="language-js">Square</code>. Зьвярніце ўвагу, што выклік <code class="language-js">super()</code>, які выкарыстоўваецца ў клясе <code class="language-js">Square</code>, можа быць выкліканы толькі ў канструктары і павінен быць выкліканы перад першым зьвяртаньнем да ключавога слова <code class="language-js">this</code>:</p>

  <pre><code class="language-js">
class Polygon {
  constructor(height, width) {
    this.name = 'Polygon';
    this.height = height;
    this.width = width;
  }
}

class Square extends Polygon {
  constructor(length) {
    super(length, length);
    this.name = 'Square';
  }
}
</code></pre>

  <h3 id="Statements_Declarations_const"><code class="language-js">const</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">Reference</a></li>
    </ul>
  </div>
  <p>Аб'яўленьне <a href="#TypesValues_Variables_Scope">блёчных</a> <a href="#TypesValues_Constants">канстантаў</a>:</p>

  <pre><code class="language-js">
if (true) {
  const MY_FAV = 20;
}
</code></pre>

  <h3 id="Statements_Declarations_function"><code class="language-js">function</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function">Reference</a></li>
    </ul>
  </div>
  <p><a href="#Lexic_Keywords">Ключавое слова</a> <code class="language-js">function</code> служыць для вызначэньня функцыяў. Яно таксама можа быць выкарыстана ў выглядзе <a href="#Expressions">выразу</a>:</p>

  <pre><code class="language-js">
var f = function(x) { return x+1; }     // Выраз (функцыя прызначаецца зьменнай)
function f(x) { return x+1; }           // Інструкцыя
</code></pre>

  <p>Выраз і інструкцыя вызначэньня функцыі падобныя адна на другую, але ў выпадку выразу імя функцыі можна (але не абавязкова) апускаць. Калі імя функцыі ў выразе пазначана, яно (імя) будзе даступнае толькі ў целе самой гэтай функцыі.</p>
  <p>Пры вызначэньні функцыі ствараецца <a href="#ObjectModel">аб'ект</a> <a href="#CoreObjects_Function"><code class="language-js">Function</code></a>, якому ўласьцівыя атрыбуты, мэтады і паводзіны апошняга.</p>
  <p>Сынтаксіс аб'яўленьня функцыі ў агульным выпадку выглядае наступным чынам:</p>

  <pre><code class="language-js">
function funcname([arg1 [, arg2 [..., argn]]]) {
    statements
}
</code></pre>

  <p>Дзе <code class="language-js">funcname</code>&nbsp;&ndash; гэта <a href="#Lexic_Identifiers">ідэнтыфікатар</a>, які задае імя новай функцыі. Пасьля імені ставяцца круглыя дужкі, у якіх праз коску могуць ісьці парамэтры функцыі (але сьпіс парамэтраў можа быць і пустым). Гэтыя ідэнтыфікатары выкарыстоўваюцца для доступу да значэньняў, якія перадаюцца ў функцыю пры яе выкліку. Цела функцыі можа складацца зь любой колькасьці інструкцыяў, якія заключаюцца ў фігурныя дужкі. Пры гэтым фігурныя дужкі абавязковыя для ўжываньня, нават калі цела функцыі пустое. Таксама фігурныя дужкі нельга апускаць, калі цела функцыі ўтрымлівае толькі адну інструкцыю, у адрозьненьні ад сынтаксісу напрыклад <a href="#Statements_Conditional_if...else">умоўнай інструкцыі</a>, дзе фігурныя дужкі дазваляецца апускаць у такім выпадку. Інструкцыі, якія ўтрымлівае цела функцыі выконваюцца не адразу пасьля аб'яўленьня функцыі, але пры яе выкліку.</p>

  <h3 id="Statements_Declarations_let"><code class="language-js">let</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">Reference</a></li>
    </ul>
  </div>
  <p>Аб'яўленьне <a href="#TypesValues_Variables_Scope">блёчных</a> <a href="#TypesValues_Variables">зьменных</a>:</p>

  <pre><code class="language-js">
if (true) {
  let x = 2;        // Зьменная ўзроўню if-блёка, па-за межамі гэтага блёку не існуе
}
</code></pre>

  <h3 id="Statements_Declarations_var"><code class="language-js">var</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var">Reference</a></li>
    </ul>
  </div>
  <p>Аб'яўленьне <a href="#TypesValues_Variables_Scope">глябальных і <i>function-scoped</i></a> <a href="#TypesValues_Variables">зьменных</a>:</p>

  <pre><code class="language-js">
var i;                                      // Аб'яўленьне без ініцыіраваньня
var j = 0;                                  // + ініцыіраваньне
var p, q;                                   // Аб'яўленьне дзьвюх зьменных у адной інструкцыі
var greeting = "hello" + name;              // Ініцыіраваньне праз выраз
var x = 2.34, y = Math.cos(0.75), r, theta; // Шмат зьменных
var x = 2, y = x*x; // Аб'яўленьне другой зьменнай выкарыстоўвае першую
var x = 2,                                  // Шмат зьменных,
    f = function(x) { return x*x },         // кожная на асобным
    y = f(x);                               // радку
</code></pre>

  <h2 id="Statements_Conditional">Умоўныя</h2>
  <p>Умоўныя інструкцыі дазваляюць выконваць іншыя інструкцыі толькі пры пэўных умовах. Яны дазваляюць разгаліноўваць плынь вашай праграмы.</p>

  <h3 id="Statements_Conditional_if...else"><code class="language-js">if...else</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else">Reference</a></li>
    </ul>
  </div>
  <p>Гэта базавая канструкцыя ўмоўнага выкананьня. Сынтаксіс яе ў агульным выпадку наступны:</p>

  <pre><code class="language-js">
if (expression) {
  statement1
} else {
  statement2
}
</code></pre>

  <p>Калі ўмоўны <a href="#Expressions">выраз</a> <code class="language-js">expression</code> верны, будзе выкананая інструкцыя <code class="language-js">statement1</code>, інакш&nbsp;&ndash; інструкцыя <code class="language-js">statement2</code>. Напрыклад:</p>

  <pre><code class="language-js">
if (n == 1) {
  console.log("У вас адно новае паведамленьне.");
} else {
  console.log("У вас " + n + " новых паведамленьняў.");
}
</code></pre>

  <p>Частка «інакш» (<code class="language-js">else</code>) можа быць апушчаная (калі ўмова выконваецца зрабіць нешта, інакш нічога не рабіць):</p>

  <pre><code class="language-js">
// Калі імя роўнае null, undefined, false, 0, "", ці NaN, задаць новае імя
if (!username) {
  username = "Alesj Zagorski";
}
</code></pre>

  <p>Калі пэўная лёгіка мае не 1 ці 2 варыянты (верна/ня верна), а больш, умоўныя інструкцыі можна злучаць адна за адной наступным чынам:</p>

  <pre><code class="language-js">
if (n == 1) {
  // Выканаць блёк коду №1
} else if (n == 2) {
  // Выканаць блёк коду №2
} else if (n == 3) {
  // Выканаць блёк коду №3
} else {
  // Калі ўсе вышэйпрыведзеныя ўмовы ня верныя, выканаць блёк коду №4
}
</code></pre>

  <h3 id="Statements_Conditional_switch"><code class="language-js">switch</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch">Reference</a></li>
    </ul>
  </div>
  <p>Калі ў чарадзе злучаных адна за адной <code class="language-js">if...else</code>-інструкцыяў правяраецца адзін і той жа выраз (значэньне зьменнай <code class="language-js">n</code> у апошнім прыкладзе папярэдняга разьдзелу), тады лепшым рашэньнем будзе выкарыстаць інструкцыю <code class="language-js">switch</code>, хаця б для таго, каб не вылічваць значэньне аднаго і таго ж выразу некалькі разоў. Сынтаксіс гэтай інструкцыі ў агульным выпадку наступны:</p>

  <pre><code class="language-js">
switch (expression) {
  case value1:
    // Інструкцыі, якія будуць выкананыя, калі выраз expression
    // будзе мець значэньне value1
    [break;]
  case value2:
    // Інструкцыі, якія будуць выкананыя, калі выраз expression
    // будзе мець значэньне value2
    [break;]
  ...
  case valueN:
    // Інструкцыі, якія будуць выкананыя, калі выраз expression
    // будзе мець значэньне valueN
    [break;]
  default:
    // Інструкцыі, якія будуць выкананыя, калі сярод усіх пералічаных значэньняў
    // ня будзе аніводнага, якія б супадаў са значэньнем выразу expression
    [break;]
}
</code></pre>

  <p>Тады перадапошні прыклад з чарадой <code class="language-js">if...else</code>-інструкцыяў можна будзе запісаць наступным чынам:</p>

  <pre><code class="language-js">
switch (n) {
  case 1:                     // Пачаць тут, калі n == 1
    // Выканаць блёк коду №1
    break;                    // Спыніцца тут
  case 2:                     // Пачаць тут, калі n == 2
    // Выканаць блёк коду №2
    break;                    // Спыніцца тут
  case 3:                     // Пачаць тут, калі n == 3
    // Выканаць блёк коду №3
    break;                    // Спыніцца тут
  default:                    // Інакш пачаць тут
    // Калі ўсе вышэйпрыведзеныя ўмовы ня верныя, выканаць блёк коду №4
    break;                    // Спыніцца тут
}
</code></pre>

  <p>Зьвярніце ўвагу на меткі <code class="language-js">break</code> у канцы кожнага блёку. Іх прысутнасьць тлумачыцца тым, што меткі <code class="language-js">case</code> вызначаюць пачатак таго блёку, які павінен быць выкананы, але не вызначаюць яго канец. Для гэтай мэты і прызначаны меткі <code class="language-js">break</code>. Калі інтэрпрэтатар сустракае іх, ён спыняе выкананьне інструкцыі <code class="language-js">switch</code> і пераходзіць да інструкцыі, наступнай за <code class="language-js">switch</code>.</p>

  <h2 id="Statements_Loops">Цыклаў</h2>
  <p>Інструкцыі цыкла дазваляюць выконваць адну ці некалькі інструкцыяў некалькі разоў пакуль выконваецца пэўная ўмова. Адзін з відавочных прыкладаў цыклічных інструкцыяў&nbsp;&ndash; выкананьне нейкай апэрацыі над усімі элемэнтамі пэўнага масіву. </p>

  <h3 id="Statements_Loops_while"><code class="language-js">while</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while">Reference</a></li>
    </ul>
  </div>
  <p>Базавая інструкцыя цыкла&nbsp;&ndash; <code class="language-js">while</code>. Яе сынтаксіс наступны:</p>

  <pre><code class="language-js">
while (condition)
  statement
</code></pre>

  <p>Калі інтэрпрэтатар сустракае <code class="language-js">while</code>-інструкцыю, ён спачатку разьлічвае выраз <code class="language-js">condition</code>. Калі ў выніку атрымліваецца «ілжывае» значэньне, тады цела цыкла (інструкцыя <code class="language-js">statement</code>) прапускаецца і выконваецца інструкцыя, якая ідзе за <code class="language-js">while</code>. Калі ж значэньне выразу наадварот «вернае», тады выконваецца цела цыкла, а пасьля ізноў вылічваецца значэньне выразу <code class="language-js">condition</code> і ўсё паўтараецца ізноў. Калі цела цыкла павінна ўтрымліваць некалькі інструкцыяў, іх трэба аб'яднаць у <a href="#Statements_EmptyAndCompound">састаўны блёк</a> <code class="language-js">{...}</code>.</p>
  <p>Прыклад ужываньня:</p>

  <pre><code class="language-js">
var n = 0;
var x = 0;

while (n < 3) {
  n++;
  x += n;
}
</code></pre>

  <p>Вышэйпрыведзены цыкл будзе выконвацца да таго часу, пакуль значэньне зьменнай <code class="language-js">n</code> меншае за 3. У кожным з «праходаў» цыкла значэньне зьменнай <code class="language-js">n</code> павялічваецца на 1, а значэньне зьменнай <code class="language-js">х</code> павялічваецца на значэньне зьменнай <code class="language-js">n</code>. У выніку атрымаем наступнае:</p>
  <ul>
    <li>У канцы першага праходу: <code class="language-js">n = 1</code>, <code class="language-js">x = 1</code></li>
    <li>У канцы другога праходу: <code class="language-js">n = 2</code>, <code class="language-js">x = 3</code></li>
    <li>У канцы трэцяга праходу: <code class="language-js">n = 3</code>, <code class="language-js">x = 6</code></li>
  </ul>

  <h3 id="Statements_Loops_do...while"><code class="language-js">do...while</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/do...while">Reference</a></li>
    </ul>
  </div>
  <p>Гэтая інструкцыя амаль цалкам падобная на <a href="#Statements_Loops_while">папярэднюю</a>, але ў ёй спачатку выконваецца цела цыкла, а ўжо потым правяраецца ўмова. Калі вынік умоўнага выразу верны, тады цела цыкла выконваецца ізноў, інакш выкананьне цыкла спыняецца і адбываецца пераход да інструкцыі, якая ідзе за цыклам. Такім чынам, цела цыкла будзе выканана прынамсі адзін раз, незалежна ад значэньня умоўнага выразу. Сынтаксіс інструкцыі ў агульным выпадку наступны:</p>

  <pre><code class="language-js">
do
  statement
while (condition);
</code></pre>

  <p>Прыклад ужываньня:</p>

  <pre><code class="language-js">
var i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
</code></pre>

  <p>У выніку выкананьня папярэдняга фрагмэнту коду ў кансоль будуць выведзеныя пасьлядоўна лічбы ад 1 да 5 уключна.</p>

  <h3 id="Statements_Loops_for"><code class="language-js">for</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for">Reference</a></li>
    </ul>
  </div>
  <p>Наступная інструкцыя цыкла&nbsp;&ndash; гэта інструкцыя <code class="language-js">for</code>. Яе сынтаксіс у агульным выпадку наступны:</p>

  <pre><code class="language-js">
for ([initialization]; [condition]; [increment])
  statement
</code></pre>

  <p>дзе:</p>
  <ul>
    <li><code class="language-js">initialization</code>&nbsp;&ndash; выраз ініцыіраваньня цыкла. Ён выконваецца аднойчы ў самым пачатку, і выкарыстоўваецца звычайна для вызначэньня альбо ініцыіраваньня лічыльніка цыкла. </li>
    <li><code class="language-js">condition</code>&nbsp;&ndash; умоўны выраз, які выконваецца перад кожным праходам цыкла, у тым ліку перад першым. Калі яго значэньне вернае, тады выконваецца цела цыкла з інструкцыяй <code class="language-js">statement</code>, інакш выкананьне цыкла спыняецца. Гэты выраз не абавязковы і калі не пазначаны, тады лічыцца, што ўмова выконваецца. У такім разе спыненьне выкананьня цыкла трэба арганізоўваць нейкім іншым чынам.</li>
    <li><code class="language-js">increment</code>&nbsp;&ndash; выраз, які выконваецца ў канцы кожнага праходу (перад наступнай праверкай умоўнага выразу) і выкарыстоўваецца звычайна для зьмяненьня лічыльніка.</li>
    <li><code class="language-js">statement</code>&nbsp;&ndash; інструкцыя, якая ўтварае цела цыклуаі выконваецца ў кожным праходзе цыкла да таго часу, пакуль выконваецца ўмова цыкла. Можа быць <a href="#Statements_EmptyAndCompound">састаўной інструкцыяй</a>.</li>
  </ul>
  <p>Прыклад ужываньня:</p>

  <pre><code class="language-js">
for (var i = 0; i < 9; i++) {
  console.log(i);
}
</code></pre>

  <p>У выніку выкананьня папярэдняга фрагмэнту коду ў кансоль будуць выведзеныя пасьлядоўна лічбы ад 0 да 8 уключна.</p>

  <h3 id="Statements_Loops_for...in"><code class="language-js">for...in</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in">Reference</a></li>
    </ul>
  </div>
  <p>Гэтая інструкцыя прызначана для перабору тых атрыбутаў пэўнага аб'екта, якія дазваляюцца для пераліку (зьяўляюцца «пералічваемымі»). Перабіраюцца атрыбуты як уласна самога аб'екта, так і тыя, якія ён спадкуе ад сваіх бацькоўскіх аб'ектаў. Ня ўсе атрыбуты пералічваюцца (і, адпаведна, ня будуць перабірацца гэтай інструкцыяй). Напрыклад, мэтад <code class="language-js">indexOf()</code> аб'екта <a href="#TypesValues_Strings_Wrapper"><code class="language-js">String</code></a> і мэтад <code class="language-js">toString()</code> аб'екта <a href="#CoreObjects_Object"><code class="language-js">Object</code></a> не зьяўляюцца «пералічваемымі».</p>
  <p>Гэтаксама як пры дапамозе інструкцыі <a href="#Statements_Loops_for"><code class="language-js">for</code></a> можна перабраць усе элемэнты масіву:</p>

  <pre><code class="language-js">
for (var i = 0; i < a.length; i++) {
  console.log(a[i]);
}
</code></pre>

  <p>пры дапамозе інструкцыі <code class="language-js">for...in</code> можна перабраць усе атрыбуты аб'екта:</p>

  <pre><code class="language-js">
for(var p in o) {
  console.log(o[p]);
}
</code></pre>

  <p>Дадзены прыклад:</p>

  <pre><code class="language-js">
var obj = {a:1, b:2, c:3};

for (var prop in obj) {
  console.log("o." + prop + " = " + obj[prop]);
}
</code></pre>

  <p>выведзе ў кансоль наступнае:</p>

  <pre><code class="language-bash">
o.a = 1
o.b = 2
o.c = 3
</code></pre>

  <p>Акрамя гэтага можна скарыстацца мэтадам <code class="language-js">hasOwnProperty()</code> для таго, каб сярод усіх перабіраемых атрыбутаў выбраць тыя, якія належаць ўласна самому аб'екту:</p>

  <pre><code class="language-js">
var triangle = {a:1, b:2, c:3};

function ColoredTriangle() {
  this.color = "red";
}

ColoredTriangle.prototype = triangle;

var obj = new ColoredTriangle();

for (var prop in obj) {
  if(obj.hasOwnProperty(prop)) {
    console.log("o." + prop + " = " + obj[prop]);
  }
}
</code></pre>

  <p>Дадзены прыклад выведзе ў кансоль наступнае:</p>

  <pre><code class="language-js">
o.color = red
</code></pre>

  <h2 id="Statements_Jumps">Пераходаў</h2>
  <p>Інструкцыі пераходаў кажуць інтэрпрэтатару перарваць звычайную хаду выкананьня праграмы і зрабіць пераход у нейкае іншае месца праграмы.</p>

  <h3 id="Statements_Jumps_break"><code class="language-js">break</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/break">Reference</a></li>
    </ul>
  </div>
  <p>Гэтая інструкцыя цалкам перарывае выкананьне <a href="#Statements_Loops">цыкла</a> альбо інструкцыі <a href="#Statements_Conditional_switch"><code class="language-js">switch</code></a> і кажа інтэрпрэтатару адразу ж перайсьці да наступнай за імі інструкцыі. Наступны мэтад перарывае цыкл <a href="#Statements_Loops_while"><code class="language-js">while</code></a> (радок 6) у момант, калі <code class="language-js">i</code> роўнае тром і пераходзіць да наступнай інструкцыі (радок 10), дзе вяртае значэньне <code class="language-js">3 * x</code>:</p>

  <pre data-line="6,10"><code class="language-js">
function testBreak(x) {
  var i = 0;

  while (i < 6) {
    if (i == 3) {
      break;
    }
    i += 1;
  }
  return i * x;
}
</code></pre>

  <h3 id="Statements_Jumps_continue"><code class="language-js">continue</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/continue">Reference</a></li>
    </ul>
  </div>
  <p>Дадзеная інструкцыя перарывае цяперашнюю ітэрацыю цыкла і пераходзіць да наступнай яго ітэрацыі&nbsp;&ndash; да праверкі ўмовы цыкла. Для інструкцыі <a href="#Statements_Loops_for"><code class="language-js">for</code></a> дадаткова перад праверкай умовы цыкла будзе выкананы выраз <code class="language-js">increment</code>, які звычайна выкарыстоўваецца для зьмяненьня лічыльніка цыкла.</p>
  <p>У наступным прыкладзе інструкцыя <code class="language-js">continue</code> (радок 6) перарве выкананьне той ітэрацыі цыкла, калі зьменная <code class="language-js">i</code> будзе мець значэньне 3 (радок 5) і пяройдзе да чарговай праверкі ўмовы цыкла (радок 3). Такім чынам зьменная <code class="language-js">n</code> па чарзе прыме значэньні 1, 3, 7, 12 (а не значэньні 1, 3, 6, 10, 15, якія б яна прыняла пры адсутнасьці інструкцыі <code class="language-js">continue</code>):</p>

  <pre data-line="6"><code class="language-js">
i = 0;
n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
}
</code></pre>

  <p>У наступным прыкладзе інструкцыя <code class="language-js">continue</code> (радок 2) перарве выкананьне той ітэрацыі цыкла, калі чарговы элемэнт масіву <code class="language-js">data[i]</code> будзе мець значэньне <a href="#TypesValues_undefined"><code class="language-js">undefined</code></a>, і пяройдзе да наступнага элемэнту масіву (альбо скончыць выкананьне цыкла, калі гэта быў апошні элемэнт):</p>

  <pre data-line="2"><code class="language-js">
for(i = 0; i < data.length; i++) {
  if (!data[i]) continue; // Элемэнт масіву мае значэньне undefined, прапускаем яго
  total += data[i];
}
</code></pre>

  <h3 id="Statements_Jumps_return"><code class="language-js">return</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return">Reference</a></li>
    </ul>
  </div>
  <p>Дадзеная інструкцыя перарывае далейшае выкананьне функцыі і вызначае значэньне, якое будзе вернутае ў тое месца коду, якое выклікала гэтую функцыю.</p>

  <pre><code class="language-js">
function square(x) { return x*x; }  // Вызначаецца функцыя, якая вяртае значэньне.
square(2);                          // Гэты выклік верне значэньне 4.
</code></pre>

  <p>Інструкцыя <code class="language-js">return</code> можа таксама ўжывацца сама па сабе, без значэньня. У гэтым выпадку выклікаючаму коду будзе вернутае значэньне <a href="#TypesValues_undefined"><code class="language-js">undefined</code></a>:</p>

  <pre><code class="language-js">
function display_object(obj) {
  // Адразу выходзім з функцыі, калі ёй было перададзенае значэньне null ці undefined.
  if (!obj) return;
  // Інакш (калі значэньне оbj вызначанае) робім зь ім нешта...
}
</code></pre>

  <h3 id="Statements_Jumps_throw"><code class="language-js">throw</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw">Reference</a></li>
    </ul>
  </div>

  <h3 id="Statements_Jumps_try...catch"><code class="language-js">try...catch</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/try...catch">Reference</a></li>
    </ul>
  </div>

  <h2 id="Statements_Miscellaneous">Іншыя</h2>

  <h3 id="Statements_Miscellaneous_with"><code class="language-js">with</code></h3>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/with">Reference</a></li>
    </ul>
  </div>

</section>

<section>
  <h1 id="ObjectModel">Аб'ектная мадэль</h1>
  <p>«Details of the Object Model» на MDN: <a href="https://developer.mozilla.org/en/JavaScript/Guide/Details_of_the_Object_Model">https://developer.mozilla.org/en/JavaScript/Guide/Details_of_the_Object_Model</a></p>
  <p>«Working with objects» на MDN: <a href="https://developer.mozilla.org/en/JavaScript/Guide/Working_with_Objects">https://developer.mozilla.org/en/JavaScript/Guide/Working_with_Objects</a></p>
  <p>«Inheritance and the prototype chain» на MDN: <a href="https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain">https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain</a></p>
  <p>«Inheritance revisited» на MDN: <a href="https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_Revisited">https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_Revisited</a></p>
  <p>«Prototypes and Inheritance in JavaScript» на scriptjunkie{}: <a href="http://msdn.microsoft.com/en-us/magazine/ff852808.aspx">http://msdn.microsoft.com/en-us/magazine/ff852808.aspx</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/whats-new-in-javascript-1-8-5/">What’s new in JavaScript 1.8.5</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/closures-front-to-back/">Closures: Front to Back</a></p>
  <p><a href="https://www.webcodegeeks.com/javascript/javascript-properties-example/">Javascript Properties Example</a></p>

  <h2 id="ObjectModel_Example">Прыклад</h2>

  <h3>HttpRequest.js</h3>

  <pre><code class="language-js">
function HttpRequest(url) {
    this.request = new XMLHttpRequest();

    this.body = undefined;
    this.method = HttpRequest.METHOD_GET;
    this.url = url;

    this.responseParser = undefined;
}

HttpRequest.METHOD_GET = 'GET';
HttpRequest.METHOD_POST = 'POST';

HttpRequest.prototype.setMethod = function(method) {
    this.method = method;
    return this;
};

HttpRequest.prototype.setBody = function(body) {
    if (typeof body === 'object') {
        body = JSON.stringify(body);
    }

    this.body = body;
    return this;
};

HttpRequest.prototype.setResponseParser = function(responseParser) {
    if (typeof responseParser !== 'function') return;

    this.responseParser = responseParser;
    return this;
};

HttpRequest.prototype.send = function(callback) {
    this.request.addEventListener('load', function() {
        if (this.responseParser) {
            callback(this.responseParser(this.request.responseText));
        } else {
            callback(this.request.responseText);
        }
    }, false);

    this.request.open(this.method, this.url, true);
    this.request.send(this.body);
    return this;
};
</code></pre>

  <h3>app.js</h3>

  <pre><code class="language-js">
new HttpRequest('/users')
    .setResponseParser(JSON.parse)
    .send(function(users) {
        // Делаем что-нибудь с пользователями
    });

new HttpRequest('/posts')
    .setResponseParser(JSON.parse)
    .send(function(posts) {
        // Делаем что-нибудь с постами
    });

// Создаём нового пользователя
new HttpRequest('/user')
    .setMethod(HttpRequest.METHOD_POST)
    .setBody({
        name: 'Tim',
        email: 'info@example.com'
    })
    .setResponseParser(JSON.parse)
    .send(function(user) {
        // Делаем что-нибудь с новым пользователем
    });
</code></pre>

</section>

<section>
  <h1 id="CoreObjects">Базавыя аб'екты</h1>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects">Guide</a></li>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects">Reference</a></li>
    </ul>
  </div>
  <p>У <i>JavaScript</i> існуюць базавыя ці, інакш кажучы, глябальныя аб'екты (у тым сэнсе, што даступныя ў глябальнай прасторы імёнаў). Ніжэй прыведзена больш падрабязная інфармацыя па кожнаму зь іх.</p>

  <h2 id="CoreObjects_Array"><code class="language-js">Array</code></h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects#Array_Object">Guide</a></li>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array">Reference</a></li>
    </ul>
  </div>
  <p><a href="http://lorenstewart.me/2017/01/22/javascript-array-methods-mutating-vs-non-mutating/">JavaScript Array Methods: Mutating vs. Non-Mutating</a></p>

  <h2 id="CoreObjects_Date"><code class="language-js">Date</code></h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects#Date_Object">Guide</a></li>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Reference</a></li>
    </ul>
  </div>

  <h2 id="CoreObjects_Error"><code class="language-js">Error</code></h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error">Reference</a></li>
    </ul>
  </div>

  <h3 id="CoreObjects_RangeError"><code class="language-js">RangeError</code></h3>

  <h2 id="CoreObjects_Function"><code class="language-js">Function</code></h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects#Function_Object">Guide</a></li>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function">Reference</a></li>
    </ul>
  </div>
  <p>Любая функцыя ў <i>JavaScript</i> зьяўляецца экзэмплярам базавага аб'екта <code class="language-js">Function</code>. Па-першае, функцыю можна стварыць праз канструктар:</p>

  <pre><code class="language-js">
new Function ([arg1[, arg2[, ... argN]],] functionBody)
</code></pre>

  <p>Выклікаючы канструктар, спачатку перадаецца сьпіс імёнаў неабавязковых аргумэнтаў, а апошнім ідзе сымбальная чарада, якая ўтрымлівае выразы для выкананьня, напрыклад:</p>

  <pre><code class="language-js">
// Стварае функцыю, якая прымае два аргумэнты і вяртае іх суму,
// прызначае зьменнай adder спасылку на створаную функцыю
var adder = new Function("a", "b", "return a + b");

// Выклік створанай функцыі
adder(2, 6);  //=> 8
</code></pre>

  <p>Часам, для вырашэньня пэўных задачаў, немагчыма абмінуць стварэньне функцыяў праз канструктар, але звычайна, ў астатніх выпадках, трэба пазьбягаць гэтага, таму што такія функцыі ствараюцца пры кожным сваім выкліку наноў. Замест гэтага ў большасьці выпадкаў трэба аб'яўляць функцыю і выклікаць яе ў тэксьце праграмы:</p>

  <pre><code class="language-js">
// Аб'яўленьне функцыі
function sayHello() {
  console.log("Hello there!");
};

// Выклік аб'яўленай функцыі
sayHello(); // Вывядзе чараду "Hello there!" у кансоль
</code></pre>

  <p>Функцыя можа быць прызначана зьменнай:</p>

  <pre><code class="language-js">
var sayHi = function() {
  console.log("Hi there!");
};

// Выклік аб'яўленай функцыі
sayHi(); // Вывядзе чараду "Hi there!" у кансоль
</code></pre>

  <p>Гэта вельмі падобна да звычайнага аб'яўленьня функцыі, але трэба ведаць, што:</p>
  <ul>
    <li>калі функцыя ствараецца праз выраз кшталту <code class="language-js">var adder = new Function("...")</code>, <code class="language-js">adder</code> зьяўляецца зьменнай, якая у дадзены момант спасылаецца на аб'ект <code class="language-js">Function</code> (а ў іншы момант можа спасылацца на іншы аб'ект, у тым ліку іншага тыпу),</li>
    <li>калі ж функцыя ствараецца праз выраз <code class="language-js">function sayHello() {...}</code>, <code class="language-js">sayHello</code> зьяўляецца імем функцыі, а ня зьменнай.</li>
  </ul>
  <p>Функцыі таксама можна аб'яўляць унутры іншых функцыяў. Укладзеныя (унутраныя) функцыі абмежаваны для выкарыстаньня толькі сваімі абымаючымі (зьнешнімі) функцыямі. Пры гэтым унутраныя функцыі могуць мець доступ да аргумэнтаў і зьменных сваіх зьнешніх функцыяў, але зьнешнія функцыі ня могуць мець доступ да аргумэнтаў і зьменных сваіх унутраных функцыяў.</p>

  <h3 id="CoreObjects_Function_Props">Атрыбуты</h3>
  <p>У  аб'ектаў <code class="language-js">Function</code> маецца адзін атрыбут, які дазваляе пашыраць/зьмяняць усе экзэмпляры адпаведных аб'ектаў:</p>

  <h4 id="CoreObjects_Function_Props_prototype">prototype</h4>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/prototype">Reference</a></li>
    </ul>
  </div>

  <h3 id="CoreObjects_Function_Methods">Мэтады</h3>
  <p>Разгледзем мэтады, якія даступны экзэмплярам <code class="language-js">Function</code>.</p>

  <h4 id="CoreObjects_Function_Methods_apply"><code class="language-js">apply</code></h4>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply">Reference</a></li>
    </ul>
  </div>

  <h4 id="CoreObjects_Function_Methods_bind"><code class="language-js">bind</code></h4>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Reference</a></li>
    </ul>
  </div>

  <h4 id="CoreObjects_Function_Methods_call"><code class="language-js">call</code></h4>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call">Reference</a></li>
    </ul>
  </div>

  <h4 id="CoreObjects_Function_Methods_isGenerator"><code class="language-js">isGenerator</code></h4>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/isGenerator">Reference</a></li>
    </ul>
  </div>

  <h4 id="CoreObjects_Function_Methods_toString"><code class="language-js">toString</code></h4>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/toString">Reference</a></li>
    </ul>
  </div>

  <h2 id="CoreObjects_Object"><code class="language-js">Object</code></h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object">Reference</a></li>
    </ul>
  </div>

  <h2 id="CoreObjects_RegExp"><code class="language-js">RegExp</code></h2>
  <div class="refs">
    <ul>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects#RegExp_Object">Guide</a></li>
      <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/RegExp">Reference</a></li>
    </ul>
  </div>


</section>

<section>
  <h1 id="Async">Асынхроннасьць</h1>

  <p><a href="https://developer.mozilla.org/En/Using_web_workers">Mozilla Developers Network</a></p>
  <p><a href="http://www.html5rocks.com/en/tutorials/workers/basics/">The Basics of Web Workers</a></p>
  <p><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/workers.html#workers">whatwg.org</a></p>
  <p><a href="http://www.html5rocks.com/en/tutorials/service-worker/introduction/?mc_cid=31cc7c17cb&mc_eid=5b4e3f8de1">Introduction to Service Worker</a></p>
  <p><a href="https://una.im/save-offline/">Implementing "Save For Offline" with Service Workers</a></p>
  <p><a href="https://github.com/mozilla/serviceworker-cookbook">ServiceWorker Cookbook</a></p>
  <p><a href="https://vimeo.com/184236467">The Pragmatist’s Guide to Service Workers</a></p>
  <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a></p>
  <br>
  <p><a href="https://bitsofco.de/asynchronous-functions-101/">Asynchronous Functions 101</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/promise-based-validation/">Promise-Based Validation</a></p>
  <p><a href="http://robotlolita.me/2015/11/15/how-do-promises-work.html?mc_cid=b2ece7659c&mc_eid=5b4e3f8de1">How do Promises Work?</a></p>
  <p><a href="http://www.html5rocks.com/en/tutorials/es6/promises/?mc_cid=b2ece7659c&mc_eid=5b4e3f8de1">JavaScript Promises</a></p>
  <p><a href="http://thewebivore.com/async-await-and-why-its-great/">async/await and why it’s so great</a></p>


  <pre><code class="language-js">
function doRequest(url) {
    return new Promise(function(resolve, reject) {
        // Инициализируем запрос
        // В случае успеха вызываем resolve(response)
        // В случае ошибки вызываем reject(error)
    });
}

// Сначала запрашиваем пользователей
doRequest('https://example.com/api/users')
// Когда все они успешно выполнены, запускаем .then()
.then(function(users) { /* ... */ })
// Когда любой из Promise активизировал функцию reject(), вызываем .catch()
.catch(function(error) { /* ... */ });

// Параллельный запуск нескольких Promise
Promise.all([
    doRequest('https://example.com/api/users'),
    doRequest('https://example.com/api/posts')
])
.then(function(responses) { /* ... */ })
.catch(function(error) { /* ... */ });
</code></pre>

</section>

<section>
  <h1 id="LoggingDebugTesting">Лагіраваньне і тэставаньне</h1>

  <h2 id="LoggingDebug">Лагіраваньне і дэбаг</h2>
  <div class="refs">
    <ul>
      <li><a href="http://jslogger.com/">Logs in Cloud</a></li>
    </ul>
  </div>
  <p>Прасьцейшы спосаб рабіць лагіраваньне і дэбаг у <i>JavaScript</i>&nbsp;&ndash; вывад інфармацыі ў кансоль <a href="http://getfirebug.com/" title="Хатняя старонка Firebug"><i>Firebug</i></a>:</p>

  <pre><code class="language-js">
function log(obj) {
  if (window.console && console.log) {
    console.log(obj);
  }
}
</code></pre>

  <p>Што такое <i>Firebug</i> можна даведацца ў відэа-ўводзінах да гэтага <a href="http://firefox.com/" title="Хатняя старонка Firefox"><i>Firefox</i></a>-дадатку на <strong>css-tricks.com</strong>: <a href="http://css-tricks.com/video-screencasts/15-introduction-to-firebug/">http://css-tricks.com/video-screencasts/15-introduction-to-firebug/</a>.</p>

  <br>
  <p><a href="https://www.sitepoint.com/logging-errors-client-side-apps/">Logging Errors in Client-Side Applications</a></p>

  <h2 id="Testing">Тэставаньне</h2>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/how-to-test-your-javascript-code-with-qunit/">How to Test your JavaScript Code with QUnit</a>, <a href="https://code.tutsplus.com/tutorials/dont-forget-to-cover-your-client-side--cms-21021">Don't Forget to Cover Your Client Side!</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/testing-your-javascript-with-jasmine/">Testing Your JavaScript with Jasmine</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/test-driven-javascript-development-in-practice/">Test-Driven JavaScript Development in Practice</a></p>
  <p><a href="http://www.testling.com/">cross-browser testing platform</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/advanced-unit-testing-techniques-in-javascript/">Advanced Unit Testing Techniques in JavaScript</a></p>
  <p><a href="https://github.com/Heydon/forceFeed">forceFeed.js</a>, <a href="https://github.com/marmelab/gremlins.js/">gremlins.js</a>&nbsp;&ndash; monkey testing library (генэруе выпадковыя дзеяньні на старонцы).</p>
  <p><a href="https://wallabyjs.com/">Wallaby.js</a>&nbsp;&ndash; Integrated Continuous Testing Tool for JavaScript.</p>
  <p><a href="https://x-team.com/blog/setting-up-javascript-testing-tools-for-es6/">Setting Up JavaScript Testing Tools for ES6</a></p>
</section>

<section>
  <h1 id="TipsTricks">Tips &amp; Tricks</h1>
  <div class="refs">
    <ul>
      <li><a href="https://blog.jscrambler.com/12-extremely-useful-hacks-for-javascript/">jscrambler</a></li>
    </ul>
  </div>

  <h2 id="TipsTricks_ConvertingToBoolean">Пераўтварэньне ў <code class="language-js">boolean</code> праз <code class="language-js">!!</code></h2>
  <p>Выраз <code class="language-js">!!variable</code> аўтаматычна перавядзе значэньне любога тыпу ў значэньне тыпу <code class="language-js">boolean</code>. У выніку <code class="language-js">false</code> атрымаецца толькі тады, калі зыходнае значэньне мела адно са значэньняў: <code class="language-js">0</code>, <code class="language-js">null</code>, <code class="language-js">""</code>, <code class="language-js">undefined</code> альбо <code class="language-js">NaN</code>, інакш атрымаецца <code class="language-js">true</code>. Напрыклад:</p>
  <pre><code class="language-js">
function Account(cash) {
    this.cash = cash;
    this.hasMoney = !!cash;
}
var account = new Account(100.50);
console.log(account.cash); // 100.50
console.log(account.hasMoney); // true

var emptyAccount = new Account(0);
console.log(emptyAccount.cash); // 0
console.log(emptyAccount.hasMoney); // false
</code></pre>

  <h2 id="TipsTricks_ConvertingToNumber">Пераўтварэньне ў лік праз <code class="language-js">+</code></h2>
  <p>Простае пераўтварэньне сымбальнай чарады ў лік:</p>
  <pre><code class="language-js">
function toNumber(strNumber) {
    return +strNumber;
}
console.log(toNumber("1234")); // 1234
console.log(toNumber("ACB")); // NaN
</code></pre>

  <h2 id="TipsTricks_DefaultValues">Змоўчныя значэньні праз <code class="language-js">||</code></h2>
  <p>У <i>ES6</i> маецца магчымасьць пазначаць змоўчныя значэньні парамэтраў. У ранейшых вэрсіях <i>JavaScript</i> тое ж самае можна было рабіць наступным чынам:</p>
  <pre><code class="language-js">
function User(name, age) {
    this.name = name || "Oliver Queen";
    this.age = age || 27;
}
var user1 = new User();
console.log(user1.name); // Oliver Queen
console.log(user1.age); // 27

var user2 = new User("Barry Allen", 25);
console.log(user2.name); // Barry Allen
console.log(user2.age); // 25
</code></pre>

  <h2 id="TipsTricks_ShortCircuitsConditional">Замена ўмоўных інструкцыяў умоўнымі апэрацыямі</h2>
  <p>Наступны фрагмэнт:</p>
  <pre><code class="language-js">
if (user) {
  user.login();
}
</code></pre>
  <p>Можна замяніць больш кароткай формай:</p>
  <pre><code class="language-js">
user && user.login();
</code></pre>

  <h2 id="TipsTricks_DetectingObjectProperties">Вызначэньне прысутнасьці атрыбутаў у аб'ектах</h2>
  <p>Прысутнасьць атрыбутаў ці функцыяў у аб'ектах можна правяраць пры дапамозе апэрацыі <code class="language-js">in</code>:</p>
  <pre><code class="language-js">
if ('querySelector' in document) {
    document.querySelector("#id");
} else {
    document.getElementById("id");
}
</code></pre>

  <h2 id="TipsTricks_LastItemInArray">Атрыманьне апошняга элемэнту масіву</h2>
  <p>Пры дапамозе функцыі <code class="language-js">Array.prototype.slice(begin, end)</code> можна атрымліваць апошні элемэнт масіву пры:</p>
  <pre><code class="language-js">
var array = [1,2,3,4,5,6];
console.log(array.slice(-1)); // [6]
console.log(array.slice(-2)); // [5,6]
console.log(array.slice(-3)); // [4,5,6]
</code></pre>

  <h2 id="TipsTricks_ArrayTruncation">Уразаньне масіву</h2>
  <p>Калі з сыходнага масіву трэба атрымаць першыя <i>n</i> яго элемэнтаў не клапоцячыся пра захаваньне зыходнага масіву, можна скарыстацца наступнай тэхнікай:</p>
  <pre><code class="language-js">
var array = [1,2,3,4,5,6];
console.log(array.length); // 6
array.length = 3;
console.log(array.length); // 3
console.log(array); // [1,2,3]
</code></pre>

  <h2 id="TipsTricks_MergingArrays">Зьліцьцё масіваў</h2>
  <p>Натуральны спосаб зьліцьця масіваў:</p>
  <pre><code class="language-js">
var array1 = [1,2,3];
var array2 = [4,5,6];
console.log(array1.concat(array2)); // [1,2,3,4,5,6];
</code></pre>
  <p>Але недахоп такога мэтаду ў тым, што ён стварае новы масіў, спажываючы дадатковую памяць, што можа быць непажадана пры вялікіх масівах. Альтэрнатыўным і больш аптымальным з пункту гледжаньня спажываньня памяці зьяўляецца наступны спосаб:</p>
  <pre><code class="language-js">
var array1 = [1,2,3];
var array2 = [4,5,6];
console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];
</code></pre>

</section>

<section>
  <h1 id="Plugins">Дадаткі і бібліятэкі</h1>
  <p><a href="http://underscorejs.org/">Underscore.js</a></p>
  <br>
  <p><a href="http://www.javascriptkit.com/cutpastejava.shtml">Сьпіс плагінаў</a></p>
  <p><a href="http://coding.smashingmagazine.com/2012/09/23/useful-javascript-libraries-jquery-plugins-web-developers/">Useful JavaScript Libraries and jQuery Plugins</a></p>
  <p><a href="http://www.smashingmagazine.com/2011/04/07/useful-javascript-and-jquery-tools-libraries-plugins/">Useful JavaScript and jQuery Tools, Libraries, Plugins</a></p>
  <p><a href="http://multiple.js.org/">Multiple.js - An experiment in sharing background across multiple elements using CSS</a></p>
  <p><a href="https://www.sitepoint.com/3-javascript-libraries-2017/">3 JavaScript Libraries to Keep an Eye on in 2017</a></p>
  <p><a href="https://yomguithereal.github.io/mnemonist/">Mnemonist</a>&nbsp;&ndash; Curated collection of data structures for the JavaScript language.</p>

  <h2 id="Plugins_Favicons">Маніпуляцыі з Favicon</h2>
  <p><a href="https://github.com/tommoor/tinycon">Tinycon&nbsp;&ndash; library for manipulating the favicon, in particular adding alert bubbles and changing images</a></p>

  <h2 id="Plugins_PageHeaders">Загалоўкі старонак</h2>
  <p>Бібліятэкі, якія хаваюць загаловак пры пракрутцы старонкі ўніз: <a href="http://codepen.io/anon/pen/mIheL">HeadsUp</a>, <a href="http://wicky.nillia.ms/headroom.js/">Headroom.js</a></p>

  <h2 id="Plugins_Table">Табліцы</h2>
  <p>Бібліятэка, якая надае табліцам магчымасьць упарадкоўваць даныя: <a href="http://www.kryogenix.org/code/browser/sorttable/">sorttable</a></p>
  <p>Бібліятэкі, якія надаюць табліцам магчымасьць фільтраваць даныя:</p>
  <ul>
    <li><a href="http://www.javascriptkit.com/script/script2/tablefilter.shtml">HTML Table Filter</a></li>
    <li><a href="http://tablefilter.free.fr/">HTML Table Filter Generator</a></li>
  </ul>
  <p><a href="http://nexts.github.io/Clusterize.js/">Clusterize.js</a>&nbsp;&ndash; Tiny plugin to display large data sets easily.</p>
  <p>Для наданьня табліцам адначасова магчымасьцяў і ўпарадкоўваць радкі, і фільтраваць іх, і пастаронкавую навігацыю, і шмат чаго іншага зьвярніце ўвагу на jQuery-дадатак <a href="#Frameworks_jQuery_Plugins_Tables">DataTables</a>.</p>

  <h2 id="Plugins_DatesFormatting">Даты</h2>
  <p>Бібліятэка для фарматаваньня, маніпуляваньня і парсынгу датаў: <a href="http://momentjs.com/">moment.js</a></p>
  <p>Бібліятэка для фарматаваньня, маніпуляваньня і парсынгу датаў: <a href="http://git.aaronlumsden.com/tidytime.js/">tidyTime.js</a></p>
  <p>Бібліятэка для фарматаваньня, маніпуляваньня і парсынгу датаў: <a href="http://arshaw.com/xdate/">xDate</a>

  <h2 id="Plugins_WYSIWYG">WYSIWYG рэдактары</h2>
  <p><a href="http://quilljs.com/">quill.js</a></p>

  <h2 id="Plugins_TextFields">Тэкставыя палі</h2>
  <p>Вызначэньне месца зьмяшчэньня ці водступу карэткі ў тэкставым полі: <a href="https://github.com/ichord/Caret.js">Caret.js</a></p>
  <p>Аўтазапаўненьне: <a href="http://leaverou.github.io/awesomplete/">Awesomplete</a></p>
  <p>Фарматаваньне: <a href="http://nosir.github.io/cleave.js/">cleave.js</a></p>
  <p><a href="http://kushagragour.in/lab/superplaceholderjs/">superplaceholder.js</a></p>

  <h2 id="Plugins_DropdownFields">Выпадаючыя сьпісы</h2>
  <p><a href="http://harvesthq.github.com/chosen/">Chosen - makes long select boxes much more user-friendly.</a></p>
  <p><a href="http://robdel12.github.io/DropKick/">DropKick.js</a></p>

  <h2 id="Plugins_NumbersFormatting">Лікі, грошы, валюты</h2>
  <p>Лякалізуемая бібліятэка для фарматаваньня лікаў, грошай і валютаў: <a href="http://josscrowcroft.github.com/accounting.js/">accounting.js</a></p>
  <p>Бібліятэка для канвэртацыі валютаў: <a href="http://josscrowcroft.github.com/money.js/">money.js</a></p>
  <p>Бібліятэка для адвольнага фарматаваньня лікаў: <a href="http://numeraljs.com/">numeral.js</a></p>
  <br />
  <p><a href="https://stripe.com/">stripe - payments for developers</a></p>
  <p><a href="http://js.recurly.com/">recurly.js - Secure, PCI Compliant Transaction Forms With Fully Customizable CSS.</a></p>
  <p><a href="http://kenkeiter.com/skeuocard/">Skeuocard - progressively enhances credit card inputs to provide a skeuomorphic interface</a></p>

  <h2 id="Plugins_Tooltips">Падказкі</h2>
  <p><a href="http://ytiurin.github.io/html5tooltipsjs/">html5tooltips.js</a>&nbsp;&ndash; Light and clean tooltips with CSS3 animation, No framework required</p>
  <p><a href="https://popper.js.org/">popper.js</a></p>

  <h2 id="Plugins_Autocomplete">Аўтаматычная падстаноўка</h2>
  <p>Аўтаматычная падстаноўка фрагмэнту тэксту па гарачай клавішы: <a href="https://github.com/ichord/At.js">At.js</a></p>

  <h2 id="Plugins_Maps">Мапы</h2>
  <p><a href="https://www.mapbox.com/">MapBox</a></p>
  <p><a href="http://leaflet.cloudmade.com/">A Modern, Lightweight Open-Source JavaScript Library for Interactive Maps by CloudMade</a></p>

  <h2 id="Plugins_SplitPanes">Split panes</h2>
  <p><a href="http://nathancahill.github.io/Split.js/">Split.js</a> is a lightweight, unopinionated utility for creating adjustable split views or panes.</p>

  <h2 id="Plugins_Dialogs">Дыялёгі</h2>
  <p><a href="https://github.com/hakimel/avgrund">Avgrund</a>&nbsp;&ndash; A modal concept which aims to give a sense of depth between the page and modal layers.</p>

  <h2 id="Plugins_PreLoading">Загрузка артэфактаў ці паводзінаў</h2>
  <p><a href="http://requirejs.org/">RequireJS</a>&nbsp;&ndash; is a JavaScript file and module loader.</p>
  <p><a href="http://createjs.com/#!/PreloadJS">PreloadJS</a>&nbsp;&ndash; A Javascript library that lets you manage and co-ordinate the loading of assets.</p>
  <p><a href="http://conditionerjs.com/">conditioner.js</a>&nbsp;&ndash; A javascript library for loading and unloading behavior based on environment conditions.</p>
  <p><a href="https://github.com/nodeca/pako">pako.js</a>&nbsp;&ndash; zlib port to javascript (<a href="https://blog.daftcode.pl/how-to-make-uploading-10x-faster-f5b3f9cfcd52#.d92o74x27">How to Make Uploading 10x Faster</a>).</p>

  <h2 id="Plugins_Asynchronous">Асынхронная апрацоўка</h2>
  <p><a href="https://blog.engineyard.com/2015/taming-asynchronous-javascript-with-async">Taming Asynchronous JavaScript with <b>Async.js</b></a></p>

  <h2 id="Plugins_Push">Push</h2>
  <p><a href="http://nickersoft.github.io/push.js">JavaScript notifications for every browser</a></p>

  <h2 id="Plugins_Animation">Анімацыя</h2>
  <p>Declarative handling library for CSS animations: <a href="http://anijs.github.io/">AniJS</a></p>
  <p><a href="http://bouncejs.com/">bounce.js</a> lets you create tasty CSS3 powered animations in no time.</p>
  <p><a href="http://thednp.github.io/kute.js/index.html">kute.js</a> is a Javascript animation engine with top performance, memory efficient & modular code.</p>

  <h2 id="Plugins_Colors">Колеры</h2>
  <p><a href="https://github.com/gka/chroma.js">chroma.js</a>&nbsp;&ndash; JavaScript library for all kinds of color manipulations.</p>

  <h2 id="Plugins_MoveDragDropResize">Move, Drag&amp;Drop, Resize</h2>
  <p><a href="http://interactjs.io/">interact.js</a>&nbsp;&ndash; JavaScript drag and drop, resizing and multi-touch gestures with inertia and snapping.</p>

  <h2 id="Plugins_Video">Відэа</h2>
  <p><a href="http://mozillapopcorn.org/">POPCORN - Popcorn makes video work like the web.</a></p>

  <h2 id="Plugins_Charts">Графікі</h2>
  <p><a href="http://gionkunz.github.io/chartist-js/">Chartist.js</a>&nbsp;&ndash; simple responsive charts.</p>
  <p><a href="https://developers.google.com/chart/interactive/docs/quick_start">Google Charts</a></p>

  <h2 id="Plugins_Presentations">Прэзэнтацыі</h2>
  <p><a href="http://markdalgleish.com/projects/fathom/">Fathom.js - прэзэнтацыі на JavaScript</a></p>
  <p><a href="https://github.com/impress/impress.js">Impress.js - presentation framework based on the power of CSS3 transforms and transitions</a></p>

  <h2 id="Plugins_CMS">CMS</h2>
  <p><a href="https://component.io/">component.io</a>&nbsp;&ndash; content management you can add anywhere.</p>

  <h2 id="Plugins_PDF">PDF</h2>
  <p>Стварэньне ўбудаваных на старонцы <i>PDF</i>-дакумэнтаў лётма на кліенцкім баку: <a href="http://parall.ax/products/jspdf">jsPDF</a></p>

  <h2 id="Plugins_Mobile">Мабільныя прылады</h2>
  <p><a href="http://quojs.tapquo.com/">Quo.js</a>&nbsp;&ndash; Micro JavaScript Library for mobile web projects.</p>
</section>

<section>
  <h1 id="Frameworks" data-content-item-open>Фрэймворкі</h1>
  <p><a href="http://www.benlesh.com/2014/04/embular-part-1-comparing-ember-and.html?spref=tw">Embular Part 1 - Comparing Ember and Angular</a></p>
  <p><a href="http://blog.codeschool.com/post/85819292538/angular-backbone-or-ember-which-is-best-for-your">Angular, Backbone, or Ember: Which is Best for your Build?</a></p>
  <p><a href="http://ilikekillnerds.com/2015/01/aurelia-vs-angularjs-round-one-fight/">Aurelia vs AngularJS – Round One: FIGHT!</a></p>
  <p><a href="http://sennajs.com/">senna.js – A blazing-fast single page application engine</a></p>
  <p><a href="https://medium.com/@mattburgess/javascript-frameworks-are-great-2df4a3f0b24d#.800pywjp2">JavaScript Frameworks Are Great</a> vs.
    <a href="https://medium.com/@mattburgess/all-javascript-frameworks-are-terrible-e68d8865183e#.dvaa8ssdm">All JavaScript frameworks are terrible</a></p>

  <h2 id="Frameworks_Node">Node.js</h2>
  <div class="refs">
    <ul>
      <li><a href="http://nodejs.org/">Home</a></li>
      <li><a href="https://nodejs.org/en/docs/">Docs</a></li>
    </ul>
  </div>
  <p>Фрэймворк для сэрвэраў. Прызначаны для выкананьня не на кліенцкім баку (у браўзэры), а на сэрверным баку. Зьяўляецца вельмі хуткім падзейна-арыентаваным фрэймворкам, які працуе на <a href="http://code.google.com/p/v8/">рухавіку V8 ад Гугла</a>.</p>

  <h3 id="Frameworks_Node_Links">Карысныя спасылкі</h3>
  <p><a href="http://code.tutsplus.com/tutorials/this-time-youll-learn-node-js--net-19448">Node.js Step by Step</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/learning-serverside-javascript-with-node-js/">Learning Server-Side JavaScript with Node.js</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/how-to-scrape-web-pages-with-node-js-and-jquery/">How to Scrape Web Pages with Node.js and jQuery</a></p>
  <p><a href="http://code.tutsplus.com/tutorials/testing-in-nodejs--net-35018">Testing in Node.js</a></p>
  <p><a href="http://code.tutsplus.com/tutorials/introduction-to-html5-desktop-apps-with-node-webkit--net-36296">Introduction to HTML5 Desktop Apps With Node-Webkit</a></p>
  <p><a href="https://blog.heroku.com/archives/2014/3/11/node-habits?utm_source=mkto&utm_medium=email&utm_campaign=marchnewsletter&mkt_tok=3RkMMJWWfF9wsRonuK%2FMZKXonjHpfsX54%2BwvXKSzlMI%2F0ER3fOvrPUfGjI4AScdnI%2BSLDwEYGJlv6SgFQrjAMapmyLgLUhE%3D">10 Habits of a Happy Node Hacker</a></p>
  <p><a href="https://www.airpair.com/node.js/posts/nodejs-framework-comparison-express-koa-hapi">Node.js Framework Comparison: Express vs. Koa vs. Hapi</a></p>
  <p><a href="http://www.webcodegeeks.com/javascript/node-js/node-js-full-application-example/">Node.js: Full application example</a></p>
  <p><a href="https://www.webcodegeeks.com/javascript/node-js/building-web-apps-with-node-js/">Node.js Tutorial: Building web apps</a></p>
  <p><a href="http://keystonejs.com/">Node.js CMS &amp; Web Application Platform</a></p>

  <h3 id="Frameworks_Node_npm">npm</h3>
  <div class="refs">
    <ul>
      <li><a href="https://www.npmjs.com/">Home</a></li>
      <li><a href="https://docs.npmjs.com/">Docs</a></li>
    </ul>
  </div>
  <p><a href="https://nodesource.com/blog/eleven-npm-tricks-that-will-knock-your-wombat-socks-off/">11 Simple npm Tricks That Will Knock Your Wombat Socks Off</a></p>
  <p><a href="https://www.toptal.com/javascript/a-guide-to-npm-the-node-package-manager">A Guide to npm: The Node.js Package Manager</a></p>
  <p>Усталяваць сам <i>Node.js</i> і <i>npm</i> (<i>Node Package Manager</i>) у сыстэму лепш за ўсё праз <i>nvm</i> (<i>Node Versions Manager</i>) наступным чынам. Спачатку ўсталюем сам <i>nvm</i>:</p>

  <pre><code class="language-bash">
$ sudo curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash
</code></pre>

  <p>Затым ужывем зьмены, якія усталёўшчык унёс у файл <code class="language-js">.profile</code> у хатняй тэчцы:</p>

  <pre><code class="language-bash">
$ source ~&frasl;.profile
</code></pre>

  <p>І напрыканцы ўсталюем апошнія стабільныя вэрсіі <i>Node.js</i> і <i>npm</i>:</p>

  <pre><code class="language-bash">
$ nvm install stable
Downloading https://nodejs.org/dist/v4.2.1/node-v4.2.1-linux-x64.tar.xz...
######################################################################## 100,0%
Now using node v4.2.1 (npm v2.14.7)
</code></pre>

  <p>Усталяваць пакет лякальна можна наступным чынам:</p>

  <pre><code class="language-bash">
$ npm install &lt;PACKAGE_NAME&gt;
</code></pre>

  <p>Стварыць праект у цяперашняй тэчцы (файл <code class="language-js">package.json</code>):</p>

  <pre><code class="language-bash">
$ npm init
</code></pre>

  <p>У гэтым файле можна прапісаць залежнасьці рукамі і тады пры выкананьні каманды <code class="language-js">npm install</code> <i>npm</i> сьцягне і усталюе ўсе пакеты, якія прапісаны як залежнасьці цяперашняга праекта. Каб не запаўняць гэты файл рукамі, можна адначасова ўсталяваць пакет і прапісаць яго залежнасьць у файле <code class="language-js">package.json</code> (з пастаяннай прысутасьцю, то бок як у распрацоўшчыцкім, так і ў вытворчым асяродках):</p>

  <pre><code class="language-bash">
$ npm install &lt;PACKAGE_NAME&gt; --save
</code></pre>

  <p>Усталяваць праект як залежнасьць выключна распрацоўшчыцкага асяродку можна такім чынам:</p>

  <pre><code class="language-bash">
$ npm install &lt;PACKAGE_NAME&gt; --save-dev
</code></pre>

  <h3 id="Frameworks_Node_Grunt">Grunt</h3>
  <div class="refs">
    <ul>
      <li><a href="http://gruntjs.com/">Home</a></li>
      <li><a href="http://gruntjs.com/getting-started">Docs</a></li>
      <li><a href="http://gruntjs.com/plugins">Plugins</a></li>
    </ul>
  </div>
  <p>Пакет аўтаматычнага выкананьня задачаў (зборкі).</p>
  <p><a href="http://www.sitepoint.com/setting-up-es6-project-using-babel-browserify/">Setting up an ES6 Project Using Babel and Browserify</a></p>
  <p><a href="http://www.sitepoint.com/how-to-grunt-and-gulp-your-way-to-workflow-automation/">How to Grunt and Gulp Your Way to Workflow Automation</a></p>

  <h3 id="Frameworks_Node_Gulp">Gulp</h3>
  <div class="refs">
    <ul>
      <li><a href="http://gulpjs.com/">Home</a></li>
      <li><a href="https://github.com/gulpjs/gulp/tree/master/docs">Docs</a></li>
      <li><a href="http://gulpjs.com/plugins/">Plugins</a></li>
      <li><a href="http://www.sitepoint.com/introduction-gulp-js/">Intro</a></li>
    </ul>
  </div>
  <p>Пакет аўтаматычнага выкананьня задачаў (зборкі).</p>
  <p><a href="http://egorsmirnov.me/2015/05/25/browserify-babelify-and-es6.html">Browserify, Babelify and ES6</a></p>
  <p><a href="http://www.sitepoint.com/simple-gulpy-workflow-sass/">A Simple Gulp’y Workflow For Sass</a></p>
  <p><a href="http://fettblog.eu/gulp-browserify-multiple-bundles/">Gulp: Creating multiple bundles with Browserify</a></p>
  <p><a href="http://stefanimhoff.de/2014/gulp-tutorial-4-css-generation-sass/">Introduction to Gulp.js</a></p>
  <p>Сьцісканьне выяваў:</p>

  <pre><code class="language-js">
var gulp = require('gulp');
var changed = require('gulp-changed');
var imagemin = require('gulp-imagemin');

gulp.task('image-minify', function() {
  var imgSrc = './src/images/**/*',
      imgDst = './dist/images';

  gulp.src(imgSrc)            // бяром выявы с зыходнага шляху
    .pipe(changed(imgDst))    // выбяраем толькі тыя, якія не зьмяніліся з апошняга білду
    .pipe(imagemin())         // сьціскаем іх
    .pipe(gulp.dest(imgDst)); // і зьмяшчаем ў выніковы шлях
});
</code></pre>

  <p>Сьцісканьне <i>HTML</i>:</p>

  <pre><code class="language-js">
var gulp = require('gulp');
var minifyHTML = require('gulp-minify-html');

gulp.task('html-minify', function() {
  var htmlSrc = './src/*.html',
      htmlDst = './dist';

  gulp.src(htmlSrc)           // бяром HTML-файлы с зыходнага шляху
    .pipe(changed(htmlDst))   // выбяраем толькі тыя, якія не зьмяніліся з апошняга білду
    .pipe(minifyHTML())       // сьціскаем іх
    .pipe(gulp.dest(htmlDst));// і зьмяшчаем ў выніковы шлях
});
</code></pre>

  <p>Сьцісканьне <i>CSS</i>:</p>

  <pre><code class="language-js">
var gulp = require('gulp');
var concat = require('gulp-concat');
var autoprefix = require('gulp-autoprefixer');
var minifyCSS = require('gulp-minify-css');

gulp.task('css-minify', function() {
  var stylesSrc = './src/styles/**/*',
      stylesDst = './dist/styles';

  gulp.src(stylesSrc)           // бяром усе СЫЫ-файлы с зыходнага шляху
    .pipe(concat('styles.css')) // аб'ядноўваем іх у адзін файл
    .pipe(autoprefix('last 2 versions')) // устаўляем vendor-specific прэфіксы
    .pipe(minifyCSS())          // сьціскаем выніковы файл
    .pipe(gulp.dest(stylesDst));// і зьмяшчаем у выніковы шлях
});
</code></pre>

  <p>Сьцісканьне <i>JavaScript</i>:</p>

  <pre><code class="language-js">
var gulp = require('gulp');
var stripDebug = require('gulp-strip-debug');
var uglify = require('gulp-uglify');

gulp.task('js-minify', function() {
  gulp.src('./bundle.js')       // бяром файл скрыпту пасьля browserify
    .pipe(stripDebug())         // выразаем усё лагіраваньне
    .pipe(uglify())             // сьціскаем
    .pipe(gulp.dest('./bundle.js')); // і перапісваем паверх зыходнага
});
</code></pre>

  <h3 id="Frameworks_Node_Webpack">Webpack</h3>
  <div class="refs">
    <ul>
      <li><a href="http://webpack.github.io/">Home</a></li>
    </ul>
  </div>
  <p>Webpack is a module bundler.</p>
  <p><a href="https://www.ag-grid.com/ag-grid-understanding-webpack/">Webpack Tutorial: Understanding How it Works</a>.</p>

  <h3 id="Frameworks_Node_Browserify">Browserify</h3>
  <div class="refs">
    <ul>
      <li><a href="http://browserify.org/">Home</a></li>
    </ul>
  </div>
  <p>Browserify lets you require('modules') in the browser by bundling up all of your dependencies.</p>
  <p><a href="https://www.npmjs.com/package/watchify">Watchify</a>&nbsp;&ndash; сочыць за зьменамі ў файлах, каб запускаць білды Browserify.</p>
  <p><a href="https://www.npmjs.com/package/reactify">Reactify</a>&nbsp;&ndash; Browserify transform for JSX.</p>

  <h3 id="Frameworks_Node_Express">Express.js</h3>
  <div class="refs">
    <ul>
      <li><a href="http://expressjs.com/">Home</a></li>
    </ul>
  </div>
  <p>Fast, unopinionated, minimalist web framework for Node.js</p>
  <p><a href="http://www.webcodegeeks.com/javascript/node-js/node-js-express-tutorial/">Node.js: Express tutorial</a></p>

  <h2 id="Frameworks_Reactive">RxJS</h2>
  <div class="refs">
    <ul>
      <li><a href="https://github.com/Reactive-Extensions/RxJS">Home</a></li>
    </ul>
  </div>
  <p>Сродак рэактыўнага праграмаваньня на <i>JavaScript</i></p>
  <p><a href="https://auth0.com/blog/understanding-reactive-programming-and-rxjs/">Understanding Reactive Programming and RxJS</a></p>
  <p><a href="https://css-tricks.com/animated-intro-rxjs/">An Animated Intro to RxJS</a></p>

  <h2 id="Frameworks_TypeScript" >TypeScript</h2>
  <div class="refs">
    <ul>
      <li><a href="http://www.typescriptlang.org/">Home</a></li>
    </ul>
  </div>
  <p>TypeScript lets you write JavaScript the way you really want to. TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p>
  <p><a href="http://blog.wolksoftware.com/working-with-react-and-typescript">Working with React and TypeScript</a></p>
  <p><a href="http://www.javacodegeeks.com/2015/10/8-steps-to-migrating-from-javascript-to-typescript.html">8 Steps to Migrating from JavaScript to TypeScript</a></p>


  <h2 id="Frameworks_Meteor" >Meteor</h2>
  <div class="refs">
    <ul>
      <li><a href="https://www.meteor.com/">Home</a></li>
      <li><a href="http://docs.meteor.com/#/full/">Docs</a></li>
    </ul>
  </div>

  <h2 id="Frameworks_MEAN">MEAN</h2>
  <div class="refs">
    <ul>
      <li><a href="http://www.mean.io/">Home</a></li>
    </ul>
  </div>
  <p><a href="http://code.tutsplus.com/tutorials/introduction-to-the-mean-stack--cms-19918">Introduction to the MEAN Stack</a></p>

  <h2 id="Frameworks_React">React</h2>
  <div class="refs">
    <ul>
      <li><a href="http://facebook.github.io/react/index.html">Home</a></li>
      <li><a href="http://facebook.github.io/react/docs/getting-started.html">Docs</a></li>
      <li><a href="http://facebook.github.io/react/docs/getting-started.html">Docs</a></li>
      <li><a href="https://www.youtube.com/channel/UCP_lo1MFyx5IXDeD9s_6nUw">YouTube Channel</a></li>
      <li><a href="http://buildwithreact.com/tutorial">Tutorial 2</a></li>
      <li><a href="https://www.codementor.io/reactjs/tutorial/the-reactjs-quick-start-guide">Tutorial 3</a></li>
      <li><a href="https://scotch.io/tutorials/learning-react-getting-started-and-concepts">Tutorial 4</a></li>
      <li><a href="http://survivejs.com/webpack_react/introduction/">Tutorial 5</a></li>
      <li><a href="http://learnreact.com/lessons">Tutorial 6</a></li>
    </ul>
  </div>

  <p><a href="https://www.infernojs.org/"><strong>An extremely fast React-like JavaScript library for building modern user interfaces.</strong></a></p>
  <p><a href="https://medium.mybridge.co/react-js-top-10-articles-of-the-year-v-2017-e95092964e49#.koxll57a7">React.JS Top 10 Articles of The Year (v.2017).</a></p>
  <p><a href="https://medium.com/@learnreact/container-components-c0e67432e005#.6y5jwy5iw">Container Components</a>&nbsp;&ndash; <strong>важная канцэпцыя.</strong></p>
  <p><a href="http://academy.plot.ly/#react">Tutorial на <b>academy.plot.ly</b>.</a></p>
  <p><a href="http://egorsmirnov.me/2015/05/22/react-and-es6-part1.html">"React and ES6" series.</a></p>
  <p><a href="http://buildwithreact.com/">Articles in "Build with react"</a></p>
  <p><a href="https://css-tricks.com/learning-react-router/">Leveling Up With React</a></p>
  <p><a href="https://www.codementor.io/reactjs/tutorial">Different tutorials</a></p>
  <p>React Router: <a href="https://github.com/ReactTraining/react-router">routing library for React</a>, <a href="https://css-tricks.com/learning-react-router/">Leveling Up With React: React Router</a>, <a href="http://codepen.io/pen?template=jyYjeW">real example</a></p>
  <p><a href="https://codesandbox.io/"><strong>CodeSandbox</strong> makes it easier to create, share and reuse React projects with others.</a></p>
  <p><a href="https://github.com/djirdehh/react-living-app">Прыклад праграмы</a>, і <a href="https://github.com/elrumordelaluz/reactour">яшчэ адзін</a></p>
  <p><a href="https://github.com/team-gryff/react-monocle">react-monocle</a>&nbsp;&ndash; developer tool for generating visual representations of your React app's component hierarchy.</p>
  <p><a href="https://github.com/storybooks/storybook">Storybook</a>&nbsp;&ndash; is a development environment for React UI components.</p>
  <p><a href="https://react-move.js.org">ReactMove</a>&nbsp;&ndash; Beautifully and deterministically animate anything in react.</p>
  <p><a href="https://github.com/gajus/react-css-modules">React CSS Modules</a></p>
  <p><a href="https://www.triplet.fi/blog/practical-guide-to-react-and-css-modules/">Practical Guide to React and CSS Modules</a></p>
  <p><a href="https://github.com/styled-components/styled-components">styled-components</a></p>
  <p><a href="https://medium.freecodecamp.com/a-5-minute-intro-to-styled-components-41f40eb7cd55#.pdp6omfaw">A 5-minute Intro to Styled Components</a></p>
  <p><a href="https://auth0.com/docs/quickstart/spa/react/java-spring-security">React + Spring Security Java API</a></p>
  <p><a href="http://myshareoftech.com/2013/12/unit-testing-react-dot-js-with-jasmine-and-karma.html">Unit Testing React.js With Jasmine and Karma</a></p>
  <p><a href="https://github.com/mxstbr/react-boilerplate?mc_cid=350132d979&mc_eid=5b4e3f8de1">react-boilerplate</a></p>
  <p><a href="https://medium.com/@steedhelix/react-webpack-and-horizon-quick-start-b9335c1ece53#.fdbx2n8bz">React, Webpack, and Horizon Quick Start</a></p>
  <p><a href="https://hackernoon.com/simple-react-development-in-2017-113bd563691f">Simple React Development in 2017</a></p>
  <p><a href="http://stack.formidable.com/radium/">Radium&nbsp;&ndash; set of tools to manage inline styles on React elements</a></p>
  <p><a href="https://medium.com/@sgroff04/how-i-learned-react-and-how-you-can-too-6714a48e984a#.ae1cmbwew">How I learned React and how you can too</a></p>
  <p><a href="https://community.algolia.com/instantsearch.js/react/">Lightning-fast search for React apps</a></p>
  <p><a href="https://hackernoon.com/testing-react-components-with-jest-and-enzyme-41d592c174f#.3v7brzetb">Testing React components with Jest and Enzyme</a></p>
  <p><a href="https://auth0.com/blog/testing-react-applications-with-jest">Testing React Applications with Jest</a></p>
  <p><a href="https://www.sitepoint.com/tutorial-build-a-react-js-application-with-user-login-and-authentication/">Build a React.js Application with User Login and Authentication</a></p>
  <p><a href="https://www.smashingmagazine.com/2017/01/internationalizing-react-apps/">Internationalizing React Apps</a></p>
  <p><a href="https://medium.com/code-life/our-best-practices-for-writing-react-components-dec3eb5c3fc8#.aiibhv2m8">Our Best Practices for Writing React Components</a></p>
  <p><a href="https://medium.freecodecamp.com/how-to-build-animated-microinteractions-in-react-aab1cb9fe7c8#.jr9pd1xpr">How to build animated microinteractions in React</a></p>
  <p><a href="https://hackernoon.com/10-react-mini-patterns-c1da92f068c5#.te0fbmkka">10 React mini-patterns</a></p>
  <p><a href="https://medium.com/@skylernelson_64801/state-architecture-patterns-in-react-a-review-df02c1e193c6">State Architecture Patterns in React: A Review</a></p>
  <p>YouTube:</p>
  <p><a href="https://www.youtube.com/watch?v=plUN2L4Ak14">Going from Backbone and Angular to FLUX</a></p>
  <p><a href="https://www.youtube.com/watch?v=qrsle5quS7A">ReactJS / Redux Tutorial - #1 Introduction</a></p>
  <p><a href="https://www.youtube.com/watch?v=AslncyG8whg">Netflix JavaScript Talks - RxJS + Redux + React = Amazing!</a></p>
  <p><a href="https://www.youtube.com/watch?v=Pd6Ub7Ju2RM">Learn React, Flux, and Flow: Part I</a></p>
  <p><a href="https://www.youtube.com/watch?v=LCaH1siSzW4">Learning Flux and React.js - Part 1</a></p>
  <p><a href="https://www.youtube.com/watch?v=IR6smI_YJDE">React Tutorial (with Webpack + ES6): Build a ToDo App with Best Practices</a></p>
  <p>Cerebral?:</p>
  <p><a href="http://www.cerebraljs.com/">cerebraljs.com</a></p>
  <p><a href="https://www.youtube.com/watch?v=QG181MnRIXM">Cerebral - React and Immutable Store</a></p>

  <h3 id="Frameworks_React_ComponentOrganisation">Арганізацыя коду кампанэнтаў</h3>

  <pre><code class="language-js">
React.createClass({

    // Спачатку зьмяшчаем валідацыю атрыбутаў, якую лепш заўсёды зьмяшчаць,
    // таму што гэта добрая дакумэнтацыя коду
    propTypes: {},

    // потым зьмяшчаем магчымыя дамешкі
    mixins : [],

    // Мэтады жыцьцёвага цыклу, якія выконваюцца да стварэньня экзэмпляру
    getInitialState: function() {},
    getDefaultProps: function() {},

    // Мэтады жыцьцёвага цыклу, якія адносяцца да mounting/updating/unmounting
    componentWillMount : function() {},
    componentWillReceiveProps: function() {},
    componentWillUnmount : function() {},

    // Уласныя мэтады з "_"-прэфіксам
    _parseData : function() {},
    _onSelect : function() {},

    // Стандартны мэтад "маляваньня" кампанэнту
    render : function() {
      var optionalElement;            // Пры наяўнасьці неабавязковых элемэнтаў
                                      // пры "маляваньні", лепш аб'явіць зьменную,
      if (this.props.condition) {     // якую запоўніць JSX-кодам толькі пры неабходнасьці
        optionalElement = (&lt;div&gt; … &lt;&frasl;div&gt;);
      }

      return (
        &lt;div&gt;               // Нават калі вяртаецца невялікі фрагмэнт JSX-коду,
          &lt;ComponentOne &frasl;&gt;  // лепш рабіць пераносы радка і водступы
          &lt;ComponentTwo &frasl;&gt;  // для лепшай чытальнасьці коду

          &lt;Component
            attribute={...}         // Калі пры "маляваньні" кампанэнту перадаецца
            anotherAttribute={...}  // сьпіс атрыбутаў, лепш зьмяшчаць іх на асобным
            attributeThree={...}    // радку
            …
          &frasl;&gt;
          …
          {optionalElement} // Калі неабавязковы элемэнт не быў запоўнены,
          …                 // у гэтым месцы проста нічога не будзе ўстаўлена

          // Устаўку сьпісу ўкладзеных кампанэнтаў лепш рабіць in-line,
          // прынамсі калі выраз дастаткова просты
          {this.props.list.map(function(data, i) {
            return (&lt;Component data={data} key={i} frasl;&gt;)
          })}
        &lt;&frasl;div&gt;
      );
    }

})
</code></pre>

  <h3 id="Frameworks_React_ComponentProperties">Атрыбуты кампанэнтаў</h3>
  <div class="refs">
    <ul>
      <li><a href="https://facebook.github.io/react/docs/reusable-components.html">Docs</a></li>
      <li><a href="https://medium.com/react-tutorials/react-properties-ef11cd55caa0">medium.com</a></li>
    </ul>
  </div>
  <p>Атрыбуты кампанэнту перадаюцца пры яго канструяваньні, а зьвяртацца да атрыбутаў унутры кампанэнту можна пры дапамозе <code class="language-javascript">this.props</code>:</p>
  <pre data-line="3,8"><code class="language-jsx">
var InterfaceComponent = React.createClass({
  render : function() {
    return &lt;div&gt;hello {this.props.name}!&lt;/div&gt;;
  }
});

React.renderComponent(
  &lt;InterfaceComponent name="chris" /&gt;,
  document.body
);
</code></pre>

  <h4 id="Frameworks_React_ComponentProperties_Validation">Валідацыя</h4>
  <p><i>React</i> прадстаўляе мэханізм валідацыі значэньняў атрыбутаў&nbsp;&ndash; <code class="language-js">propTypes</code>:</p>

  <pre><code class="language-js">
React.createClass({
  propTypes: {
    // Па-першае, можна пазначыць, што атрыбут належыць да прымітыўных тыпаў.
    // Па-змоўчваньні, яны ўсе неабавязковыя.
    optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,

    // Усё, што можа быць адлюстравана: лікі, чароды, іншыя кампанэнты
    // альбо масівы гэтых тыпаў.
    optionalNode: React.PropTypes.node,

    // React-кампанэнт (альбо элемэнт у тэрміналёгіі React).
    optionalElement: React.PropTypes.element,

    // Можна таксама пазначыць, што атрыбут павінен зьяўляцца экзэмплярам пэўнай клясы.
    optionalMessage: React.PropTypes.instanceOf(Message),

    // Можна пазначыць непасрэдна значэньні, якія мае прымаць атрыбут.
    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),

    // Значэньне можа быць аб'ектам розных тыпаў.
    optionalUnion: React.PropTypes.oneOfType([
      React.PropTypes.string,
      React.PropTypes.number,
      React.PropTypes.instanceOf(Message)
    ]),

    // Масіў пэўнага тыпу
    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),

    // An object with property values of a certain type
    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),

    // An object taking on a particular shape
    optionalObjectWithShape: React.PropTypes.shape({
      color: React.PropTypes.string,
      fontSize: React.PropTypes.number
    }),

    // Усё вышэйпералічанае можна дапоўніць 'isRequired' каб зрабіць атрыбут абавязковым.
    requiredFunc: React.PropTypes.func.isRequired,

    // Значэньне любога тыпу.
    requiredAny: React.PropTypes.any.isRequired,

    // Можна таксама пазначыць callback-мэтад для ўласнай праверкі значэньня.
    // Ён павінен вяртаць Error, калі праверка была няўдалай.
    // Не ўжывайце 'console.warn' альбо throw.
    customProp: function(props, propName, componentName) {
      if (!/matchme/.test(props[propName])) {
        return new Error('Validation failed!');
      }
    }

    customBefore: function(props, propName, componentName) {
      if (!(propName in props)) {
        throw new Error("before must be set.");
      }

      var now = new Date();

      if (now.getTime() >= props[propName].getTime()) {
        throw new Error("before must be set to a later date.");
      }
    }
  },
  /* ... */
});
</code></pre>

  <p>Калі валідацыя не прайшла ў рэжыме распрацоўкі (ужываецца не мініміфікаваная і аптымізаваная бібліатэка <i>React</i>), у кансоль будзе выведзена адпаведнае папярэджаньне. У вытворчым рэжыме валідацыя ўвогуле не будзе адбывацца для лепшай хуткадзейнасьці.</p>
  <p>Дадатковай магчымасьцю, якую прадстаўляе <code class="language-js">propTypes</code>, зьяўляецца праверка таго, што ў кампанэнт быў перададзены дакладна адзін укладзены кампанэнт:</p>

  <pre data-line="3"><code class="language-js">
var MyComponent = React.createClass({
  propTypes: {
    children: React.PropTypes.element.isRequired
  },

  render: function() {
    return (
      &lt;div&gt;
        {this.props.children} // This must be exactly one element or it will throw.
      &lt;&frasl;div&gt;
    );
  }

});
</code></pre>

  <h4 id="Frameworks_React_ComponentProperties_DefaultValues">Змоўчныя значэньні</h4>
  <p>Можна пазначыць змоўчныя значэньні для атрыбутаў, калі яны не абавязковыя і не былі перададзеныя ў кампанэнт:</p>

  <pre data-line="4,5,18"><code class="language-js">
var InterfaceComponent = React.createClass({
  getDefaultProps : function() {
    return {
      "firstName" : "Алесь",
      "lastName"  : "Зарэцкі"
    };
  },
  render : function() {
    return (
      &lt;div&gt;
        hello {this.props.firstName + " " + this.props.lastName}
      &lt;&frasl;div&gt;
    );
  }
});

React.renderComponent(
  &lt;InterfaceComponent &frasl;&gt;, // атрыбуты не былі перададзеныя, таму будуць ужытыя змоўчныя
  document.body
);
</code></pre>

  <h4 id="Frameworks_React_ComponentProperties_Transfer">Перадача па герархіі</h4>
  <p>Бацькоўскія кампанэнты могуць перадаваць даччыным усе свае атрыбуты разам. Існуе 2 варыянты гэта рабіць.</p>
  <ul>
    <li>Варыянт 1

      <pre data-line="16"><code class="language-js">
var ChildComponent = React.createClass({
  render : function() {
    return (
      &lt;div style=&lbrace;{
        color      : this.props.color,
        background : this.props.background
      }&rbrace;&gt;
        I am {this.props.color}
      &lt;&frasl;div&gt
    );
  }
});

var ParentComponent = React.createClass({
  render : function() {
    return this.transferPropsTo( // Усе атрыбуты будуць перададзеныя даччынаму
      &lt;ChildComponent background={null} &frasl;&gt; // акрамя "background"
    );
  }
});

React.renderComponent(
  &lt;ParentComponent color="blue" background="red" &frasl;&gt;,
  document.body
);
</code></pre>

    </li>
    <li>Варыянт 2

      <pre data-line="4"><code class="language-js">
var CheckLink = React.createClass({
  render: function() {
    // Атрыбуты CheckLink будуць перададзеныя ў &lt;a&gt;
    return &lt;a {...this.props}&gt;{'√ '}{this.props.children}&lt;&frasl;a&gt;;
  }
});

React.render(
  &lt;CheckLink href="/checked.html"&gt;
    Click here!
  &lt;&frasl;CheckLink&gt;,
  document.getElementById('example')
);
</code></pre>

    </li>
  </ul>

  <h3 id="Frameworks_React_ComponentState">Стан кампанэнтаў</h3>
  <div class="refs">
    <ul>
      <li><a href="https://facebook.github.io/react/docs/thinking-in-react.html">Docs</a></li>
      <li><a href="https://medium.com/react-tutorials/react-state-14a6d4f736f5">medium.com</a></li>
    </ul>
  </div>
  <p>Асноўнае правіла адносна стану кампанэнтаў&nbsp;&ndash; ён павінен быць мінімальна неабходным. Ня трэба захоўваць тое, што можна дынамічна разьлічыць/атрымаць. Калі кампанэнт статычны і не залежыць ад зьнешніх фактараў, у яго не павінна быць стану&nbsp;&ndash; усё павінна разьлічвацца ў момант адлюстраваньня. Мэтад <code class="language-js">getInitialState</code> вызначае зыходны стан, мэтад <code class="language-js">setState</code> усталёўвае новае значэньне зьменным, а мэтад <code class="language-js">replaceState</code> зацірае папярэдні стан (цалкам выдаляе значэньні <strong>ўсіх</strong> зьменных стану) і ўсталёўвае новыя значэньні.</p>

  <pre><code class="language-js">
var InterfaceComponent = React.createClass({
  getInitialState : function() {
    return {
      name : "chris"
    };
  },
  handleClick : function() {
    this.setState({
      name : "bob"
    });
  },
  render : function() {
    return (
      &lt;div onClick={this.handleClick}&gt;
        hello {this.state.name}
      &lt;&frasl;div&gt;
    );
  }
});

React.renderComponent(
  &lt;InterfaceComponent &frasl;&gt;,
  document.body
);
</code></pre>

  <a class="jsbin-embed" href="http://jsbin.com/zenusi/embed?js,output&height=500px">JS Bin on jsbin.com</a>

  <h3 id="Frameworks_React_PubSub">Publisher-Subscriber pattern</h3>
  <p><a href="https://msdn.microsoft.com/en-us/magazine/hh201955.aspx">Understanding the Publish/Subscribe Pattern for Greater JavaScript Scalability</a></p>
  <p><a href="http://amplifyjs.com/api/pubsub/">AmplifyJS</a></p>
  <p><a href="https://github.com/mroderick/PubSubJS">PubSubJS</a></p>
  <p><a href="https://github.com/developit/mitt">Mitt: tiny 200b functional event emitter / pubsub.</a></p>

  <h3 id="Frameworks_React_Addons">Add-ons і кампанэнты</h3>
  <p><a href="http://elemental-ui.com/">UI Toolkit for React.js Websites and Apps</a></p>
  <p><a href="https://facebook.github.io/react/docs/addons.html">Add-ons at React Docs</a></p>
  <p><a href="http://react-components.com/">react-components.com</a></p>
  <p><a href="http://www.reactjsx.com/">Search reusable React components</a></p>
  <p><a href="http://react.rocks/">react.rocks</a></p>
  <p><a href="https://github.com/chenglou/react-motion">react-motion</a></p>

  <h4 id="Frameworks_React_Addons_MaterialUI">Material UI</h4>
  <div class="refs">
    <ul>
      <li><a href="http://callemall.github.io/material-ui/#/">Home</a></li>
    </ul>
  </div>

  <h4 id="Frameworks_React_Addons_Blueprint">Blueprint UI</h4>
  <div class="refs">
    <ul>
      <li><a href="http://blueprintjs.com/">Home</a></li>
    </ul>
  </div>

  <h3 id="Frameworks_React_Flux">Flux</h3>
  <div class="refs">
    <ul>
      <li><a href="https://facebook.github.io/flux/">Home</a></li>
      <li><a href="https://facebook.github.io/flux/docs/overview.html#content">Docs</a></li>
      <li><a href="https://github.com/coryhouse/react-flux-starter-kit">Starter Kit</a></li>
    </ul>
  </div>

  <h3 id="Frameworks_React_Flow">Flow</h3>
  <div class="refs">
    <ul>
      <li><a href="https://flowtype.org/">Home</a></li>
      <li><a href="https://flowtype.org/docs/getting-started.html">Docs</a></li>
    </ul>
  </div>
  <p><a href="https://www.theodo.fr/blog/2016/11/go-with-the-flow-a-static-type-checking-tool-for-javascript/">Go With the Flow – A Static Type Checking Tool for JavaScript</a></p>


  <h3 id="Frameworks_React_Redux">Redux</h3>
  <div class="refs">
    <ul>
      <li><a href="http://redux.js.org/">Home</a></li>
      <li><a href="https://github.com/coryhouse/react-slingshot">Starter Kit</a></li>
    </ul>
  </div>
  <p>Redux is a predictable state container for JavaScript apps.</p>
  <p><a href="https://code.tutsplus.com/tutorials/how-to-use-the-react-redux-package--cms-27150">How to Use the react-redux Package</a>.</p>
  <p><a href="https://medium.freecodecamp.com/scaling-your-redux-app-with-ducks-6115955638be#.ab0lfg121">Scaling your Redux App with ducks</a>.</p>

  <h3 id="Frameworks_React_Draftjs">Draft.js</h3>
  <div class="refs">
    <ul>
      <li><a href="http://facebook.github.io/draft-js/">Home</a></li>
    </ul>
  </div>
  <p>Draft.js is a framework for building rich text editors in React</p>
  <p>Іншыя рэалізацыі <i>rich text editors</i>:</p>
  <ul>
    <li><a href="http://alloyeditor.com/demo/">http://alloyeditor.com/demo/</a></li>
    <li><a href="http://zenoamaro.github.io/react-quill/">http://zenoamaro.github.io/react-quill/</a></li>
    <li><a href="http://tgecho.github.io/react-prosemirror/">http://tgecho.github.io/react-prosemirror/</a></li>
  </ul>

  <h2 id="Frameworks_Vue">Vue</h2>
  <div class="refs">
    <ul>
      <li><a href="https://vuejs.org/">Home</a></li>
      <li><a href="https://vuejs-tips.github.io/cheatsheet/">CheatSheet</a></li>
    </ul>
  </div>
  <p><a href="https://medium.com/js-dojo/4-things-vue-js-got-right-10820cc84004#.d4hjv138r">4 Things Vue.js Got Right</a></p>
  <p><a href="https://medium.com/@bradfmd/vue-vuex-getting-started-f78c03d9f65#.7eumjws1w">Vue + Vuex — Getting started (application state management)</a></p>
  <p><a href="https://css-tricks.com/intro-to-vue-1-rendering-directives-events/">Intro to Vue.js: Rendering, Directives, and Events</a></p>
  <p><a href="https://josephuspaye.github.io/Keen-UI/#/ui-alert">Keen UI&nbsp;&ndash; A lightweight collection of essential UI components written with Vue.js and inspired by Material Design.</a></p>

  <h2 id="Frameworks_Aurelia">Aurelia</h2>
  <div class="refs">
    <ul>
      <li><a href="http://aurelia.io/">Home</a></li>
    </ul>
  </div>
  <p><a href="http://aurelia.io/">Aurelia - next generation JavaScript client framework that leverages simple conventions to empower your creativity.</a></p>

  <h2 id="Frameworks_Angular">Angular</h2>
  <div class="refs">
    <ul>
      <li><a href="http://angularjs.org/">Home</a></li>
    </ul>
  </div>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/building-a-web-app-from-scratch-in-angularjs/">Building a Web App From Scratch in AngularJS</a></p>
  <p><a href="https://www.guru99.com/angularjs-introduction.html">AngularJS Tutorial</a></p>
  <p><a href="http://codetunes.com/2014/5-tips-on-how-to-use-angularjs-with-rails-that-changed-how-we-work/">5 tips on how to use AngularJS with Rails that changed how we work</a></p>
  <p><a href="http://bandrzejczak.com/blog/2015/11/22/single-sign-on-with-keycloak-in-a-sigle-page-application-part-1-slash-2-angular-dot-js/">SSO for Your Single Page Application (Part 1/2 - AngularJS)</a></p>

  <h2 id="Frameworks_Ember">Ember</h2>
  <div class="refs">
    <ul>
      <li><a href="http://emberjs.com/">Home</a></li>
      <li><a href="http://emberjs.com/guides/">Guides</a></li>
      <li><a href="https://emberjs.com/api/">API</a></li>
    </ul>
  </div>
  <p><a href="http://landongn.com/ember/things-i-wish-someone-had-told-me-when-i-was-learning-ember-js/">Things I wish someone had told me when I was learning Ember.js</a></p>
  <p><a href="http://www.ember-cli-mirage.com/docs/v0.3.x/">Ember CLI MIRAGE</a>&nbsp;&ndash; Build, test and demo your app using a client-side server</p>
  <p><a href="https://ember-fastboot.com/">Ember FastBoot</a>&nbsp;&ndash; progressive enhancement for ambitious web apps</p>
  <p>Платныя курсы: <a href="https://code.tutsplus.com/courses/build-an-ambitious-app-with-ember-2">Tuts+</a>, <a href="https://app.pluralsight.com/library/courses/ember-2-getting-started/table-of-contents">Pluralsight</a></p>

  <h3 id="Frameworks_Ember_Install">Усталёўка</h3>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/getting-started/">Guide</a></li>
    </ul>
  </div>
  <p>Перш за ўсё трэба <a href="#Frameworks_Node_npm">ўсталяваць <i>Node.js</i> з <i>npm</i></a>. Таксама абавязковай залежнасьцю зьяўляецца <a href="../git/index.html"><i>Git</i></a> і <a href="https://bower.io/"><i>Bower</i></a> (<a href="https://www.emberjs.com/blog/2017/01/23/ember-2-11-released.html#toc_ember-no-longer-supplied-via-code-bower-code">да вэрсіі 2.11, пачынаючы зь вэрсіі 2.12 больш не зьяўляецца залежнасьцю</a>), апошні ўсталёўваецца праз <i>npm</i>:</p>

  <pre><code class="language-bash">
$ npm install -g bower
</code></pre>

  <p>Неабавязковымі залежнасьцямі зьяўляюцца <a href="https://facebook.github.io/watchman/docs/install.html"><i>Watchman</i></a>, які аптымізуе сачэньне за файламі, і <a href="http://phantomjs.org/"><i>PhantomJS</i></a> для тэставаньня адкрыцьця старонак без браўзэра (іншымі словамі безаконны вэб-кліент).</p>

  <p>Напрыканцы ўсталёўваем сам <i>ember</i>:</p>

  <pre><code class="language-bash">
$ npm install -g ember-cli
</code></pre>

  <p>І правяраем усталёўку:</p>

  <pre><code class="language-bash">
$ ember -v
ember-cli: 2.12.1
node: 6.10.2
os: linux x64
</code></pre>

  <h3 id="Frameworks_Ember_CLI">Ember CLI</h3>
  <div class="refs">
    <ul>
      <li><a href="https://ember-cli.com/">Home</a></li>
    </ul>
  </div>
  <p><i>Ember CLI</i>&nbsp;&ndash; гэта ўтыліта каманднага радку, якая забясьпечвае <a href="https://github.com/broccolijs/broccoli#broccoli"><i>Broccoli-powered asset pipeline</i></a>, строгую герархію праектаў згодна з канвэнцыяй, моцную сыстэму пашырэньня пры дапамозе дадаткаў.</p>

  <h3 id="Frameworks_Ember_CoreConcepts">Ключавыя канцэпцыі</h3>
  <img src="https://guides.emberjs.com/v2.12.0/images/ember-core-concepts/ember-core-concepts.png" alt="Ключавыя канцэпцыі Ember" style="width: 98%;">

  <h3 id="Frameworks_Ember_Routing">Разводка шляхоў</h3>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/routing/">Guide</a></li>
    </ul>
  </div>
  <p>Разводка шляхоў (<i>routing</i>) вызначае, якія існуюць шляхі (<i>URLs</i>) у праграме. Разводка зьмяшчаецца ў файле <code class="language-bash">app/router.js</code>:</p>

  <div class="pre-title"><code>app/router.js</code></div>
  <pre><code class="language-js">
Router.map(function() {
  this.route('orders', { path: '/orders' }); // першы аргумэнт - імя разводкі, другі - шлях
});
</code></pre>

  <p>Калі імя разводкі і шлях супадаюць, як у прыкладзе вышэй, шлях можна апускаць:</p>

  <div class="pre-title"><code>app/router.js</code></div>
  <pre><code class="language-js">
Router.map(function() {
  this.route('orders'); // кароткая форма
});
</code></pre>

  <p>Іншымі словамі можна сказаць, што шляхі праграмы&nbsp;&ndash; гэта магчымыя станы праграмы. Калі карыстальнік уручную задае шлях у браўзэры, ён пераводзіць праграму ў пэўны стан, і наадварот, калі праграма пераходзіць у пэўны стан, яна адлюстроўвае адпаведны шлях у браўзэры. Трэба адзначыць, што калі карыстальнік уручную ўвядзе шлях, адбудзецца паўнавартаснае абнаўленьне старонкі. Калі ж праграма сама пераходзіць у пэўны стан, то абнаўленьне старонкі не адбываецца, праграма абнаўляе стан (і візуальнае адлюстраваньне) у межах цяперашняй старонкі.</p>
  <p><i>Ember</i> аўтаматычна стварае разводку для каранёвага шляху нават калі яна ня створана яўна (<i>index</i>-разводка да
    <a href="#Frameworks_Ember_Templates">макету</a> <code class="language-bash">app/templates/index.hbs</code>).</p>
  <p>Калі ў праграме спрацоўвае пэўная разводка, <i>Ember</i> шукае аднайменныя <a href="#Frameworks_Ember_RouteHandlers">апрацоўшчык разводкі</a> і <a href="#Frameworks_Ember_Templates">макет</a>. Калі яны ня былі яшчэ створаныя, <i>Ember</i> аўтаматычна падставіць змоўчныя.</p>

  <h4 id="Frameworks_Ember_Routing_NestedRoutes">Укладзеныя шляхі</h4>
  <p>Часам патрэбна каб адзін макет быў адлюстраваны ўнутры іншага і пры гэтым каб меў свой асобны шлях. Для гэтага існуюць укладзеныя шляхі. Напрыклад, шлях <code class="language-bash">/orders</code> будзе агульным (бацькоўскім) для іншых: <code class="language-bash">/orders/index</code>, <code class="language-bash">/orders/new</code>, <code class="language-bash">/orders/edit</code>, і яго макет будзе ўтрымліваць агульны для ўсіх гэтых даччыных шляхоў код.</p>
  <p>Вызначаюцца ўкладзеныя шляхі наступным чынам: </p>

  <div class="pre-title"><code>app/router.js</code></div>
  <pre><code class="language-js">
Router.map(function() {
  this.route('orders', function() {
    this.route('order', {
      this.route('index');
      this.route('new');
      this.route('edit');
    });
  });
});
</code></pre>

  <p>Калі карыстальнік трапляе на шлях <code class="language-bash">/orders/new</code>, макет <code class="language-bash">/orders/new.hbs</code> будзе адлюстраваны на месцы <code class="language-js">&lbrace;&lbrace;outlet&rbrace;&rbrace;</code> бацькоўскага макету <code class="language-bash">orders.hbs</code>.</p>

  <h4 id="Frameworks_Ember_Routing_DynamicSegments">Дынамічныя сэгмэнты</h4>
  <p>Калі частка шляху дынамічная (напрыклад ID замовы), яна пазначаецца зьменнай, перад імем якой ставіцца двукроп'е: </p>

  <div class="pre-title"><code>app/router.js</code></div>
  <pre><code class="language-js">
Router.map(function() {
  this.route('orders', function() {
    this.route('order', { path: '/:order_id' }); // менавіта 'order_id', не 'id',
  });                                            // інакш можа ўзьнікнуць канфлікт імёнаў
});
</code></pre>

  <p>Калі карыстальнік увядзе ў браўзэрным радку шлях <code class="language-js">/orders/5</code>, зьменная <code class="language-js">order_id</code> прыме значэньне <code class="language-js">5</code> і яно будзе даступнае ў апрацоўшчыку:</p>

  <div class="pre-title"><code>app/routes/orders/order.js</code></div>
  <pre><code class="language-js">
export default Ember.Route.extend({
  model(params) {
    return [
      { id: '1', name: 'Nate' },
      { id: '2', name: 'Gregg' }
    ].findBy('id', params.order_id);
  }
});
</code></pre>

  <h4 id="Frameworks_Ember_Routing_GlobingAndWildcard">Wildcard-разводка</h4>
  <p>Можна вызначаць разводку, якая будзе спрацоўваць не на адзін шлях, а адразу на шмат шляхоў. Адно з магчымых варыянтаў выкарыстаньня&nbsp;&ndash; вызначэньне разводкі для няісных шляхоў: </p>

  <div class="pre-title"><code>app/router.js</code></div>
  <pre><code class="language-js">
Router.map(function() {
  this.route('not-found', { path: '/*path' });
});
</code></pre>

  <p>Тады, калі карыстальнік увядзе шлях <code class="language-bash">/a/non-existent/path</code>, яму будзе адлюстраваны макет:</p>

  <div class="pre-title"><code>app/templates/not-found.hbs</code></div>
  <pre><code class="language-js">
&lt;p&gt;Oops, the page you&#146;re looking for wasn&#146;t found&lt;/p&gt;
</code></pre>

  <h3 id="Frameworks_Ember_RouteHandlers">Апрацоўшчыкі разводкі</h3>

  <h4 id="Frameworks_Ember_RouteHandlers_RenderingTemplate">Прамалёўка макету</h4>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/routing/rendering-a-template/">Guide</a></li>
    </ul>
  </div>
  <p>Адна з задачаў апрацоўшчыка разводкі&nbsp;&ndash; выбар адпаведнага макету і яго прамалёўка. Па змоўчваньні будзе абраны макет, імя якога супадае з імем разводкі:</p>

  <div class="pre-title"><code>app/router.js</code></div>
  <pre><code class="language-js">
Router.map(function() {
  this.route('posts', function() {
    this.route('new');
  });
});
</code></pre>

  <p>У прыкладзе вышэй разводка <code class="language-bash">posts</code> прамалюе макет <code class="language-bash">posts.hbs</code>, а разводка <code class="language-bash">posts.new</code>&nbsp;&ndash; макет <code class="language-bash">posts/new.hbs</code></p>
  <p>Вынік прамалёўкі кожнага з макетаў будзе ўстаўлены ў месцазнаходжаньне <code class="language-js">&lbrace;&lbrace;outlet&rbrace;&rbrace;</code> макета яго бацькоўскай у герархіі разводкі. Калі вярнуцца да папярэдняга прыкладу, то разводка <code class="language-bash">posts.new</code> уставіць вынік прамалёўкі свайго макету ў <code class="language-js">&lbrace;&lbrace;outlet&rbrace;&rbrace;</code>, які знаходзіцца ў макеце <code class="language-bash">posts.hbs</code>, а разводка <code class="language-bash">posts</code> уставіць вынік прамалёўкі свайго макету ў <code class="language-js">&lbrace;&lbrace;outlet&rbrace;&rbrace;</code>, які знаходзіцца ў макеце <code class="language-bash">application.hbs</code>.</p>
  <p>Пры неабходнасьці прамаляваць макет, адрозны ад змоўчнага, можна перавызначыць атрыбут <a href="http://emberjs.com/api/classes/Ember.Route.html#property_templateName"><code class="language-js">templateName</code></a> апрацоўшчыка:</p>

  <div class="pre-title"><code>app/routes/posts.js</code></div>
  <pre><code class="language-js">
import Ember from 'ember';

export default Ember.Route.extend({
  templateName: 'posts/favorite-posts'
});
</code></pre>

  <p>Акрамя гэтага можна яшчэ перавызначыць і хук <a href="http://emberjs.com/api/classes/Ember.Route.html#method_renderTemplate"><code class="language-js">renderTemplate()</code></a> для большага кантролю над працэсам прамалёўкі макета.</p>

  <h4 id="Frameworks_Ember_RouteHandlers_DefiningModel">Вызначэньне мадэлі даных</h4>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/routing/specifying-a-routes-model/">Guide</a></li>
    </ul>
  </div>
  <p>Часьцей за ўсё ў макеце трэба адлюстраваць пэўныя даныя, іншай задачай апрацоўшчыка разводкі як раз зьяўляецца вызначэньне мадэлі даных. Каб прадставіць мадэль даных макету, трэба перавызначыць хук <a href="http://emberjs.com/api/classes/Ember.Route.html#method_model"><code class="language-js">model()</code></a> апрацоўшчыка:</p>

  <div class="pre-title"><code>app/routes/favorite-posts.js</code></div>
  <pre><code class="language-js">
import Ember from 'ember';

export default Ember.Route.extend({
  model() {
    return this.get('store').query('post', { favorite: true });
  }
});
</code></pre>

  <p>Тыпова гэты хук будзе вяртаць існасьць <a href="https://guides.emberjs.com/v2.12.0/models/"><i>Ember Data</i></a>, але гэта можа быць і <a href="https://www.promisejs.org/"><i>promise</i></a>, і масіў, і ўвогуле любы аб'ект. Значэньне, вернутае хукам <code class="language-js">model()</code>, будзе даступна ў макеце ў якасьці атрыбуту <code class="language-js">model</code>.</p>

  <div class="pre-title"><code>app/templates/favorite-posts.hbs</code></div>
  <pre><code class="language-js">
&lt;h1&gt;Favorite Posts&lt;/h1&gt;
&lbrace;&lbrace;#each model as |post|&rbrace;&rbrace;
  &lt;p&gt;&lbrace;&lbrace;post.body&rbrace;&rbrace;&lt;/p&gt;
&lbrace;&lbrace;/each&rbrace;&rbrace;
</code></pre>

  <p>Прыклад вызначэньня мадэлі праз <a href="https://www.promisejs.org/"><i>promise</i></a>:</p>

  <div class="pre-title"><code>app/routes/favorite-posts.js</code></div>
  <pre><code class="language-js">
import Ember from 'ember';

export default Ember.Route.extend({
  model(params) {
    return new RSVP.Promise(resolve => {
      this.get('ajax')
        .fetchModel(Post, `${SERVICES.posts}/${params.user_id}/favorite`)
        .then(posts => resolve(posts));
    });
  });
</code></pre>

  <p>Калі трэба абнавіць даныя (напрыклад, пасьля абнаўленьня даных на сэрвэры), можна скарыстацца мэтадам <a href="https://emberjs.com/api/ember/2.15/classes/Ember.Route/methods/refresh?anchor=refresh"><code class="language-js">refresh()</code></a>:</p>

  <div class="pre-title"><code>app/routes/favorite-posts.js</code></div>
  <pre><code class="language-js">
import Ember from 'ember';

export default Ember.Route.extend({
  actions() {
    someAction() {
      return new Promise((resolve, reject) {
        ...
      }).then(() => this.refresh());
    }
  }
});
</code></pre>

  <p><strong>ЗАЎВАГА:</strong> у выпадку апрацоўкі шляху з <a href="#Frameworks_Ember_Routing_DynamicSegments">дынамічным сэгмэнтам</a>, хук <code class="language-js">model()</code> будзе абавязкова выкліканы ў выпадку непасрэднага уводу <i>URL'</i>а, але калі праграма патрапіць на яго праз праграмныя сродкі (напрыклад праз <code class="language-js">&lbrace;&lbrace;link-to&rbrace;&rbrace;</code>), тады хук будзе выкліканы толькі пры ўмове, што будзе вызначаны ідэнтыфікатар аб'екту:</p>

  <div class="pre-title"><code>app/templates/photos.hbs</code></div>
  <pre data-line="4"><code class="language-js">
&lt;h1&gt;Photos&lt;/h1&gt;
&lbrace;&lbrace;#each model as |photo|&rbrace;&rbrace;
  &lt;p&gt;
    &lbrace;&lbrace;#link-to 'photo' photo.id&rbrace;&rbrace;
      &lt;img src="&lbrace;&lbrace;photo.thumbnailUrl&rbrace;&rbrace;" alt="&lbrace;&lbrace;photo.title&rbrace;&rbrace;" /&gt;
    &lbrace;&lbrace;/link-to&rbrace;&rbrace;
  &lt;/p&gt;
&lbrace;&lbrace;/each&rbrace;&rbrace;
</code></pre>

  <p>Калі ж у <code class="language-js">&lbrace;&lbrace;link-to&rbrace;&rbrace;</code> будзе перададзена мадэль, тады хук <code class="language-js">model()</code> ня будзе выкліканы, а ў макет трапіць перададзеная мадэль:</p>

  <div class="pre-title"><code>app/templates/photos.hbs</code></div>
  <pre data-line="4"><code class="language-js">
&lt;h1&gt;Photos&lt;/h1&gt;
&lbrace;&lbrace;#each model as |photo|&rbrace;&rbrace;
  &lt;p&gt;
    &lbrace;&lbrace;#link-to 'photo' photo&rbrace;&rbrace;
      &lt;img src="&lbrace;&lbrace;photo.thumbnailUrl&rbrace;&rbrace;" alt="&lbrace;&lbrace;photo.title&rbrace;&rbrace;" /&gt;
    &lbrace;&lbrace;/link-to&rbrace;&rbrace;
  &lt;/p&gt;
&lbrace;&lbrace;/each&rbrace;&rbrace;
</code></pre>

  <h4 id="Frameworks_Ember_RouteHandlers_Redirecting">Перанакіраваньне</h4>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/routing/redirection/">Guide</a></li>
    </ul>
  </div>
  <p>Часам у апрацоўшчыку разводкі трэба зрабіць аўтаматычнае перанакіраваньне на іншую разводку, напрыклад на лагін-старонку, калі была спроба адкрыць прыватную старонку не ўвайшоўшым карыстальнікам. Для гэтага існуюць 2 мэтады: <code class="language-js">transitionTo()</code> (з захаваньнем гісторыі пераходаў у браўзэры) і <code class="language-js">replaceWith()</code> (без захаваньня гісторыі пераходаў).</p>
  <p>Калі пераход магчымы нават без загрузкі мадэлі, рабіць гэта варта ў хуку <code class="language-js">beforeModel()</code>:</p>

  <div class="pre-title"><code>app/routes/index.js</code></div>
  <pre><code class="language-js">
import Ember from 'ember';

export default Ember.Route.extend({
  beforeModel(transition) {
    this.transitionTo('posts'); // Перарывае цяперашні пераход і робіць новы - да разводкі 'posts'
  }
});
</code></pre>

  <p>У якасьці аргумэнту <code class="language-js">beforeModel()</code> атрымлівае цяперашні пераход, які можна будзе захаваць і выкарыстаць пазьней, напрыклад для вяртаньня да першапачатковага шляху пасьля ўваходу карыстальніка ў сыстэму.</p>
  <p>Але бываюць выпадкі, калі рашэньне пра пераход магчыма зрабіць толькі пасьля загрузкі даных, тады зрабіць гэта можна ў хуку <code class="language-js">afterModel()</code>:</p>

  <div class="pre-title"><code>app/routes/index.js</code></div>
  <pre><code class="language-js">
import Ember from 'ember';

export default Ember.Route.extend({
  afterModel(model, transition) {
    if (model.get('length') === 1) {
      this.transitionTo('post', model.get('firstObject'));// Пры адкрыцьці разводкі 'posts' аўтаматычны пераход да
                                                          // разводкі 'post', калі ў сыстэме існуе толькі адзін пост
    }
  }
});
</code></pre>

  <p>Існуе яшчэ адзін хук, падобны да <code class="language-js">afterModel()</code>&nbsp;&ndash; гэта <code class="language-js">redirect()</code>. Ён адрозьніваецца ад першага тым, што хукі <code class="language-js">beforeModel()</code>, <code class="language-js">model()</code> і <code class="language-js">afterModel()</code> ня будуць паўторна выкліканыя пасьля пераходу.</p>

  <h4 id="Frameworks_Ember_RouteHandlers_PreventingRetryingTransitions">Перапыненьне і паўторная спроба пераходу</h4>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.16.0/routing/preventing-and-retrying-transitions/">Guide</a></li>
    </ul>
  </div>
  <p>Пры пераходзе ад аднаго шляху да іншага, разводчык шляхоў Эмбера перадае аб'ект <code class="language-js">transition</code> у розныя хукі апрацоўшчыкаў разводкі, якія ўдзельнічаюць у гэтым пераходзе. Любы хук і мэтад, якія маюць доступ да гэтага аб'екту, могуць імгненна спыніць такі пераход, зрабіўшы выклік <code class="language-js">transition.abort()</code>, і, калі аб'ект <code class="language-js">transition</code> быў захаваны, пазьней паўтарыць спробу пераходу, зрабіўшы выклік <code class="language-js">transition.retry()</code>.</p>

  <h5 id="Frameworks_Ember_RouteHandlers_PreventingRetryingTransitions_willTransition">Перапыненьне пераходу ў <code class="language-js">willTransition()</code></h5>
  <p>Пры любой спробе пераходу (<code class="language-js">&lbrace;&lbrace;link-to&rbrace;&rbrace;</code>, <code class="language-js">transitionTo()</code>, альбо нават пры зьмене адраса ў адрасным радку браўзэра), будзе выкліканы мэтад <code class="language-js">willTransition()</code> актыўнага апрацоўшчыка разводкі. Гэта дае магчымасьць любому актыўнаму апрацоўшчыку (ад самага ніжняга па герархіі да самага верхняга) вырашаць дазволіць пераход альбо не. Уявім, што наша праграма мае складаную форму, карыстальнік увёў у яе даныя і потым выпадкова альбо проста не падумаўшы націснуў кнопку браўзэра "назад". Калі ня мець магчымасьці адмяніць такі пераход, уведзеныя даныя будуць непажадана згубленыя і карыстальніку прыйдзецца ўводзіць іх наноў. Пазьбегнуць такой сытуацыі можна наступным чынам:</p>

  <div class="pre-title"><code>app/routes/form.js</code></div>
  <pre><code class="language-js">
import Route from '@ember/routing/route';

export default Route.extend({
  actions: {
    willTransition(transition) {
      if (this.controller.get('userHasEnteredData')
            && !confirm('Are you sure you want to abandon progress?')) {
        transition.abort();
      } else {
        // Перадаць кіраваньне мэтаду `willTransition` бацькоўскага
        // апрацоўшчыка, каб і ён меў магчымасьць умяшацца ў працэс.
        return true;
      }
    }
  }
});
</code></pre>

  <p>Аднак трэба мець на ўвазе, што калі спроба зьмяніць шлях была зроблена непасрэдна ў адрасным радку альбо кнопкай браўзэра "назад", спачатку зьменіцца шлях у адрасным радку а ўжо потым будзе апрацаваны мэтад <code class="language-js">willTransition()</code>. Гэта азначае, што калі пераход нават будзе перапынены, у адрасным радку будзе ўсё роўна адлюстраваны новы шлях, куды была зроблена спроба пераходу.</p>

  <h5 id="Frameworks_Ember_RouteHandlers_PreventingRetryingTransitions_modelHooks">Перапыненьне пераходу ў мадэльных хуках</h5>
  <p>Акрамя перапыненьня пераходу ў актыўным апрацоўшчыку разводкі, яго можна перапыніць і ў апрацоўшчыку новага шляху. Мадэльныя хукі <code class="language-js">model()</code>, <code class="language-js">beforeModel()</code>, <code class="language-js">afterModel()</code> таксама прымаюць аб'ект <code class="language-js">transition</code> у якасьці парамэтру, і могуць перарваць пераход:</p>

  <div class="pre-title"><code>app/routes/disco.js</code></div>
  <pre><code class="language-js">
import Route from '@ember/routing/route';

export default Route.extend({
  beforeModel(transition) {
    if (new Date() > new Date('January 1, 2100')) {
      alert('Sorry, you need a time machine to enter this route.');
      transition.abort();
    }
  }
});
</code></pre>

  <h5 id="Frameworks_Ember_RouteHandlers_PreventingRetryingTransitions_Retrying">Паўторная спроба пераходу</h5>
  <p>У перарванага пераходу можа быць паўторная спроба ў пазьнейшы час. Адной з найбольш распаўсюджанай сфэрай выкарыстаньня зьяўляецца выпадак, калі апрацоўшчык шляху з абмежаваным доступам напраўляе карыстальніка для ўваходу ў сыстэму, а той у сваю чаргу вяртае карыстальніка назад да шляху з абмежаваным доступам пасьля пасьпяховага ўваходу ў сыстэму:</p>

  <div class="pre-title"><code>app/routes/some-authenticated.js</code></div>
  <pre><code class="language-js">
import Route from '@ember/routing/route';

export default Route.extend({
  beforeModel(transition) {
    if (!this.controllerFor('auth').get('userIsLoggedIn')) {
      let loginController = this.controllerFor('login');
      loginController.set('previousTransition', transition);
      this.transitionTo('login');
    }
  }
});
</code></pre>

  <div class="pre-title"><code>app/controllers/login.js</code></div>
  <pre><code class="language-js">
import Controller from '@ember/controller';

export default Controller.extend({
  actions: {
    login() {
      // Log the user in, then reattempt previous transition if it exists.
      let previousTransition = this.get('previousTransition');
      if (previousTransition) {
        this.set('previousTransition', null);
        previousTransition.retry();
      } else {
        // Default back to homepage
        this.transitionToRoute('index');
      }
    }
  }
});
</code></pre>

  <h4 id="Frameworks_Ember_RouteHandlers_LoadingErrorSubstates">Станы загрузкі і памылак</h4>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.16.0/routing/loading-and-error-substates/">Guide</a></li>
    </ul>
  </div>
  <p>У момант пераходу звычайна адбываецца загрузка мадэлі даных, якая можа заняць пэўны час. Разводка шляхоў у гэты момант "спыняе" працэс да таго часу, пакуль усе <a href="https://www.promisejs.org/"><i>promise</i></a> загрузкі даных ня скончаць сваё выкананьне. Калі да гэтага была адкрытая пустая старонка ў браўзэры, яна і будзе заставацца пустой да поўнай загрузкі даных. Калі быў адкрыты іншы шлях праграмы, яго старонка таксама будзе адлюстраваная да поўнай загрузкі даных новага шляху. І калі такая загрузка займае пэўны час, трэба паказаць карыстальніку нейкім чынам, што ідзе нейкая апрацоўка, што праграма не вісіць. </p>

  <h4 id="Frameworks_Ember_RouteHandlers_QueryParameters">Парамэтры запыту</h4>
  <h4 id="Frameworks_Ember_RouteHandlers_AsynchronousRouting">Асынхронная разводка</h4>

  <h3 id="Frameworks_Ember_Templates">Візуальныя макеты</h3>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/templates/handlebars-basics/">Guide</a></li>
      <li><a href="http://handlebarsjs.com">Handlebars</a></li>
    </ul>
  </div>
  <p><code class="language-js">&lbrace;&lbrace;outlet&rbrace;&rbrace;</code> пазначае месца, куды будзе ўстаўляцца зьмест укладзеных шаблёнаў:</p>

  <div class="pre-title"><code>app/templates/application.hbs</code></div>
  <pre data-line="3"><code class="language-html">
&lt;h1&gt;Title&lt;/h1&gt;

&lbrace;&lbrace;outlet&rbrace;&rbrace;
</code></pre>

  <p><i>Ember</i> аўтаматычна стварае шаблён <code class="language-bash">app/templates/index.hbs</code> для каранёвага шляху нават калі ён ня створаны яўна.</p>

  <h4 id="Frameworks_Ember_Templates_Links">Спасылкі</h4>

  <div class="pre-title"><code>app/templates/index.hbs</code></div>
  <pre><code class="language-html">
&lbrace;&lbrace;#link-to "orders" class="some-class" tagName="div"&rbrace;&rbrace;Orders&lbrace;&lbrace;/link-to&rbrace;&rbrace;
</code></pre>

  <p>Зьвярніце ўвагу на атрыбут <code class="language-html">tagName</code>, ён пазначае элемэнт <i>HTML</i> які будзе ў выніку адлюстраваны:</p>

  <pre><code class="language-html">
&lt;div id="ember3" class="some-class ember-view"&gt;Orders&lt;/div&gt;
</code></pre>

  <p>Эмбер аўтаматычна падставіў значэньне <code class="language-html">id</code>, дадаў да нашай клясы яшчэ сваю ўнутраную, і што найбольш важна, нягледзячы на тое, што гэта ня лінк, эмбер ведае, што клік на гэты блёк павінен перавесьці праграму ў новы стан (адбудзецца пераход па пазначанаму шляху).</p>

  <h4 id="Frameworks_Ember_Templates_SubexpressionHelpers">Дапаможнікі падвыразаў</h4>

  <h5 id="Frameworks_Ember_Templates_SubexpressionHelpers_Truth">Ісьціны</h5>
  <div class="refs">
    <ul>
      <li><a href="https://github.com/jmurphyau/ember-truth-helpers">GitHub</a></li>
    </ul>
  </div>
  <p>Пакет: <a href="https://www.npmjs.com/package/ember-truth-helpers"><code class="language-bash">ember-truth-helpers</code></a></p>
  <table>
    <thead>
    <tr>
      <th>Дапаможнік</th>
      <th>Аналяг у <i>JavaScript</i></th>
      <th>Прыклад у <i>HtmlBars</i></th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code class="language-bash">eq</code></td>
      <td><code class="language-js">if (a === b)</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (eq a b)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">not-eq</code></td>
      <td><code class="language-js">if (a !== b)</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (not-eq a b)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">not</code></td>
      <td><code class="language-js">if (!a)</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (not a)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">and</code></td>
      <td><code class="language-js">if (a && b)</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (and a b)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">or</code></td>
      <td><code class="language-js">if (a || b)</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (or a b)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">xor</code></td>
      <td><code class="language-js">if (a && !b || !a && b)</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (xor a b)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">gt</code></td>
      <td><code class="language-js">if (a > b)</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (gt a b)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">gte</code></td>
      <td><code class="language-js">if (a >= b)</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (gte a b)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">lt</code></td>
      <td><code class="language-js">if (a < b)</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (lt a b)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">lte</code></td>
      <td><code class="language-js">if (a <= b)</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (lte a b)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">is-array</code></td>
      <td><code class="language-js">if (Ember.isArray(a))</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (is-array a)&rbrace;&rbrace;</code></td>
    </tr>
    <tr>
      <td><code class="language-bash">is-equal</code></td>
      <td><code class="language-js">if (Ember.isEqual(a, b))</code></td>
      <td><code class="language-html">&lbrace;&lbrace;if (is-equal a b)&rbrace;&rbrace;</code></td>
    </tr>
    </tbody>
  </table>



  <h3 id="Frameworks_Ember_Components">Кампанэнты</h3>

  <h3 id="Frameworks_Ember_Models">Мадэлі</h3>

  <h3 id="Frameworks_Ember_ApplicationConcerns">Аспэкты функцыянаваньня праграмаў</h3>

  <h4 id="Frameworks_Ember_ApplicationConcerns_ApplicationsAndInstances">Праграмы і іх экзэмпляры</h4>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/applications/applications-and-instances/">Guide</a></li>
    </ul>
  </div>

  <h4 id="Frameworks_Ember_ApplicationConcerns_DependencyInjection">Ін'екцыя залежнасьцяў</h4>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/applications/dependency-injection/">Guide</a></li>
    </ul>
  </div>

  <h4 id="Frameworks_Ember_ApplicationConcerns_Initializers">Initializers</h4>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/applications/initializers/">Guide</a></li>
    </ul>
  </div>

  <h4 id="Frameworks_Ember_ApplicationConcerns_Services">Сэрвісы</h4>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/applications/services/">Guide</a></li>
    </ul>
  </div>
  <p><a href="https://emberjs.com/api/classes/Ember.Service.html"><code class="language-js">Ember.Service</code></a>&nbsp;&ndash; аб'ект, які існуе на працягу працы ўсёй праграмы. Такія аб'екты патрэбныя ў сытуацыях, калі трэба падзяляць стан ці злучэньні (<i>connections</i>) паміж рознымі часткамі праграмы. Прыкладамі такіх сытуацыяў зьяўляюцца:</p>
  <ul>
    <li>Аўтэнтыфікацыя/сэсія карыстальніка</li>
    <li>Геалякацыя</li>
    <li><i>WebSockets</i></li>
    <li>Адсылка падзеяў і паведамленьняў на сэрвэр.</li>
    <li>Лагіраваньне</li>
  </ul>

  <h5 id="Frameworks_Ember_ApplicationConcerns_Services_Defining">Генэрацыя</h5>
  <p>Сэрвіс можа быць створаны пры дапамозе <i>CLI</i>-генэратару:</p>

  <pre><code class="language-bash">
$ ember generate service shopping-cart
</code></pre>

  <p>У выніку будзе створаны сэрвіс <code class="language-js">ShoppingCart</code>, які пашырае <code class="language-js">Ember.Service</code> і можа мець свае ўласныя атрыбуты і мэтады:</p>

  <div class="pre-title"><code>app/services/shopping-cart.js</code></div>
  <pre><code class="language-js">
import Ember from 'ember';

export default Ember.Service.extend({
  items: null,

  init() {
    this._super(...arguments);
    this.set('items', []);
  },

  add(item) {
    this.get('items').pushObject(item);
  },

  remove(item) {
    this.get('items').removeObject(item);
  },

  empty() {
    this.get('items').clear();
  }
});
</code></pre>

  <h5 id="Frameworks_Ember_ApplicationConcerns_Services_Accessing">Доступ</h5>
  <p>Каб зрабіць сэрвіс даступным да выкарыстаньня ў кампанэнце ці ў іншым сэрвісе, трэба зрабіць туды яго ін'екцыю:</p>

  <div class="pre-title"><code>app/components/cart-contents.js</code></div>
  <pre><code class="language-js">
import Ember from 'ember';

export default Ember.Component.extend({
  //will load the service in file /app/services/shopping-cart.js
  cart: Ember.inject.service('shopping-cart')
});
</code></pre>

  <p>Калі імя атрыбуту для ін'екцыі супадае з імем сэрвісу, выклік можна рабіць без парамэтраў:</p>

  <div class="pre-title"><code>app/components/cart-contents.js</code></div>
  <pre><code class="language-js">
import Ember from 'ember';

export default Ember.Component.extend({
  //will load the service in file /app/services/shopping-cart.js
  shoppingCart: Ember.inject.service()
});
</code></pre>

  <p>Такія атрыбуты для ін'екцыі маюць адкладзеную ініцыяцыю (<i>lazy loading</i>), гэта азначае, што сэрвіс ня будзе створаны пакуль да яго ня будзе зьвяртаньня. Гэта ў сваю чаргу азначае, што зьвяртацца да такога артыбуту трэба не наўпрост, але праз мэтад <code class="language-js">get</code>:</p>

  <div class="pre-title"><code>app/components/cart-contents.js</code></div>
  <pre><code class="language-js">
import Ember from 'ember';

export default Ember.Component.extend({
  cart: Ember.inject.service('shopping-cart'),

  actions: {
    remove(item) {
      this.get('cart').remove(item);
    }
  }
});
</code></pre>

  <p>Пасьля таго, як была зроблена ін'екцыя сэрвісу ў кампанэнт, ён можа быць выкарыстаны ў шаблёне:</p>

  <div class="pre-title"><code>app/templates/components/cart-contents.hbs</code></div>
  <pre><code class="language-html">
&lt;ul&gt;
  &lbrace;&lbrace;#each cart.items as |item|&rbrace;&rbrace;
    &lt;li&gt;
      &lbrace;&lbrace;item.name&rbrace;&rbrace;
      &lt;button &lbrace;&lbrace;action "remove" item&rbrace;&rbrace;&gt;Remove&lt;/button&gt;
    &lt;/li&gt;
  &lbrace;&lbrace;/each&rbrace;&rbrace;
&lt;/ul&gt;
</code></pre>

  <h4 id="Frameworks_Ember_ApplicationConcerns_RunLoop">Цыкл апрацоўкі</h4>
  <div class="refs">
    <ul>
      <li><a href="https://guides.emberjs.com/v2.12.0/applications/run-loop/">Guide</a></li>
    </ul>
  </div>

  <h3 id="Frameworks_Ember_Glimmer">Glimmer</h3>
  <div class="refs">
    <ul>
      <li><a href="https://glimmerjs.com/">Home</a></li>
      <li><a href="https://glimmerjs.com/guides/">Guides</a></li>
    </ul>
  </div>
  <p><a href="https://hackernoon.com/why-im-excited-about-glimmerjs-3631bd0c95c4">Why I’m excited about GlimmerJS</a></p>
  <p>Бібліятэка для пабудовы <i>UI</i>-кампанэнтаў альбо незалежных, якія наўпрост будуць падключацца да старонкі, альбо працаваць у межах <i>Ember</i>-праграмы.</p>

  <h2 id="Frameworks_Backbone">Backbone</h2>
  <div class="refs">
    <ul>
      <li><a href="http://backbonejs.org/">Home</a></li>
      <li><a href="https://github.com/jashkenas/backbone/wiki/Tutorials,-blog-posts-and-example-sites">Resources</a></li>
    </ul>
  </div>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/getting-started-with-backbone-js/">Getting Started with Backbone.js</a></p>
  <p><a href="http://code.tutsplus.com/tutorials/single-page-todo-application-with-backbonejs--cms-21417">Single Page ToDo Application With Backbone.js</a></p>
  <p><a href="http://adrianmejia.com/blog/2012/09/11/backbone-dot-js-for-absolute-beginners-getting-started/">Backbone.js for Absolute Beginners</a></p>
  <p><a href="http://adrianmejia.com/blog/2012/09/11/backbone-dot-js-for-absolute-beginners-getting-started/">Backbone.js for Absolute Beginners</a></p>
  <p><a href="https://github.com/jashkenas/backbone/wiki/Backbone,-The-Primer">Backbone, The Primer</a></p>
  <p><a href="https://blog.andyet.com/2010/10/29/building-a-single-page-app-with-backbonejs-undersc/">Building a single page app with Backbone.js, underscore.js and jQuery</a></p>
  <p><a href="https://github.com/dmytroyarmak/backbone-contact-manager/blob/gh-pages/README.md#backbone-contact-manager">Backbone Contact Manager</a></p>
  <p><a href="http://www.bennolan.com/2010/11/24/backbone-jquery-demo.html">Backbone Mobile Example</a></p>

  <h2 id="Frameworks_KnockOut">KnockOut</h2>
  <div class="refs">
    <ul>
      <li><a href="http://knockoutjs.com/">Home</a></li>
    </ul>
  </div>
  <p><a href="http://code.tutsplus.com/series/into-the-ring-with-knockoutjs--net-22038">Into the Ring with Knockout.js</a></p>

  <h2 id="Frameworks_jQuery">jQuery</h2>
  <div class="refs">
    <ul>
      <li><a href="http://jquery.com/">Home</a></li>
      <li><a href="http://api.jquery.com/">API</a></li>
      <li><a href="http://overapi.com/jquery/">OverAPI</a></li>
      <li><a href="http://tutsplus.com/course/30-days-to-learn-jquery/" title="30-дзённы курс вывучэньня jQuery ад Jeffrey Way">Відэа-курс</a></li>
      <li><a href="http://try.jquery.com/" title="Інтэрактыўны курс ад CodeSchool">CodeSchool</a></li>
    </ul>
  </div>
  <p><i>jQuery</i>&nbsp;&ndash; гэта <i>JavaScript</i>-бібліятэка, якая спрашчае:</p>
  <ul>
    <li>доступ і маніпуляцыі з элемэнтамі <a href="http://ru.wikipedia.org/wiki/Document_Object_Model" title="Document Object Model"><span class="term">DOM</span></a>;</li>
    <li>вызначэньне рэакцый на <i>JavaScript</i>-падзеі.</li>
    <li>выкананьне <a href="#Technology_AJAX" title="Asynchronous Javascript and XML"><span class="term">AJAX</span></a>-запытаў;</li>
    <li>выкананьне <i>JavaScript</i>-эфэктаў (анімацыі).</li>
  </ul>
  <p>Бібліятэка надзвычай папулярная, як вынік над ёй працуюць шмат прафісыйных адмыслоўцаў, якія адточваюць яе да дасканаласьці. Адпаведна, нягледзячы на мінусы (напрыклад, дадатковая вага старонак, якія ўтрымліваюць бібліятэку), яе адназначна ёсьць сэнс выкарыстоўваць:</p>
  <ul>
    <li>амаль поўная адсутнасьць памылак;</li>
    <li>аптымальны код, сумяшчальны з большасьцю браўзэраў;</li>
    <li>лёгкасьць асваеньня і выкарыстаньня.</li>
  </ul>
  <p>Падключыць у дакумэнт бібліятэку можна спаслаўшыся альбо на лякальную яе вэрсію, папярэдне спампаваўшы яе <a href="http://docs.jquery.com/Downloading_jQuery">адсюль</a>:</p>

  <pre><code class="language-js">
&lt;script src="jqueri-1.7.1.js"&gt;&lt;/script&gt;
</code></pre>

  <p>альбо на адзін з даступных <a href="http://en.wikipedia.org/wiki/Content_delivery_network" title="Content Delivery Network">CDN</a>, напрыклад гуглаўскі:</p>

  <pre><code class="language-js">
&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"&gt;&lt;/script&gt;
</code></pre>

  <p>«1» у шляху, у апошнім прыкладзе азначае запыт на апошнюю вэрсію, калі патрэбна не апошняя, а пэўная вэрсія, трэба пазначыць яе замест, напрыклад: «1.7.1». Заўважце, што перавагай спасылкі на лякальную вэрсію зьяўляецца магчымасьць працаваць зь лякальнай вэрсіяй сайту, сеціўнай праграмы, ці займацца распрацоўкай нават ня маючы сувязі з інтэрнэтам. Перавагай жа спасылкі на <a href="http://en.wikipedia.org/wiki/Content_delivery_network" title="Content Delivery Network">CDN</a> зьяўляецца высокая верагоднасьць кэшаваньня файлу бібліятэкі і на сэрвэры, і ў лякальным браўзэры карыстальнікаў, што прывядзе да хутчэйшай загрузкі старонкі.</p>

  <h3 id="Frameworks_jQuery_Querying">Доступ да элемэнтаў</h3>
  <p>У самым агульным выпадку доступ да элемэнтаў <a href="http://ru.wikipedia.org/wiki/Document_Object_Model" title="Document Object Model"><span class="term">DOM</span></a> адбываецца праз <a href="../css/index.html"><span class="term">CSS</span></a>-<a href="../css/index.html#Selectors"><span class="term">сэлектары</span></a>:</p>

  <pre><code class="language-js">
var lis = jQuery("ul li");
</code></pre>

  <p><code class="language-js">jQuery</code>&nbsp;&ndash; гэта функцыя, якая мае аліас <code class="language-js">$</code>, такім чынам апошні прыклад можна запісаць больш кароткай формай:</p>

  <pre><code class="language-js">
var lis = $("ul li");
</code></pre>

  <p>У гэтых прыкладах зьменная <code class="language-js">lis</code> будзе ўтрымліваць масіў усіх элемэнтаў <a href="../html/index.html#li"><code class="language-js">li</code></a> <i>HTML</i>-дакумэнту, у якіх сярод бацькоўскіх элемэнтаў ёсьць элемэнт <a href="../html/index.html#ul"><code class="language-js">ul</code></a>.</p>
  <p><i>jQuery</i>-код амаль заўсёды маніпулюе з элемэнтамі дакумэнту, таму важна, каб ён выканаўся не ў адвольны момант часу, але менавіта пасьля таго моманту, калі дакумэнт будзе цалкам загружаны ў акно браўзэра. Для гэтага <i>jQuery</i> прадстаўляе адмысловы мэханізм:</p>

  <pre><code class="language-js">
$(document).ready(function() {
  var lis = $("ul li");
});
</code></pre>

  <p>Безназоўная функцыя, якая перадаецца ў <code class="language-js">$(document).ready()</code>, будзе выканана толькі пасьля таго, як будзе загружаны ўвесь дакумэнт цалкам.</p>

  <h4 id="Frameworks_jQuery_Querying_Children">Доступ да дзіцячых элемэнтаў</h4>
  <div class="refs">
    <ul>
      <li><a href="http://api.jquery.com/children/">children</a></li>
      <li><a href="http://api.jquery.com/find/">find</a></li>
    </ul>
  </div>
  <p>Атрымаць усе <strong>непасрэдныя</strong> дзіцячыя элемэнты можна пры дапамозе функцыі <code class="language-js">children</code>. У наступным прыкладзе:</p>

  <pre><code class="language-js">
$(document).ready(function() {
  var lis = $("ul.emphasis").children("li");
});
</code></pre>

  <p>зьменная <code class="language-js">lis</code> будзе ўтрымліваць усе наўпроставыя дзіцячыя элемэнты <a href="../html/index.html#li"><code class="language-js">li</code></a> элемэнту <a href="../html/index.html#ul"><code class="language-js">ul</code></a>, чыя кляса пазначана як <code class="language-js">emphasis</code>, адзначаныя ў радках 2, 3 і 4 у прыкладзе ніжэй:</p>

  <pre data-line="2,3,4"><code class="language-html">
&lt;ul class="emphasis"&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;third&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

  <p><i>jQuery</i>-выраз <code class="language-js">$("ul.emphasis").children("li")</code> эквівалентны <i>CSS</i>-<a href="../css/index.html#Selectors"><span class="term">сэлектару</span></a> <code class="language-js">ul.emphasis > li</code>.</p>
  <p>Атрымаць <strong>усе</strong> дзіцячыя элемэнты <strong>незалежна ад герархіі</strong> можна пры дапамозе функцыі <code class="language-js">find</code>. У наступны прыкладзе:</p>

  <pre><code class="language-js">
$(document).ready(function() {
  var lis = $("ul.emphasis").find("li");
});
</code></pre>

  <p>зьменная <code class="language-js">lis</code> будзе ўтрымліваць усе дзіцячыя элемэнты <a href="../html/index.html#li"><code class="language-js">li</code></a> элемэнту <a href="../html/index.html#ul"><code class="language-js">ul</code></a>, чыя кляса пазначана як <code class="language-js">emphasis</code>, адзначаныя ў радках 2, 3, 4 і 6 у прыкладзе ніжэй:</p>

  <pre data-line="2,3,4,6"><code class="language-html">
&lt;ul class="emphasis"&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;third&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

  <p><i>jQuery</i>-выраз <code class="language-js">$("ul.emphasis").find("li")</code> эквівалентны <i>CSS</i>-<a href="../css/index.html#Selectors"><span class="term">сэлектару</span></a> <code class="language-js">ul.emphasis li</code>.</p>

  <h4 id="Frameworks_jQuery_Querying_Parents">Доступ да бацькоўскіх элемэнтаў</h4>
  <div class="refs">
    <ul>
      <li><a href="http://api.jquery.com/parent/">parent</a></li>
      <li><a href="http://api.jquery.com/parents/">parents</a></li>
      <li><a href="http://api.jquery.com/closest/">closest</a></li>
    </ul>
  </div>
  <p>Аналягічна функцыям доступу да дзіцячых элемэнтаў сярод функцыяў доступу да бацькоўскіх ёсьць:</p>
  <ul>
    <li><code class="language-js">parent</code>, якая вяртае <strong>наўпроставага</strong> бацьку ў герархіі;</li>
    <li><code class="language-js">parents</code>, якая вяртае <strong>ўсе</strong> бацькоўскія элемэнты адпаведна пазначанаму <i>CSS</i>-<a href="../css/index.html#Selectors">сэлектару</a>, <strong>незалежна ад герархіі</strong>;</li>
    <li>а таксама <code class="language-js">closest</code>, якая вяртае <strong>бліжэйшы</strong> элемэнт у бацькоўскай герархіі, <strong>улучна з самім элемэнтам</strong>, у якога гэта функцыя выклікаецца.</li>
  </ul>

  <h4 id="Frameworks_jQuery_Querying_SameLevel">Доступ да элемэнтаў аднаго ўзроўню</h4>
  <div class="refs">
    <ul>
      <li><a href="http://api.jquery.com/siblings/">siblings</a></li>
    </ul>
  </div>
  <p>Уявім, што мы маем наступны <i>HTML</i>-код:</p>

  <pre><code class="language-js">
&lt;div class="buttons"&gt;
  &lt;button&gt;першая&lt;/button&gt;
  &lt;button&gt;другая&lt;/button&gt;
  &lt;button&gt;трэцяя&lt;/button&gt;
&lt;/div&gt;
</code></pre>

  <p>а таксама наступны <i>jQuery</i>-код:</p>

  <pre><code class="language-js">
$(".buttons button").on("click", function() {
  concole.log($(this).text());
});
</code></pre>

  <p>У выніку, у кансоль браўзэра будзе выведзена імя націснутай кнопкі. Для таго, каб атрымаць усе элемэнты таго ж узроўню, маецца функцыя <code class="language-js">siblings</code>:</p>

  <pre><code class="language-js">
$(".buttons button").on("click", function() {
  $(this).siblings().text("siblings");
});
</code></pre>

  <p>У выніку пры націсканьні на адну з кнопак тэкст <strong>астатніх</strong> (але не націснутай) будзе выстаўлены як «siblings».</p>

  <h4 id="Frameworks_jQuery_Querying_Narrowing">Звужэньне набору элемэнтаў</h4>
  <div class="refs">
    <ul>
      <li><a href="http://api.jquery.com/first/">first</a></li>
      <li><a href="http://api.jquery.com/last/">last</a></li>
      <li><a href="http://api.jquery.com/eq/">eq</a></li>
      <li><a href="http://api.jquery.com/filter/">filter</a></li>
    </ul>
  </div>
  <p>У выпадку, калі пэўны <i>jQuery</i>-запыт вярнуў шэраг элемэнтаў, маюцца функцыі звужэньня гэтага набору:</p>
  <ul>
    <li>функцыя <code class="language-js">first</code> верне <strong>першы</strong> элемэнт шэрагу (альбо масіву);</li>
    <li><code class="language-js">last</code> верне <strong>апошні</strong> элемэнт шэрагу;</li>
    <li>функцыя <code class="language-js">eq</code> верне адвольны элемэнт <strong>па ягонаму індэксу</strong> (пачынаючы з 0);</li>
    <li>а функцыя <code class="language-js">filter</code> звузіць набор да тых элемэнтаў, якія <strong>задаволяць</strong> перададзенаму ёй <i>CSS</i>-<strong>крытэру</strong>.</li>
  </ul>

  <pre><code class="language-js">
var second = $(".buttons").find("button").eq(1);
var last = $(".buttons").find("button").filter(":last-child");
// апошняе эквівалентна (менавіта ў дадзеным выпадку):
var last = $(".buttons").find("button").last();
</code></pre>

  <p>У выніку, у апошнім прыкладзе, мы атрымаем ня ўсе кнопкі кантэйнэра <code class="language-js">buttons</code>, але толькі другую ў першым радку і апошнюю ў другім і чацьвертым радку. Яшчэ адзін прыклад выкарыстаньня функцыі <code class="language-js">filter</code>:</p>

  <pre><code class="language-js">
// Дадасьць клясу hidden толькі да тых dd, якія зьяўляюцца ня менш як 4мі
// дзіцячымі элемэнтамі свайго бацькі, то бок пачынаючы з 2га dd:
$("dd").filter(":nth-child(n+4)").addClass("hidden");
</code></pre>

  <pre><code class="language-js">
&lt;dl&gt;
  &lt;dt&gt;What are your hours?&lt;/dt&gt;
  &lt;dd&gt;We are open 24/7.&lt;/dd&gt;
  &lt;dt&gt;What are your hours?&lt;/dt&gt;
  &lt;dd class="hidden"&gt;We are open 24/7.&lt;/dd&gt;
  &lt;dt&gt;What are your hours?&lt;/dt&gt;
  &lt;dd class="hidden"&gt;We are open 24/7.&lt;/dd&gt;
  &lt;dt&gt;What are your hours?&lt;/dt&gt;
  &lt;dd class="hidden"&gt;We are open 24/7.&lt;/dd&gt;
  &lt;dt&gt;What are your hours?&lt;/dt&gt;
  &lt;dd class="hidden"&gt;We are open 24/7.&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>

  <h4 id="Frameworks_jQuery_Querying_Navigation">Перамяшчэньне па наборы элемэнтаў</h4>
  <div class="refs">
    <ul>
      <li><a href="http://api.jquery.com/prev/">prev</a></li>
      <li><a href="http://api.jquery.com/next/">next</a></li>
    </ul>
  </div>
  <p>Таксама інсуюць функцыі перамяшчэньня па масіву элемэнтаў. У прыкладзе вышэй мы атрымалі другую кнопку кантэйнэра <code class="language-js">buttons</code>. Цяпер мы можам атрымаць доступ да папярэдняй ці наступнай кнопцы ў гэтым наборы праз функцыі <code class="language-js">prev</code> і <code class="language-js">next</code>:</p>

  <pre><code class="language-js">
var first = $(".buttons").find("button").eq(1).prev();
</code></pre>

  <p>што эквівалентна наступнаму:</p>

  <pre><code class="language-js">
var first = $(".buttons").find("button").first();
</code></pre>

  <h4 id="Frameworks_jQuery_Querying_Chaining">Ланцуг выклікаў</h4>
  <div class="refs">
    <ul>
      <li><a href="http://api.jquery.com/end/">end</a></li>
    </ul>
  </div>
  <p>Кожная <i>jQuery</i>-функцыя вяртае <i>jQuery</i>-аб'ект, які абгортвае адпаведны(-я) <i>JavaScript</i>-аб'ект(-ы). Гэта дазваляе запісваць выклікі функцый у ланцуг, як можна было зразумець з папярэдніх прыкладаў. Калі ў такім ланцугу прысутнічаюць функцыі доступу да элемэнтаў, фільтрацыі набору элемэнтаў, ці перамяшчэньня па наборы, адмяніць вынік працы папярэдняй такой функцыі можна пры дапамозе функцыі <code class="language-js">end</code>:</p>

  <pre><code class="language-js">
$(".buttons button").on("click", function() {
  $(this)                   // вяртае націснутую кнопку
    .siblings()             // вяртае ўсе элемэнты таго ж узроўню, то бок усе кнопкі
    .removeAttr("disabled") // выдаляе атрыбут disabled ува ўсіх кнопак
  .end()                    // адмяняе вынік працы апошняй функцыі доступу - siblings,
                            // то бок звужаем набор, у выніку jQuery-аб'ект будзе
                            // ўтрымліваць спасылку толькі на націснутую кнопку
  .attr("disabled", "disabled"); // дадаем атрыбут disabled да гэтай націснутай кнопкі
});
</code></pre>

  <p>Вынікам будзе наступны эфэкт (панаціскайце на кнопкі):</p>
  <a class="jsbin-embed" href="http://jsbin.com/gijeyet/embed?js,output&height=180px">Прыклад на jsbin.com</a>

  <h4 id="Frameworks_jQuery_Querying_this"><code class="language-js">this</code></h4>
  <p>У дадатак да таго, што ўжо апісана <a href="#Operators_Object_this">вышэй</a> у дачыненьні да <i>JavaScript</i>, у <i>jQuery</i> існуе яшчэ адна магчымасьць пазначыць кантэкст функцыі (злучыць <code class="language-js">this</code> унутры функцыі з пэўным аб'ектам)&nbsp;&ndash; гэта мэтад <code class="language-js">$.proxy</code>:</p>

  <pre><code class="language-js">
var myFunction = function() { console.log(this); };
var myObject = { foo : 'bar' };

myFunction(); // Вывядзе аб'ект window

var myProxyFunction = $.proxy(myFunction, myObject);
myProxyFunction(); // Вывядзе аб'ект myObject
</code></pre>

  <p>ці так:</p>

  <pre><code class="language-js">
var myObject = {
    myFn : function() {
        console.log(this);
    }
};

$('#foo').click(myObject.myFn); // Вывядзе элемэнт з id 'foo'
$('#foo').click($.proxy(myObject, 'myFn')); // Вывядзе аб'ект myObject
</code></pre>

  <h3 id="Frameworks_jQuery_Manipulating">Маніпуляцыі з элемэнтамі</h3>

  <h4 id="Frameworks_jQuery_Manipulating_Attributes">Атрыбуты элемэнтаў</h4>
  <div class="refs">
    <ul>
      <li><a href="http://api.jquery.com/attr/">attr</a></li>
      <li><a href="http://api.jquery.com/data/">data</a></li>
      <li><a href="http://api.jquery.com/removeAttr/">removeAttr</a></li>
    </ul>
  </div>
  <p>Атрымаць і зьмяніць значэньне атрыбуту пэўнага <i>HTML</i>-элемэнту можна пры дапамозе варыянтаў функцыі <code class="language-js">attr</code>. Варыянт з адным парамэтрам (назвай атрыбуту) верне значэньне атрыбуту. Варыянт з двума парамэтрамі (першы&nbsp;&ndash; назва атрыбуту, другі&nbsp;&ndash; яго значэньне) альбо дадасьць новы атрыбут з пазначаным значэньнем, альбо зьменіць значэньне існага атрыбуту на пазначанае:</p>

  <pre><code class="language-js">
$("#elem").attr("title", "Some title");   // Знаходзім элемэнт з id "elem" і прызначаем
                                          // яго атрыбуту title значэньне "Some title"
concole.log($("#elem").attr("title"));    // Выводзім у кансоль прызначанае ў папярэднім
                                          // выразе значэньне атрыбуту title
</code></pre>

  <p>Таксама існуе варыянт функцыі, у якім можна адначасна зьмяняць значэньні некалькіх атрыбутаў:</p>

  <pre><code class="language-js">
$('#greatphoto').attr({
  alt: 'Beijing Brush Seller',
  title: 'photo by Kelly Clark'
});
</code></pre>

  <p>...і варыянт, калі ў якасьці друга парамэтру выкарыстоўваецца ня проста значэньне, але функцыя, якая павінна вяртаць новае значэньне, а прымае яна індэкс элемэнту ў наборы і старое значэньне атрыбуту:</p>

  <pre><code class="language-js">
$('#greatphoto').attr('title', function(i, val) {
  return val + ' - photo by Kelly Clark'
});
</code></pre>

  <p>Спэцыфікацыя <i>HTML</i>5 дазволіла выкарыстоўваць карыстальніцкія атрыбуты для элемэнтаў выгляду <code class="language-js">data-...</code>:</p>

  <pre><code class="language-js">
&lt;button data-file="day"&gt;Day&lt;/button&gt;
</code></pre>

  <p>Для доступу да такіх атрыбутаў у <i>jQuery</i> ёсьць адмысловая аліас-функцыя <code class="language-js">data</code>:</p>

  <pre><code class="language-js">
$("button").data("file");
// што эквівалентна:
$("button").attr("data-file");
</code></pre>

  <p>Цалкам выдаліць пэўны атрыбут з элемэнту можна пры дапамозе функцыі <code class="language-js">removeAttr</code>:</p>

  <pre><code class="language-js">
$('#greatphoto').removeAttr('title');
</code></pre>

  <h4 id="Frameworks_jQuery_Manipulating_Content">Дадаваньне зьместу</h4>
  <div class="refs">
    <ul>
      <li><a href="http://api.jquery.com/append/">append</a></li>
      <li><a href="http://api.jquery.com/appendTo/">appendTo</a></li>
      <li><a href="http://api.jquery.com/prepend/">prepend</a></li>
      <li><a href="http://api.jquery.com/prependTo/">prependTo</a></li>
      <li><a href="http://api.jquery.com/after/">after</a></li>
      <li><a href="http://api.jquery.com/insertAfter/">insertAfter</a></li>
      <li><a href="http://api.jquery.com/before/">before</a></li>
      <li><a href="http://api.jquery.com/insertBefore/">insertBefore</a></li>
    </ul>
  </div>
  <p>У <i>jQuery</i> існуе шэраг функцыяў, пры дапамозе якіх можна дадаць зьмест да старонкі. Уявім, што ў нас маецца наступны фрагмэнт дакумэнту:</p>

  <pre><code class="language-js">
&lt;article&gt;
  &lt;h1&gt;Загаловак&lt;/h1&gt;
  &lt;p&gt;Параграф 1.&lt;/p&gt;
  &lt;p&gt;Параграф 2.&lt;/p&gt;
&lt;/article&gt;
</code></pre>

  <p>Які будзе выглядаць наступным чынам:</p>
  <div class="example manipulating_content_example">
    <div class="example_content">
      <div>
        <h1>Загаловак</h1>
        <p>Параграф 1.</p>
        <p>Параграф 2.</p>
      </div>
    </div>
  </div>
  <p>Дадаць зьмест <strong>у пачатак</strong> альбо <strong>канец</strong> пэўнага элемэнту можна пры дапамозе функцыяў <code class="language-js">prepend</code> і <code class="language-js">append</code> адпаведна. Напрыклад, наступны скрыпт:</p>

  <pre><code class="language-js">
$("p").last().append(" Трохі тэксту ў параграф.");
</code></pre>

  <p>Дадасьць тэкст « Трохі тэксту ў параграф.» у канец апошняга (2-га) параграфу:</p>
  <div class="example manipulating_content_example">
    <div class="example_content">
      <div>
        <h1>Загаловак</h1>
        <p>Параграф 1.</p>
        <p>Параграф 2. Трохі тэксту ў параграф.</p>
      </div>
    </div>
  </div>
  <p>Дадаць зьмест <strong>перад</strong> альбо <strong>пасьля</strong> пэўнага элемэнту можна пры дапамозе функцыяў <code class="language-js">before</code> і <code class="language-js">after</code> адпаведна. Напрыклад, наступны скрыпт:</p>

  <pre><code class="language-js">
$("p").last().before("Трохі тэксту перад параграфам.");
</code></pre>

  <p>Дадасьць тэкст «Трохі тэксту перад параграфам.» перад апошнім параграфам:</p>
  <div class="example manipulating_content_example">
    <div class="example_content">
      <div>
        <h1>Загаловак</h1>
        <p>Параграф 1.</p>
        Трохі тэксту перад параграфам.
        <p>Параграф 2.</p>
      </div>
    </div>
  </div>
  <p>Як можна заўважыць фарматаваньне дададзенага фрагмэнту адрозьніваецца ад фарматаваньня параграфаў. Гэта таму, што тэкст быў дададзены як звычайны тэкст наўпрост у артыкул, што ў большасьці выпадкаў не зусім правільна. Правільней было б стварыць новы элемэнт параграфу з тэкстам унутры і ўставіць яго ў дакумэнт. Для гэтага існуюць функцыі <code class="language-js">appendTo</code>, <code class="language-js">prependTo</code>, <code class="language-js">insertBefore</code> і <code class="language-js">insertAfter</code>. Напрыклад, папярэдні прыклад больш правільна было б рэалізаваць наступным чынам:</p>

  <pre><code class="language-js">
$("&lt;p&gt;Новы параграф.&lt;/p&gt;").insertBefore($('p').last());
</code></pre>

  <div class="example manipulating_content_example">
    <div class="example_content">
      <div>
        <h1>Загаловак</h1>
        <p>Параграф 1.</p>
        <p>Новы параграф.</p>
        <p>Параграф 2.</p>
      </div>
    </div>
  </div>
  <p>Па-першае, зьвярніце ўвагу на тое, што выкарыстаньне гэтых апошніх чатырох функцыяў іншае ў параўнаньні зь першымі чатырма. У гэтыя функцыі перадаецца ня новы зьмест, а існыя элемэнты, у якія (ці пасьля/перад якімі) трэба ўставіць зьмест.</p>
  <p>Па-другое, зьвярніце ўвагу на тое, што код <code class="language-js">$("&lt;p&gt;Новы параграф.&lt;/p&gt;")</code> будзе не шукаць элемэнт на старонцы, а створыць цалкам новы элемэнт, які пасьля дадзенага выкліку будзе існаваць адно толькі ў памяці кампутара, і толькі пасьля выкліку функцыі <code class="language-js">insertBefore</code> будзе ўстаўлены ў дакумэнт.</p>
  <p>Таксама трэба заўважыць, што фрагмэнт <code class="language-js">$("&lt;p&gt;Новы параграф.&lt;/p&gt;")</code> не зусім адпавядае добрай практыцы напісаньня <i>JavaScript</i>. Лепш яго перапісаць наступным чынам:</p>

  <pre><code class="language-js">
$("&lt;p&gt;&lt;/p&gt;", {
  text: "Новы параграф."
})
</code></pre>

  <p>Для большай нагляднасьці пашырым гэты прыклад, каб пазначыць <code class="language-js">class</code> і <code class="language-js">id</code> новага элемэнту:</p>

  <pre><code class="language-js">
$("&lt;p&gt;&lt;/p&gt;", {
  text: "Новы параграф.",
  class: "myClass",
  id: "myId"
})
</code></pre>

  <p>Варта закрануць яшчэ адзін нечаканы эфэкт ужываньня функцыяў <code class="language-js">appendTo</code>, <code class="language-js">prependTo</code>, <code class="language-js">insertBefore</code> і <code class="language-js">appendTo</code>. Калі яны выклікаюцца ня ў створанага элемэнту, але ў існага, адбываецца перанос гэтага элемэнту з першапачатковай пазыцыі на старонцы ў новую пазыцыю. Наступны код:</p>

  <pre><code class="language-js">
$("h1").insertAfter($('p').last());
</code></pre>

  <p>Прывядзе да пераносу загалоўку з пачатку артыкула ў яго канец:</p>
  <div id="insertAfter_example" class="example manipulating_content_example">
    <div class="example_content">
      <div>
        <p>Параграф 1.</p>
        <p>Параграф 2.</p>
        <h1>Загаловак</h1>
      </div>
    </div>
  </div>

  <h3 id="Frameworks_jQuery_EventsHandling">Апрацоўка падзеяў</h3>
  <div class="refs">
    <ul>
      <li><a href="http://api.jquery.com/on/">on</a></li>
      <li><a href="http://api.jquery.com/off/">off</a></li>
      <li><a href="http://api.jquery.com/bind/" class="deprecated_link">bind</a></li>
      <li><a href="http://api.jquery.com/unbind/" class="deprecated_link">unbind</a></li>
      <li><a href="http://api.jquery.com/live/" class="deprecated_link">live</a></li>
      <li><a href="http://api.jquery.com/die/" class="deprecated_link">die</a></li>
      <li><a href="http://api.jquery.com/delegate/" class="deprecated_link">delegate</a></li>
      <li><a href="http://api.jquery.com/undelegate/" class="deprecated_link">undelegate</a></li>
    </ul>
  </div>
  <p>Функцыі <code class="language-js">bind</code> і <code class="language-js">unbind</code> прызначаліся раней для усталёўкі і зьняцьця апрацоўшчыкаў падзеяў на і з пэўных элемэнтаў, якія на дадзены момант знаходзяцца ў дакумэнце. Адпаведна, элемэнты, якія былі дададзеныя да дакумэнту пазьней, ня мелі гэтага апрацоўшчыка. Пазьней зьявіўся мэтад, які пазбаўляўся ад гэтага недахопу&nbsp;&ndash; <code class="language-js">live</code>, і парны для яго <code class="language-js">die</code>. Ён дадаваў пазначаны апрацоўшчык падзеі ня толькі да існых элемэнтаў, адпавядаючых крытэру, але і да ўсіх тых, якія зьяўляліся ў дакумэнце пазьней. Потым зьявіліся <code class="language-js">delegate</code>/<code class="language-js">undelegate</code>. Ідэя апошніх была ў тым, што ў выпадку, калі ў дакумэнце існуе шмат ідэнтычных элемэнтаў, і ўсе яны павінны аднолькава рэагаваць на пэўную падзею, усталёўваць на іх усіх адзін і той жа апрацоўшчык немэтазгодна, асабліва калі такіх элемэнтаў можа быць сотні ці тысячы&nbsp;&ndash; гэта можа вельмі значна запаволіць працу старонкі. Замест гэтага лепш усталяваць адзін апрацоўшчык, на іх бацькоўскіх элемэнт, і каб ён <em>дэлегаваў</em> апрацоўку сваім адпаведным даччыным элемэнтам. Адсюль і назва мэтаду. Трэба заўважыць, што тое ж самае можна было зрабіць і з дапамогай функцыі <code class="language-js">live</code>, але <code class="language-js">delegate</code> ня проста меў такую магчымасьць, яго назва і сынтакс накіроўвалі распрацоўшчыкаў у бок лепшай практыкі.</p>
  <p>Але, гэта ўсё перадгісторыя, на самай справе ў <i>jQuery</i>, пачынаючы з вэрсіі 1.7, былі ізноў уведзены новыя функцыі&nbsp;&ndash; <code class="language-js">on</code> і <code class="language-js">off</code>, якія павінны былі ўвасобіць у сабе самае лепшае сваіх папярэднікаў, а ўсе вышэйпералічаныя былі пазначаныя як непажаданыя да выкарыстаньня. Яны засталіся ў бібліятэцы, але зьяўляюцца на дадзены момант нічым іншым як аліас-функцыямі да актуальных <code class="language-js">on</code> і <code class="language-js">off</code>.</p>
  <p>Разгледзім навочны прыклад. Возьмем элемэнт <a href="../html/index.html#dl"><code class="language-js">dl</code></a> з прыкладу вышэй, дзе 5 разоў зьмяшчаецца тэрмін <code class="language-js">What are your hours?</code> і яго вызначэньне <code class="language-js">We are open 24/7.</code> Пры дапамозе наступнага коду:</p>

  <pre><code class="language-js">
$("dd").filter(":nth-child(n+4)").addClass("hidden");
$("dl").on("mouseenter", "dt", function() {
    $(this)
        .next()             // пераходзім з "спрацаваўшага" dt на яго dd
        .slideDown(200)     // паказваем гэты dd з эфэктам slideDown
            .siblings("dd") // атрымліваем астатнія dd элемэнты
            .slideUp(200);  // і хаваем іх з эфэктам slideUp
});
</code></pre>

  <p>можна дасягнуць наступнага выніку (панаводзьце курсар мышы на розныя элемэнты):</p>
  <a class="jsbin-embed" href="http://jsbin.com/yamoyeh/embed?js,output&height=380px">Прыклад на jsbin.com</a>

  <p>Апрацоўшчык падзеі <code class="language-js">mouseenter</code> (кажучы мовай <i>CSS</i>&nbsp;&ndash; <i>hover</i>) будзе ўсталяваны не на кожны элемэнт <a href="../html/index.html#dt"><code class="language-js">dt</code></a>, але на ўвесь сьпіс <a href="../html/index.html#dl"><code class="language-js">dl</code></a>, прычым апрацоўку падзеі сьпіс будзе дэлегаваць адпаведнаму элемэнту <a href="../html/index.html#dt"><code class="language-js">dt</code></a> (на які быў наведзены курсар мышы). Дэлегаваць не ў наўпроставым сэнсе, а ў тым, што <code class="language-js">$(this)</code> у апрацоўшчыку будзе спасылацца на адпаведны <a href="../html/index.html#dt"><code class="language-js">dt</code></a>-элемэнт.</p>

  <h4 id="Frameworks_jQuery_EventsHandling_EventTypes">Тыпы падзеяў</h4>
  <p>У табліцы ніжэй прыведзеныя магчымыя тыпы падзеяў.</p>
  <table>
    <thead>
    <tr>
      <th>Тып падзеі</th>
      <th>Апісаньне</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><a href="http://api.jquery.com/blur/"><code class="language-js">blur</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі той губляе фокус. Раней падзея ўжывалася толькі для элемэнтаў формаў, зараз&nbsp;&ndash; да любых элемэнтаў старонкі. Парная падзея да падзеі <code class="language-js">focus</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/change/"><code class="language-js">change</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі зьмяняецца яго значэньне. Ужываньне абмежаванае элемэнтамі <a href="../html/index.html#input"><code class="language-js">input</code></a>, <a href="../html/index.html#textarea"><code class="language-js">textarea</code></a> і <a href="../html/index.html#select"><code class="language-js">select</code></a>. У выпадку чэкбоксаў, радыёкнопак і сэлектбоксаў падзея дасылаецца адразу ж пасьля зьмены значэньня. У выпадку астатніх элемэнтаў падзея дасылаецца толькі пасьля таго, як зь іх сайдзе фокус.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/click/"><code class="language-js">click</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі над элемэнтам знаходзіцца курсор мышы і была націснутая (падзея <code class="language-js">mousedown</code>) і вызвалена (падзея <code class="language-js">mouseup</code>) яе кнопка. Для спрацоўваньня гэтай падзеі патрэбна менавіта пасьлядоўнасьць гэтых дзьвюх апэрацыяў, а не асобныя зь іх. Ужываецца да любых элемэнтаў старонкі.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/dblclick/"><code class="language-js">dblclick</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі над элемэнтам знаходзіцца курсор мышы і была пасьлядоўна 2 разы націснутая і вызвалена яе кнопка. На адзін і той жа элемэнт не рэкамэндуецца ўсталёўваць адначасова апрацоўшчыкі падзеяў <code class="language-js">click</code> і <code class="language-js">dblclick</code>. Ужываецца да любых элемэнтаў старонкі.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/error/"><code class="language-js">error</code></a></td>
      <td>Падзея дасылаецца элемэнту, напрыклад выяве, калі яго рэсурс ня можа быць згружаны звонку (няправільная спасылка, тып рэсурсу альбо памылка выкананьня скрыпту).</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/focus/"><code class="language-js">focus</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі той атрымлівае фокус. Па змоўчваньні фокус могуць атрымаць толькі элемэнты формы і спасылкі, але элемэнту любога тыпу можна пазначыць атрыбут <code class="language-js">tabindex</code>, тады ён таксама будзе здольны атрымаць фокус. Парная падзея да падзеі <code class="language-js">blur</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/focusin/"><code class="language-js">focusin</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі ён альбо адзін з яго даччыных элемэнтаў атрымлівае фокус. Парная падзея да падзеі <code class="language-js">focusout</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/focusout/"><code class="language-js">focusout</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі ён альбо адзін з яго даччыных элемэнтаў губляе фокус. Парная падзея да падзеі <code class="language-js">focusin</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/keydown/"><code class="language-js">keydown</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі карыстальнік націскае нейкую кнопку клявіятуры, але толькі ў тым выпадку, калі гэты элемэнт утрымлівае фокус. Парная падзея да падзеі <code class="language-js">keyup</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/keypress/"><code class="language-js">keypress</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі браўзэр рэгіструе націсканьне кнопкі клявіятуры, але толькі ў тым выпадку, калі гэты элемэнт утрымлівае фокус. Падзея падобная да <code class="language-js">keydown</code>. Адрозьненьні ў тым, што пры націсканьні й утрымліваньні націснутай пэўнай кнопкі клявіятуры <code class="language-js">keydown</code> спрацуе адзін раз, а <code class="language-js">keypress</code> тым часам спрацуе столькі разоў, колькі будзе пры гэтым ўстаўлена сымбаляў (напрыклад, у тэкставае поле). Таксама адрозьненьні ў тым, што пры націсканьні мадыфікацыйных кнопак (<i>Shift</i>, <i>Ctrl</i> і г.д.) падзея <code class="language-js">keydown</code> спрацуе, а <code class="language-js">keypress</code>&nbsp;&ndash; не.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/keyup/"><code class="language-js">keyup</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі карыстальнік адпускае раней націснутую кнопку клявіятуры, але толькі ў тым выпадку, калі гэты элемэнт утрымлівае фокус. Парная падзея да падзеі <code class="language-js">keydown</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/load/"><code class="language-js">load</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі яго зьмест і ўсіх яго даччыных элемэнтаў цалкам запампаваны ў старонку. Ужываецца толькі для тых элемэнтаў, якія могуць быць зьвязаны з <a href="http://ru.wikipedia.org/wiki/URL" title="Uniform Resource Locator">URL</a>'ам: выявы, скрыпты, фрэймы і вокны.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/mousedown/"><code class="language-js">mousedown</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі націснулі кнопку мышы і пры гэтым курсор мышы знаходзіўся над гэтым элемэнтам. Ужываецца да любых элемэнтаў старонкі. Парная падзея да падзеі <code class="language-js">mouseup</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/mouseenter/"><code class="language-js">mouseenter</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі курсор мышы «заходзіць» на яго. У адрозьненьні ад падзеі <code class="language-js">mouseover</code> <strong>ня</strong> будзе дасланая бацькоўскаму элемэнту, калі курсор мышы «зойдзе» на яго даччыны элемэнт, які графічна знаходзіцца ў межах гэтага бацькоўскага элемэнту, над ім. Ужываецца да любых элемэнтаў старонкі. Парная падзея да падзеі <code class="language-js">mouseleave</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/mouseleave/"><code class="language-js">mouseleave</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі курсор мышы «сыходзіць» зь яго. У адрозьненьні ад падзеі <code class="language-js">mouseout</code> <strong>ня</strong> будзе дасланая бацькоўскаму элемэнту, калі курсор мышы «сыдзе» зь яго даччынага элемэнту, які графічна знаходзіцца ў межах гэтага бацькоўскага элемэнту, над ім. Ужываецца да любых элемэнтаў старонкі. Парная падзея да падзеі <code class="language-js">mouseenter</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/mousemove/"><code class="language-js">mousemove</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі курсор мышы рухаецца над гэтым элемэнтам, пры гэтым незалежна ад таго, наўпрост над ім, альбо над адным зь яго дзіцячых элемэнтаў. Ужываецца да любых элемэнтаў старонкі.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/mouseout/"><code class="language-js">mouseout</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі курсор мышы «сыходзіць» зь яго. У адрозьненьні ад падзеі <code class="language-js">mouseleave</code> <strong>будзе</strong> дасланая бацькоўскаму элемэнту, нават калі курсор мышы «сыдзе» зь яго даччынага элемэнту, які графічна знаходзіцца ў межах гэтага бацькоўскага элемэнту, над ім. Ужываецца да любых элемэнтаў старонкі. Парная падзея да падзеі <code class="language-js">mouseover</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/mouseover/"><code class="language-js">mouseover</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі курсор мышы «заходзіць» на яго. У адрозьненьні ад падзеі <code class="language-js">mouseenter</code> <strong>будзе</strong> дасланая бацькоўскаму элемэнту, нават калі курсор мышы «зойдзе» на яго даччыны элемэнт, які графічна знаходзіцца ў межах гэтага бацькоўскага элемэнту, над ім. Ужываецца да любых элемэнтаў старонкі. Парная падзея да падзеі <code class="language-js">mouseout</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/mouseup/"><code class="language-js">mouseup</code></a></td>
      <td>Падзея дасылаецца элемэнту, калі адпусьцілі кнопку мышы і пры гэтым курсор мышы знаходзіўся над гэтым элемэнтам. Парная падзея да падзеі <code class="language-js">mousedown</code>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/resize/"><code class="language-js">resize</code></a></td>
      <td>Падзея дасылаецца элемэнту <code class="language-js">window</code>, калі зьмяняецца памер акна браўзэра.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/scroll/"><code class="language-js">scroll</code></a></td>
      <td>Падзея дасылаецца аконным, фрэймавым элемэнтам, ці любым іншым, чый <i>CSS</i>-атрыбут <code class="language-js">overflow</code> мае значэньне <code class="language-js">scroll</code>, калі пазыцыя яго скролінгу зьмяняецца.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/select/"><code class="language-js">select</code></a></td>
      <td>Падзея дасылаецца элемэнтам, калі карыстальнік зьмяняе абраньне тэксту ў ім. Падзея ўжываецца толькі для элемэнтаў <a href="../html/index.html#input_text"><code class="language-js">input type="text"</code></a> і <a href="../html/index.html#textarea"><code class="language-js">textarea</code></a>.</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/submit/"><code class="language-js">submit</code></a></td>
      <td>Падзея дасылаецца элемэнту <a href="../html/index.html#form"><code class="language-js">form</code></a>, калі адбываецца спроба яе сабміту (дасылкі даных).</td>
    </tr>
    <tr>
      <td><a href="http://api.jquery.com/unload/"><code class="language-js">unload</code></a></td>
      <td>Падзея дасылаецца элемэнту <code class="language-js">window</code>, калі адбываецца зьмена адрасу старонкі. Падзея генэруецца ня толькі пры наўпроставай зьмене адрасу: кнопкі «назад» і «ўперад» браўзэра, пераход па спасылцы, увод новага адрасу ў адрасны радок, але таксама пры ўскосным дзеяньні: перагрузка той жа самай старонкі і нават закрыцьцё акна ці ўстаўкі браўзэра.</td>
    </tr>
    </tbody>
  </table>

  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/20-helpful-jquery-methods-you-should-be-using/">20 Helpful jQuery Methods you Should be Using</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-an-introduction-to-jquery-templating/">An Introduction to jQuery Templating</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/fun-with-jquery-templating-and-ajax/">jQuery Templating and AJAX</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-display-elements-sequentially-with-jquery/">Display Elements Sequentially with jQuery</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/progressively-enhance-a-form-link-to-modal-form/">Progressively Enhance a Form to a Modal Form</a></p>
  <p><a href="http://www.tuttoaster.com/create-an-ajaxjqueryphp-contact-form/">Create an AJAX/jQuery/PHP Contact Form</a></p>
  <p><a href="http://www.csskarma.com/blog/sliding-labels-v2/">Sliding labels on form</a></p>

  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/14-helpful-jquery-tricks-notes-and-best-practices/">14 Helpful jQuery Tricks, Notes, and Best Practices</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/uncovering-jquerys-hidden-features/">Uncovering jQuery’s Hidden Features</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-think-right-to-left-with-jquery/">Quick Tip: Think Right-to-Left with jQuery</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/spotlight-jquery-replacetext/">jQuery replaceText</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/jquery-1-4-released-the-15-new-features-you-must-know/">jQuery 1.4 Released: The 15 New Features you Must Know</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/jquery-animations-a-7-step-program/">jQuery Animations: A 7-Step Program</a></p>
  <p><a href="http://www.gmtaz.com/jquery-13-cheatsheet-wallpaper/">CheatSheet</a></p>
  <p><a href="http://webdesigneraid.com/8-great-websites-to-learn-step-by-step-jquery/">8 Great Websites to Learn Step-by-Step jQuery</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/using-jquery-to-manipulate-and-filter-data/">Using jQuery To Manipulate and Filter Data</a></p>
  <p><a href="http://www.jankoatwarpspeed.com/post/2008/06/09/Building-a-better-web-forms-Context-highlighting-using-jQuery.aspx">Building better web forms: Context highlighting using jQuery</a></p>

  <h3 id="Frameworks_jQuery_toJS">From jQuery to JS</h3>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/from-jquery-to-javascript-a-reference/">From jQuery to JavaScript: A Reference</a></p>

  <h3 id="Frameworks_jQuery_UI">jQuery UI</h3>
  <div class="refs">
    <ul>
      <li><a href="http://jqueryui.com/">jQuery UI</a></li>
    </ul>
  </div>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/whats-changed-in-jquery-ui-1-8-plus-free-books/">What’s Changed in jQuery UI 1.8</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/coding-your-first-jquery-ui-plugin/">Coding your First jQuery UI Plugin</a></p>
  <p><a href="https://courses.tutsplus.com/courses/jquery-ui-101-the-essentials">jQuery UI 101: The Essentials</a></p>

  <h3 id="Frameworks_jQuery_Plugins">Дадаткі і бібліятэкі</h3>
  <div class="refs">
    <ul>
      <li><a href="http://plugins.jquery.com/">Home</a></li>
    </ul>
  </div>
  <p><a href="http://jquerycards.com/">A repository of over 1000 quality jQuery plugins</a></p>
  <p><a href="http://www.tuttoaster.com/41-remarkable-and-useful-jquery-plugins/">41 Remarkable and useful jQuery Plugins</a></p>
  <p><a href="http://www.jquery4u.com/plugins/">Popular jQuery Plugins</a></p>
  <p><a href="http://www.jquery4u.com/plugins/jquery-plugins-2010/">Best jQuery Plugins for 2010</a></p>
  <p><a href="http://speckyboy.com/2010/03/01/25-amazing-and-fresh-jquery-plugins/">25 Amazing and Fresh jQuery Plugins</a></p>
  <p><a href="http://webdesigneraid.com/15-best-of-the-best-jquery-plugins-in-2010/">15 Best of the best jQuery Plugins in 2010</a></p>
  <p><a href="http://webdesignledger.com/resources/best-jquery-plugins-of-2010">Best jQuery Plugins of 2010</a></p>
  <p><a href="http://webdesignledger.com/resources/10-useful-jquery-plugins">10 Useful jQuery Plugins</a></p>
  <p><a href="http://webdesignledger.com/resources/10-useful-jquery-plugins-and-techniques">10 Useful jQuery Plugins and Techniques</a></p>
  <p><a href="http://malsup.com/jquery/block/#overview" title="BlockUI">BlockUI</a></p>
  <p><a href="https://github.com/danbentley/placeholder" title="placeholder">Placeholder</a></p>
  <p><a href="http://flowplayer.org/tools/index.html" title="placeholder">jQuery Tools</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/enhancing-web-apps-with-amplifyjs/" title="amplify.js">Enhancing Web Apps with AmplifyJS</a></p>
  <p><a href="http://www.kalyani.com/2010/10/subway-map-visualization-jquery-plugin/">SubWay map plugin.</a></p>
  <p><a href="http://bassistance.de/jquery-plugins/">jQuery plugins</a></p>
  <p><a href="http://chico-ui.com.ar/">Chico UI</a></p>
  <p><a href="http://mjsarfatti.com/sandbox/nestedSortable/">nestedSortable jQuery Plugin</a></p>
  <p><a href="http://farhadi.ir/projects/html5sortable/">HTML5 Sortable</a> - jQuery plugin to create sortable lists and grids using native HTML5 drag and drop API</p>

  <h4 id="Frameworks_jQuery_Plugins_Forms">Формы</h4>
  <p><a href="http://www.tripwiremagazine.com/2010/01/75-top-jquery-plugins-to-improve-your-html-forms.html">75+ Top jQuery Plugins to improve Your HTML Forms</a></p>
  <p><a href="http://www.designyourway.net/blog/resources/55-jquery-form-plugins-to-download-and-use/">55 jQuery Form Plugins To Download And Use</a></p>

  <h4 id="Frameworks_jQuery_Plugins_SelectField">Элемэнт <code class="elem">select</code></h4>
  <p><a href="http://abeautifulsite.net/blog/2011/01/jquery-selectbox-plugin/">SelectBox Plugin</a></p>
  <p><a href="http://ivaynberg.github.com/select2/">Select2 Plugin</a></p>
  <p><a href="http://jamielottering.github.com/DropKick/">DropKick</a>&nbsp;&ndash; painless custom dropdowns</p>

  <h4 id="Frameworks_jQuery_Plugins_TextField">Тэкставыя палі</h4>
  <p><a href="http://www.scriptiny.com/2012/09/jquery-input-textarea-limiter/">Input &amp; Textarea Character Limit Display with jQuery</a></p>

  <h4 id="Frameworks_jQuery_Plugins_Tables">Табліцы</h4>
  <p><a href="http://www.picnet.com.au/picnet_table_filter.html">Picnet table filter</a></p>
  <p><a href="http://www.datatables.net">DataTables</a></p>
  <p><a href="http://filamentgroup.com/lab/responsive_design_approach_for_complex_multicolumn_data_tables/">A Responsive Design Approach for Complex, Multicolumn Data Tables</a></p>
  <p><a href="http://warpech.github.com/jquery-handsontable/index.html">Excel-like table editor in HTML &amp; jQuery</a></p>

  <h4 id="Frameworks_jQuery_Plugins_Images">Выявы, слайды, буклеты</h4>
  <p><a href="http://buildinternet.com/project/supersized/">supersized</a>&nbsp;&ndash; fullscreen background slideshow ад <a href="http://buildinternet.com">BuildInternet.com</a></p>
  <p><a href="http://buildinternet.com/project/mosaic/">mosaic</a>&nbsp;&ndash; sliding boxes and captions ад <a href="http://buildinternet.com">BuildInternet.com</a></p>
  <p><a href="http://buildinternet.com/project/totem/">totem</a>&nbsp;&ndash; animated vertical ticker ад <a href="http://buildinternet.com">BuildInternet.com</a></p>
  <p><a href="https://github.com/buildinternet/thumbreel">thumbreel</a>&nbsp;&ndash; fluid thumbnail bar ад <a href="http://buildinternet.com">BuildInternet.com</a></p>
  <p><a href="http://tympanus.net/codrops/2012/09/03/bookblock-a-content-flip-plugin/">BookBlock</a>&nbsp;&ndash; a content flip plugin</p>

  <h4 id="Frameworks_jQuery_Plugins_Pagination">Пастаронкавая навігацыя</h4>
  <div class="refs">
    <ul>
      <li><a href="https://github.com/remylab/jPaginator/">jPaginator</a></li>
      <li><a href="http://webdesign.tutsplus.com/tutorials/htmlcss-tutorials/extreme-makeover-jpaginator-css3-edition/">Tutorial</a></li>
    </ul>
  </div>
  <p><img src="{{ base_path }}/assets/images/jPaginator.png" alt="jPaginator screenshot" title="jPaginator screenshot" /></p>

  <h4 id="Frameworks_jQuery_Plugins_ProgressiveLoad">Адкладзеная загрузка</h4>
  <p><a href="http://imakewebthings.github.com/jquery-waypoints/">Waypoints</a>&nbsp;&ndash; унівэрсальны <i>jQuery</i>-дадатак, які дазваляе прычапляць апрацоўшчыкі падзеі, калі пэўны элемэнт старонкі трапляе ці наадварот зьнікае з экрану пры скролінгу. Гэта дазваляе рабіць ня толькі адкладзеную загрузку зьместу старонкі па патрэбе, але і шмат чаго іншага. На старонцы дадатку прыведзеныя варыянты магчымага выкарыстаньня, а таксама апісаньне.</p>
  <p>Іншыя дадаткі адкладзенай загрузкі зьместу старонкі: <a href="http://designbeep.com/2011/08/12/12-jquery-infinite-scrollingscroll-read-plugins-for-content-navigation/">12 jQuery Infinite Scrolling(scroll &amp; read) Plugins for Content Navigation</a>.</p>

  <h4 id="Frameworks_jQuery_Plugins_Time">Час</h4>
  <p><a href="http://pragmaticly.github.com/smart-time-ago/">Smart Time Ago</a>&nbsp;&ndash; дадатак, які аўтаматычна вызначае колькі часу прайшло з пазначанай даты, выводзіць гэтую інфармацыю ў элемэнт старонкі і абнаўляе яе з пазначанай пэрыядычнасьцю.</p>

  <h4 id="Frameworks_jQuery_Plugins_Money">Лікі, грошы, валюты</h4>
  <p><a href="http://www.egrappler.com/jquery-credit-card-validation-plugin-smart-validate/">Credit card validation plugin.</a></p>
  <p><a href="http://paweldecowski.github.com/jQuery-CreditCardValidator/">jQuery Credit Card Validator.</a></p>

  <h4 id="Frameworks_jQuery_Plugins_KeyboardShortcuts">Клавішныя скароты</h4>
  <p><a href="http://code.google.com/p/js-hotkeys/">js-hotkeys</a></p>
  <p><a href="https://github.com/madrobby/keymaster">keymaster</a></p>
  <p><a href="http://oscargodson.com/labs/jkey/">jKey</a></p>

  <h4 id="Frameworks_jQuery_Plugins_Tooltips">Падказкі</h4>
  <p><a href="http://www.1stwebdesigner.com/css/stylish-jquery-tooltip-plugins-webdesign/">30 Stylish jQuery Tooltip Plugins For Catchy Designs</a></p>
  <p><a href="http://visionwidget.com/inspiration/web/495-jquery-tooltip-plugins.html">20 Examples of jQuery Tooltip Plugins</a></p>
  <p><a href="http://bassistance.de/jquery-plugins/jquery-plugin-tooltip/">jQuery plugin: Tooltip</a></p>
  <p><a href="http://www.websovet.com/jquery-dlya-chajnikov-vsplyvayushhaya-podskazka-plagin-tooltip">jQuery для чайников | Всплывающая подсказка | Плагин Tooltip</a></p>
  <p><a href="http://ipicture.justmybit.com/">iPicture - Tooltip your images</a></p>

  <h2 id="Frameworks_Zepto">Zepto.js</h2>
  <div class="refs">
    <ul>
      <li><a href="http://zeptojs.com/">Zepto.js</a></li>
    </ul>
  </div>
  <p>Мінімалістычны аналяг <i>jQuery</i> (амаль ідэнтычны API) з падтрымкай толькі сучасных браўзэраў.</p>

  <h2 id="Frameworks_ExpandJS">ExpandJS</h2>
  <div class="refs">
    <ul>
      <li><a href="http://expandjs.com/">ExpandJS</a></li>
    </ul>
  </div>
  <p>Modular library with 100+ custom elements and 350+ utility functions to kickstart your Web Applications.</p>

</section>

<section>
  <h1 id="Technology">Тэхналёгіі</h1>

  <h2 id="Technology_AJAX">AJAX</h2>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/24-best-practices-for-ajax-implementations/">24 Best Practices for AJAX Implementations</a></p>
  <p><a href="http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-cross-domain-ajax-request-with-yql-and-jquery/">Cross Domain AJAX Request with YQL and jQuery</a></p>
  <p>AJAX-падзеі:</p>
  <ul>
    <li>ajax:before – right before ajax call</li>
    <li>ajax:loading – before ajax call, but after XmlHttpRequest object is created)</li>
    <li>ajax:success – successful ajax call</li>
    <li>ajax:failure – failed ajax call</li>
    <li>ajax:complete – completion of ajax call (after ajax:success and ajax:failure)</li>
    <li>ajax:after – after ajax call is sent (note: not after it returns)</li>
  </ul>

  <h2 id="Technology_JSON">JSON</h2>
  <p><a href="http://www.copterlabs.com/blog/json-what-it-is-how-it-works-how-to-use-it/">JSON: What It Is, How It Works, and How to Use It</a></p>

</section>

<section>
  <h1 id="Tools">Прылады</h1>
  <h2 id="Tools_Compression">Сьцісканьне скрыптоў</h2>
  <div class="refs">
    <ul>
      <li><a href="https://github.com/google/closure-compiler">Google Closure Compiler</a></li>
      <li><a href="http://javascriptcompressor.com/">JavaScript Compressor</a></li>
      <li><a href="http://www.xmlforasp.net/JSCompressor.aspx">JSCompressor</a></li>
      <li><a href="http://jscompress.com/">JSCompress</a></li>
      <li><a href="http://www.danstools.com/javascript-minify/">Javascript Minifier</a></li>
    </ul>
  </div>

  <h2 id="Tools_GoodPractices">Добрая практыка</h2>
  <div class="refs">
    <ul>
      <li><a href="http://jslint.com/">JSLint</a></li>
    </ul>
  </div>
  <p>Прылада правярае ці адпавядае напісаны вамі скрыпт пэўным крытэрам «добрай практыкі».</p>
  <p><a href="http://www.jshint.com/">JSHint</a>&nbsp;&ndash; прыкладна тое ж самае.</p>

  <h2 id="Tools_EventKeyCodes">Event KeyCodes</h2>
  <p><a href="http://keycode.info/">Прасьцейшая праграма, якая проста выводзіць коды націснутых клявіш</a>.</p>
</section>
