---
title: Разгортваньне праграм у працоўным асяродку
description: Разгортваньне праграм у працоўным асяродку
disqus_shortname: deploy-be
---

<section>
  <h1 id="Docker">Docker</h1>
  <div class="refs">
    <ul>
      <li><a href="https://www.docker.com/">Home</a></li>
      <li><a href="https://docs.docker.com/">Docs</a></li>
      <li><a href="https://hub.docker.com/">Hub</a></li>
      <li><a href="https://cloud.docker.com/app/">Cloud</a></li>
    </ul>
  </div>
  <p><a href="https://www.youtube.com/watch?v=aSATsLG59Zs">Arun Gupta "Docker and Kubernetes Recipes for Java Developers" 11.11.2015</a></p>
  <p><a href="https://www.youtube.com/watch?v=ZNdc4-yFTeA">Arun Gupta "Docker for Java Developers" 22.09.2016</a></p>

  <p><a href="http://merrigrove.blogspot.co.uk/2015/10/visualizing-docker-containers-and-images.html?_tmc=Diy2bNEQqG5t8sSbcMW6T5Us4KCmgsInjBviObh0atg&mkt_tok=3RkMMJWWfF9wsRonuqTMZKXonjHpfsX57u4lX6G2lMI%2F0ER3fOvrPUfGjI4AS8VqI%2BSLDwEYGJlv6SgFQ7LMMaZq1rgMXBk%3D">Visualizing Docker Containers and Images</a></p>
  <p><a href="http://blog.xebia.com/2015/08/31/making-amazon-ecs-container-service-as-easy-to-use-as-docker-run/?mkt_tok=3RkMMJWWfF9wsRonuqTMZKXonjHpfsX57u4lX6G2lMI%2F0ER3fOvrPUfGjI4ASMRhI%2BSLDwEYGJlv6SgFQ7LMMaZq1rgMXBk%3D">Making Amazon ECS Container Service As Easy To Use As Docker Run</a></p>
  <br />
  <p><a href="http://www.javacodegeeks.com/2015/11/10-awesome-docker-tutorials-to-kick-start-your-devops-projects.html">10 Awesome Docker Tutorials to Kick-Start your DevOps Projects</a></p>
  <br />
  <br />
  <br />
  <p><a href="https://www.digitalocean.com/community/tutorials/how-to-work-with-docker-data-volumes-on-ubuntu-14-04">How To Work with Docker Data Volumes on Ubuntu 14.04</a></p>
  <p><a href="https://docs.docker.com/engine/admin/">Configuring and running Docker on various distributions</a></p>
  <p><a href="https://docs.docker.com/engine/reference/commandline/dockerd/">daemon</a></p>
  <p><a href="https://docs.docker.com/docker-cloud/installing-cli/">The Docker Cloud CLI</a></p>
  <p><a href="https://docs.docker.com/docker-cloud/infrastructure/byoh/">Use the Docker Cloud Agent</a></p>



  <h2 id="Docker_Install">Усталяваньне</h2>
  <div class="refs">
    <ul>
      <li><a href="https://docs.docker.com/engine/installation/linux/ubuntulinux/">How-To</a></li>
      <li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-16-04">How-To</a></li>
    </ul>
  </div>
  <p><i>Docker</i> патрабуе 64-бітнай вэрсіі <i>Ubuntu</i> (альбо яе клона), а таксама вэрсіі <i>kernel</i> не ніжэй за 3.10. Каб праверыць вэрсію <i>kernel</i>, скарыстайцеся камандай:</p>

  <pre><code class="language-bash">
$ uname -r
4.4.0-21-generic
</code></pre>

  <p>Абнаўляем базу даных <i>apt-get</i> і ўсталёўваем неабходныя пакеты:</p>

  <pre><code class="language-bash">
$ sudo apt-get update
$ sudo apt-get install apt-transport-https ca-certificates
</code></pre>

  <p>Дадаем у сыстэму <i>GPG</i>-ключ да афіцыйнага рэпазыторыю <i>Docker</i>:</p>

  <pre><code class="language-bash">
$ sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
</code></pre>

  <p>Далей трэба дадаць рэпазыторый <i>Docker</i> да крыніц <i>apt-get</i>, дзе <code>&lt;REPO&gt;</code> трэба будзе замяніць спасылкай у адпаведнасьці з вэрсіяй ОС (глядзі ніжэй):</p>

  <pre><code class="language-bash">
echo "deb &lt;REPO&gt; main" | sudo tee /etc/apt/sources.list.d/docker.list
</code></pre>

  <table>
    <thead>
    <tr>
      <th>Вэрсія Ubuntu</th>
      <th>Спасылка да крыніцы</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>Precise 12.04 (LTS)</td>
      <td><code>https://apt.dockerproject.org/repo ubuntu-precise</code></td>
    </tr>
    <tr>
      <td>Trusty 14.04 (LTS)</td>
      <td><code>https://apt.dockerproject.org/repo ubuntu-trusty</code></td>
    </tr>
    <tr>
      <td>Xenial 16.04 (LTS)</td>
      <td><code>https://apt.dockerproject.org/repo ubuntu-xenial</code></td>
    </tr>
    </tbody>
  </table>

  <p>Ізноў абнаўляем базу даных <i>apt-get</i>:</p>

  <pre><code class="language-bash">
$ sudo apt-get update
</code></pre>

  <p>Яшчэ раз пераконваемся, што зьбіраемся зрабіць ўсталёўку з рэпазыторыю <i>Docker</i>, а не <i>Ubuntu</i>:</p>

  <pre><code class="language-bash">
$ apt-cache policy docker-engine
docker-engine:
  Installed: (none)
  Candidate: 1.12.2-0~xenial
  Version table:
 *** 1.12.2-0~xenial 500
        500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages
     1.12.1-0~xenial 500
        500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages
     1.12.0-0~xenial 500
        500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages
     1.11.2-0~xenial 500
        500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages
     1.11.1-0~xenial 500
        500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages
     1.11.0-0~xenial 500
        500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages
</code></pre>

  <p>І напрыканцы ўсталёўваем <i>Docker</i>:</p>

  <pre><code class="language-bash">
$ sudo apt-get install docker-engine
</code></pre>

  <p>У выніку павінен усталявацца <i>Docker</i>, запусьціцца сэрвіс, а таксама будзе прапісана каманда яго аўтастарту пры загрузцы сыстэмы. Каб пераканацца што сэрвіс запушчаны:</p>

  <pre data-line="3"><code class="language-bash">
$ sudo systemctl status docker
● docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)
   Active: active (running) since Thu 2016-10-20 09:24:30 +03; 10h ago
     Docs: https://docs.docker.com
 Main PID: 1154 (dockerd)
</code></pre>

  <h3 id="Docker_Install_InvokeServiceWithoutSudo">Выкананьне без <code>sudo</code></h3>
  <p><i>docker</i>-сэрвіс працуе праз <i>Unix-socket</i>, якім валодае <i>root</i>-карыстальнік, таму астатнія карыстальнікі могуць выконваць каманду <code>docker</code> толькі праз каманду адміністраваньня сыстэмы <code>sudo</code>. Для зручнасьці можна пазбавіцца ад такой неабходнасьці, для гэтага трэба дадаць карыстальніка пад якім вы працуеце ў <code>docker</code>-групу:</p>

  <pre><code class="language-bash">
$ sudo usermod -G docker -a $(whoami)
</code></pre>

  <h2 id="Docker_Commands">Каманды</h2>
  <p>У агульным выпадку каманда <i>docker</i>-сэрвісу выконваецца наступным чынам:</p>

  <pre><code class="language-bash">
$ docker [option] [command] [arguments]
</code></pre>

  <p>Вывесьці сьпіс усіх даступных каманд можна набраўшы каманду <code class="language-bash">docker</code>:</p>

  <pre><code class="language-bash">
$ docker
Usage: docker [OPTIONS] COMMAND [arg...]
       docker [ --help | -v | --version ]

...
</code></pre>

  <p>Ніжэй прыведзена апісаньне некаторых з камандаў (<i>усюды, дзе ў камандах пазначаюцца імёны вобразаў ці кантэйнэраў, могуць выкарыстоўвацца іх ID):</i></p>
  <table>
    <thead>
    <tr>
      <th style="width: 220px;">Каманда</th>
      <th>Апісаньне</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code class="language-bash">docker images</code></td>
      <td>Выводзіць сьпіс асноўных вобразаў, якія раней былі сьцягнутыя ў сыстэму</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker images -a</code></td>
      <td>Выводзіць сьпіс усіх (у тым ліку прамежкавых) вобразаў, якія раней былі сьцягнутыя ў сыстэму</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker pull &lt;IMAGE&gt;</code></td>
      <td>Сьцягвае вобраз з рэгістру ў сыстэму</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker push &lt;IMAGE&gt;</code></td>
      <td>Закідвае вобраз з сыстэмы ў рэгістар</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker rmi &lt;IMAGE&gt;</code></td>
      <td>Выдаляе вобраз з сыстэмы</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker ps</code></td>
      <td>Выводзіць сьпіс працуючых кантэйнэраў</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker ps -a</code></td>
      <td>Выводзіць сьпіс усіх, у тым ліку непрацуючых кантэйнэраў</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker create &lt;IMAGE&gt;</code></td>
      <td>Стварае кантэйнэр з вобразу</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker run &lt;IMAGE&gt; [&lt;COMMAND&gt;]</code></td>
      <td>Стварае і запускае новы кантэйнэр з пазначанага вобразу і (неабавязкова) запускае ў ім пэўную каманду</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker start &lt;CONTAINER&gt;</code></td>
      <td>Запускае кантэйнэр</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker logs &lt;CONTAINER&gt;</code></td>
      <td>Выводзіць лог кантэйнэра</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker port &lt;CONTAINER&gt;</code></td>
      <td>Выводзіць сьпіс мапінгу партоў кантэйнэра</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker top &lt;CONTAINER&gt;</code></td>
      <td>Выводзіць сьпіс працуючых працэсаў кантэйнэра</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker stop &lt;CONTAINER&gt;</code></td>
      <td>Спыняе кантэйнэр</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker restart &lt;CONTAINER&gt;</code></td>
      <td>Спыняе і па новай стартуе кантэйнэр</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker kill &lt;CONTAINER&gt;</code></td>
      <td>Прыбівае кантэйнэр</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker commit &lt;CONTAINER&gt;</code></td>
      <td>Стварае новы вобраз з кантэйнэру, уключаючы ўсе зьмены, якія былі ў ім зроблены пасьля старту</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker network</code></td>
      <td>Кіраваньне сеткай докера<br>
        <code class="language-bash">docker network inspect bridge</code>&nbsp;&ndash; выведзе падрабязную інфармацыю пра сетку <code class="language-bash">bridge</code>
      </td>
    </tr>
    <tr>
      <td><code class="language-bash">docker node</code></td>
      <td>Кіраваньне вузламі клястэру.</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker volume</code></td>
      <td>Кіраваньне тамамі даных.</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker login</code></td>
      <td>Уваход у рэгістар.</td>
    </tr>
    <tr>
      <td><code class="language-bash">docker logout</code></td>
      <td>Выхад з рэгістру.</td>
    </tr>
    </tbody>
  </table>

  <h2 id="Docker_Images">Вобразы</h2>
  <p><i>docker</i>-кантэйнэры запускаюцца з вобразаў, якія захоўваюцца ў лякальнай сыстэме альбо ў рэгістры (прыватным альбо публічным як <i>Docker Hub</i>). Каб праглядзець, якія вобразы ўжо захоўваюцца лякальна, можна скарыстацца камандай:</p>

  <pre><code class="language-bash">
$ docker images

REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              c54a2cc56cbb        3 months ago        1.848 kB
</code></pre>

  <h3 id="Docker_Images_Search">Пошук вобразаў</h3>
  <p>Шукаць даступныя вобразы можна пры дапамозе каманды <code class="language-bash">docker search</code>:</p>

  <pre><code class="language-bash">
$ docker search ubuntu

NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
ubuntu                            Ubuntu is a Debian-based Linux operating s...   4903      [OK]
ubuntu-upstart                    Upstart is an event-based replacement for ...   67        [OK]
rastasheep/ubuntu-sshd            Dockerized SSH service, built on top of of...   45                   [OK]
ubuntu-debootstrap                debootstrap --variant=minbase --components...   28        [OK]
    &hellip;
    smartentry/ubuntu                 ubuntu with smartentry                          0                    [OK]
teamrock/ubuntu                   TeamRock's Ubuntu image configured with AW...   0                    [OK]
</code></pre>

  <p><i>OK</i> у калёнцы <i>OFFICIAL</i> азначае, што вобраз зроблены і падтрымліваецца кампаніяй, якая "валодае" альбо стаіць за праектам.</p>

  <h3 id="Docker_Images_Pull">Сьцягваньне вобразаў</h3>
  <p>Каб сьцягнуць вобраз з рэгістру ў лякальную сыстэму без яго запуску, трэба скарыстацца камандай:</p>

  <pre><code class="language-bash">
$ docker pull ubuntu
</code></pre>

  <h3 id="Docker_Images_Start">Запуск кантэйнэра з вобразу</h3>
  <p>Каманда <code class="language-bash">docker run</code> запускае кантэйнэр з пэўнага вобразу. Калі такога вобразу яшчэ няма на лякальнай машыне, ён будзе спачатку сьцягнуты з рэгістру і потым застартаваны (парамэтры <code class="language-bash">-i</code> і <code class="language-bash">-t</code> дазваляюць атрымаць доступ да інтэрактыўнай кансолі працуючага кантэйнэру):</p>

  <pre><code class="language-bash">
$ docker run -it ubuntu
Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu
    &hellip;
    Digest: sha256:2d44ae143feeb36f4c898d32ed2ab2dffeb3a573d2d8928646dfc9cb7deb1315
Status: Downloaded newer image for ubuntu:latest
root@504d5f9b2c66:/#
</code></pre>

  <p>Камандны радок павінен будзе зьмяніцца, адлюстроўваючы той факт, што зараз кансоль не вашага кампутара, але кантэйнэра (сымбальна-лікавы ID пасьля <code>root@</code>&nbsp;&ndash; гэта <i>ID</i> кантэйнэра):</p>

  <pre><code class="language-bash">
root@504d5f9b2c66:/#
</code></pre>

  <h3 id="Docker_Images_Change">Унёсак зьменаў у працуючы кантэйнэр</h3>
  <p>Можна ўнесьці зьмены ў працуючы кантэйнэр (у параўнаньні з вобразам, зь якога ён быў застартаваны), напрыклад аднавіць базу даных <i>apt-get</i> <i>Ubuntu</i>:</p>

  <pre><code class="language-bash">
root@504d5f9b2c66:/# apt-get update
Get:1 http://archive.ubuntu.com/ubuntu xenial InRelease [247 kB]
Get:2 http://archive.ubuntu.com/ubuntu xenial-updates InRelease [95.7 kB]
    &hellip;
    Fetched 24.4 MB in 28s (854 kB/s)
Reading package lists... Done
root@504d5f9b2c66:/#
</code></pre>

  <p>І ўсталяваць <i>NodeJS</i>:</p>

  <pre><code class="language-bash">
root@504d5f9b2c66:/# apt-get install -y nodejs
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  libicu55 libssl1.0.0 libuv1
The following NEW packages will be installed:
  libicu55 libssl1.0.0 libuv1 nodejs
    &hellip;
    update-alternatives: using /usr/bin/nodejs to provide /usr/bin/js (js) in auto mode
Processing triggers for libc-bin (2.23-0ubuntu3) ...
</code></pre>

  <p>Файлавая сыстэма докера часовая па-змоўчваньні. Калі застартаваць пэўны вобраз, ўнесьці нейкія зьмены ў сыстэму кантэйнэра, спыніць яго і зноў застартаваць той жа самы вобраз, усе зьмены, якія былі зроблены на папярэднім кроку, будуць згубленыя. У сувязі з гэтым вобразы докера&nbsp;&ndash; гэта больш шаблёны, чым звыклыя нам вобразы віртуальных машын. Таму ўсталяваўшы <i>NodeJS</i> у кантэйнэр у папярэднім прыкладзе, мы будзем мець кантэйнэр, які адрозьніваецца ад свайго вобразу. Гэты стан можна захаваць у новы вобраз. Для гэтага трэба выйсьці зь яго:</p>

  <pre><code class="language-bash">
root@504d5f9b2c66:/# exit
</code></pre>

  <p>І захаваць зьмены ў новы вобраз:</p>

  <pre><code class="language-bash">
$ docker commit -m "What did you do to the image" -a "Author Name" container-id repository/new_image_name
</code></pre>

  <p>Дзе:</p>
  <ul>
    <li><code>container-id</code>&nbsp;&ndash; гэта <i>ID</i> кантэйнэра, на які мы зьвярталі ўвагу вышэй;</li>
    <li><code>repository</code>&nbsp;&ndash; гэта імя вашага уліковага запісу альбо рэпазыторыю ў <i>Docker Hub</i>;</li>
    <li><code>new_image_name</code>&nbsp;&ndash; гэта імя новага вобразу;</li>
  </ul>
  <p>Напрыклад:</p>

  <pre><code class="language-bash">
$ docker commit -m "added node.js" -a "Yurtsevich" 504d5f9b2c66 yurtsevich/ubuntu-with-nodejs
</code></pre>

  <p>Можна пераканацца, што вобраз сапраўды быў захаваны:</p>

  <pre><code class="language-bash">
$ docker images
REPOSITORY                      TAG                 IMAGE ID            CREATED              SIZE
yurtsevich/ubuntu-with-nodejs   latest              f9c99a5f7a94        3 seconds ago        215.3 MB
ubuntu                          latest              f753707788c5        8 days ago           127.2 MB
hello-world                     latest              c54a2cc56cbb        3 months ago         1.848 kB
</code></pre>

  <p>Розьніца ў памеры паміж вобразамі <code>ubuntu</code> і <code>yurtsevich/ubuntu-with-nodejs</code> пазначае аднаўленьне базы даных <i>apt-get</i> і ўсталяваньне <i>NodeJS</i> у кантэйнэры, які мы запусьцілі з вобразу <code>ubuntu</code>. Але трэба памятаць што вобраз пакуль што захаваны толькі лякальна.</p>

  <h3 id="Docker_Images_Push">Закід вобразаў</h3>
  <p>Каб закінуць у рэгістар захаваны лякальна вобраз, трэба спачатку ўвайсьці на <i>Docker Hub</i>:</p>

  <pre><code class="language-bash">
$ docker login -u yurtsevich
Password:
Login Succeeded
</code></pre>

  <p>А потым скарыстацца камандай закіду:</p>

  <pre><code class="language-bash">
$ docker push yurtsevich/ubuntu-with-nodejs
The push refers to a repository [docker.io/yurtsevich/ubuntu-with-nodejs]
874ba904c09a: Pushed
...
latest: digest: sha256:f64b0d5b7bf099e4f50e1f7bb8bdeb668ab0adff605c76d903c72b7844c1cadb size: 1569
</code></pre>

  <h2 id="Docker_Dockerfile">Dockerfile</h2>
  <div class="refs">
    <ul>
      <li><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">Best practices</a></li>
      <li><a href="https://docs.docker.com/engine/reference/builder/">Reference</a></li>
    </ul>
  </div>
  <p>Ствараць вобразы можна не інтэрактыўна праз камандны радок, а пры дапамозе адмысловага скрыпту, які павінен захоўвацца ў файле <code class="language-bash">Dockerfile</code>.</p>

  <h3 id="Docker_Dockerfile_Wildfly">Wildfly</h3>
  <p><a href="https://hub.docker.com/r/jboss/wildfly/~/dockerfile/">https://hub.docker.com/r/jboss/wildfly/~/dockerfile/</a></p>
  <p><a href="https://github.com/jboss-dockerfiles/wildfly">https://github.com/jboss-dockerfiles/wildfly</a></p>
  <p><a href="https://github.com/jboss-dockerfiles/keycloak">https://github.com/jboss-dockerfiles/keycloak</a></p>
  <p><a href="https://goldmann.pl/blog/2014/07/18/logging-with-the-wildfly-docker-image/">https://goldmann.pl/blog/2014/07/18/logging-with-the-wildfly-docker-image/</a></p>

  <h3 id="Docker_Dockerfile_PostgreSQL">PostgreSQL</h3>
  <p><a href="https://hub.docker.com/_/postgres/">postgres</a></p>
  <p><a href="https://docs.docker.com/engine/examples/postgresql_service/">Dockerize PostgreSQL</a></p>
  <p><a href="https://hub.docker.com/r/gsengun/flyway-postgres/">flyway-postgres</a></p>
  <p><a href="https://hub.docker.com/r/dhoer/flyway/">Docker Flyway</a></p>


  <h2 id="Docker_Containers">Кантэйнэры</h2>
  <p>Праглядзець сьпіс усіх актыўных кантэйнэраў можна камандай:</p>

  <pre><code class="language-bash">
$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
504d5f9b2c66        ubuntu              "/bin/bash"         8 minutes ago       Up 8 minutes                            pedantic_carson
</code></pre>

  <p>А сьпіс усіх, актыўных і неактыўных, кантэйнэраў:</p>

  <pre><code class="language-bash">
$ docker ps -a
</code></pre>

  <p>Праглядзець апошні створаны кантэйнэр:</p>

  <pre><code class="language-bash">
$ docker ps -l
</code></pre>

  <p>Спыніць працуючы кантэйнэр можна камандай:</p>

  <pre><code class="language-bash">
$ docker stop container-id
</code></pre>

  <h2 id="Docker_Network">Сетка</h2>
  <div class="refs">
    <ul>
      <li><a href="https://docs.docker.com/engine/tutorials/networkingcontainers/">Networking containers</a></li>
    </ul>
  </div>

  <h2 id="Docker_Volumes">Тамы даных</h2>
  <div class="refs">
    <ul>
      <li><a href="https://docs.docker.com/engine/tutorials/dockervolumes/">Manage data in containers</a></li>
    </ul>
  </div>
  <p><a href="https://flocker-docs.clusterhq.com/en/latest/docker-integration/tutorial-swarm-compose.html">Tutorial: Using Flocker with Docker, Swarm, Compose</a></p>
  <p><a href="https://flocker-docs.clusterhq.com/en/latest/docker-integration/manual-install.html">Manually Installing Flocker with Docker Swarm</a></p>

  <h2 id="Docker_Security">Бясьпека</h2>
  <p><a href="http://blog.contino.io/blog/docker-security-what-you-need-to-know">Docker Security: What You Need to Know</a></p>

  <h2 id="Docker_Logging">Лагіраваньне</h2>
  <div class="refs">
    <ul>
      <li><a href="https://www.elastic.co/products/logstash">LogStash</a></li>
    </ul>
  </div>
  <p><a href="https://technologyconversations.com/2016/10/24/forwarding-logs-from-all-containers-running-anywhere-inside-a-docker-swarm-cluster/">Forwarding Logs From All Containers Running Anywhere Inside A Docker Swarm Cluster</a></p>

  <h2 id="Docker_Machine">Machine</h2>
  <aside>
    <p>Бывае, што ў <i>BIOS</i> кампутара магчымасьць віртуалізацыі заблякаваная на апаратным узроўні. Каб <i>Docker Machine</i> мела магчымасьць запускаць свае віртуальныя машыны, трэба зьняць гэтую блякіроўку.</p>
    <p>Таксама трэба памятаць, што <i>Docker Machine</i> не мае свайго рухавіку віртуалізацыі, але выкарыстоўвае <i>API</i> староньніх сэрвісаў (<i>VirtualBox</i>, <i>VMWare</i> і г.д.), таму для яго працы трэба ўсталяваць у сыстэму хаця б адзін з гэтых сэрвісаў.</p>
  </aside>
  <div class="refs">
    <ul>
      <li><a href="https://www.docker.com/products/docker-machine">Home</a></li>
      <li><a href="https://docs.docker.com/machine/overview/">Docs</a></li>
    </ul>
  </div>
  <p><i>Machine</i>&nbsp;&ndash; гэта служба віртуалізацыі, маніторынгу і кіраваньня докер-хастамі.</p>

  <h3 id="Docker_Machine_Install">Усталяваньне</h3>
  <div class="refs">
    <ul>
      <li><a href="https://docs.docker.com/machine/install-machine/">Docs</a></li>
    </ul>
  </div>
  <p>Каб усталяваць <i>Machine</i> трэба выканаць каманду (пад <i>power-user</i>):</p>

  <pre><code class="language-bash">
$ curl -L https://github.com/docker/machine/releases/download/v0.8.2/docker-machine-`uname -s`-`uname -m` >/usr/local/bin/docker-machine &amp;&amp; \
chmod +x /usr/local/bin/docker-machine
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   600    0   600    0     0    447      0 --:--:--  0:00:01 --:--:--   447
100 23.4M  100 23.4M    0     0  83322      0  0:04:54  0:04:54 --:--:-- 53889
</code></pre>

  <p>А пасьля пераканацца, што ўсталёўка прайшла пасьпяхова:</p>

  <pre><code class="language-bash">
$ docker-machine version
docker-machine version 0.8.2, build e18a919
</code></pre>

  <h2 id="Docker_Swarm">Swarm</h2>
  <div class="refs">
    <ul>
      <li><a href="https://docs.docker.com/swarm/">Docs</a></li>
    </ul>
  </div>

  <h2 id="Docker_Kubernetes">Kubernetes</h2>
  <div class="refs">
    <ul>
      <li><a href="http://kubernetes.io/">Home</a></li>
    </ul>
  </div>


</section>

<section>
  <h1 id="EC2">EC2</h1>
  <div class="refs">
    <ul>
      <li><a href="http://aws.amazon.com/ec2/">Home</a></li>
      <li><a href="https://console.aws.amazon.com/ec2">Console</a></li>
    </ul>
  </div>
  <p>Перад тым, як стартаваць экзэмпляр сэрвэру, трэба стварыць пару ключоў:</p>
  <p><img src="createKeys.png" width="600px"></p>
  <p>Пры стварэньні пары ключоў сэрвіс Амазона запусьціць запампоўку публічнага ключа, яго трэба захаваць напрыклад у тэчку <code>~/.ec2/</code>  і потым спаслацца на яго пры стварэньні <i>ssh</i>-сэсіі. Пасьля гэтага цісьнем кнопку для старта сэрвэру:</p>
  <p><img src="launchInstance.png" width="600px"></p>
  <p>І выбіраем <i>Amazon Linux</i> са сьпісу магчымых перадвызначаных вобразаў:</p>
  <p><img src="amazonLinux.png" width="600px"></p>
  <p>Пры стварэньні <i>ssh</i>-сэсіі ў якасьці імені карыстальніка трэба ўвесьці <code>ec2-user</code>:</p>
  <p><img src="configureSsh.png" width="1000px"></p>

</section>

<section>
  <h1 id="CI">Continuous Integration</h1>
  <p>Усталёўка <i>Jenkins</i> на <i>Amazon Linux</i> праз <i>SSH</i>-кансоль:</p>
  <ul>
    <li><a href="http://sanketdangi.com/post/62715793234/install-configure-jenkins-on-amazon-linux">http://sanketdangi.com/post/62715793234/install-configure-jenkins-on-amazon-linux</a></li>
    <li><a href="https://www.youtube.com/watch?v=1JSOGJQAhtE">https://www.youtube.com/watch?v=1JSOGJQAhtE</a></li>
  </ul>

  <h2 id="CI_Git">Git</h2>
  <p>Усталёўка <i>Git</i> на <i>Amazon Linux</i> праз <i>SSH</i>-кансоль: <code>sudo yum install git</code></p>

  <h2 id="CI_JDK">JDK</h2>
  <p>Усталёўка <i>JDK</i> на <i>Amazon Linux</i> праз <i>SSH</i>-кансоль: <code>sudo yum install java-devel</code></p>

  <h2 id="CI_Maven">Maven</h2>
  <p>Спачатку сьцягваем пакет усталёўкі:</p>

  <pre><code class="language-bash">
$ wget https://repos.fedorapeople.org/repos/dchen/apache-maven/epel-7/x86_64/apache-maven-3.2.5-1.el7.noarch.rpm
</code></pre>

  <p>А потым запускаем саму ўсталёўку:</p>

  <pre><code class="language-bash">
$ rpm -ivh apache-maven-3.2.5-1.el7.noarch.rpm
</code></pre>
</section>

<section>
  <h1 id="OpenShift" data-content-item-open>OpenShift</h1>
  <div class="refs">
    <ul>
      <li><a href="https://www.openshift.com/">Home</a></li>
      <li><a href="https://openshift.redhat.com/app/console">Web console</a></li>
    </ul>
  </div>
  <p><a href="http://www.first8.nl/blog/vertical-scaling-with-openshift/">VERTICAL SCALING WITH OPENSHIFT</a>.</p>
  <p><a href="http://www.first8.nl/blog/horizontal-scaling-with-open-shift/">HORIZONTAL SCALING WITH OPENSHIFT</a>.</p>
  <p><a href="http://www.first8.nl/blog/managing-multiple-gears-with-open-shift/">MANAGING MULTIPLE GEARS WITH OPEN SHIFT</a>.</p>

  <p><i>OpenShift</i>&nbsp;&ndash; <i>The Open Hybrid Cloud Application Platform by Red Hat</i>, іншымі словамі <i>PaaS</i> для аўтаматычнага разгортваньня праграм на воблачным хостынгу.</p>
  <p>Падтрымлівае мовы:</p>
  <ul>
    <li><i>Java</i> (<i>JBoss AS 7</i>, <i>WildFly 8.2</i>, <i>Tomcat 6/7 via JBoss EWS</i>, <i>JBoss EAP 6.4</i>)</li>
    <li><i>Ruby</i></li>
    <li><i>Node.js</i></li>
    <li><i>Python</i></li>
    <li><i>Perl</i></li>
    <li><i>PHP</i></li>
    <li><i>Ceylon</i></li>
    <li><i>DIY/Custom</i></li>
  </ul>

  <h2 id="OpenShift_ClientTools">Client tools</h2>
  <div class="refs">
    <ul>
      <li><a href="https://developers.openshift.com/en/getting-started-debian-ubuntu.html">Install</a></li>
      <li><a href="https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html-single/User_Guide/index.html">Guide</a></li>
    </ul>
  </div>
  <p>Акрамя <a href="https://openshift.redhat.com/app/console">вэб-кансолі</a> кіраваць праграмай можна праз <i>client tools</i> (<i>rhc</i>)&nbsp;&ndash; кансольную праграму, якая працуе на <i>Ruby</i>.</p>

  <h2 id="OpenShift_CreateApp">Ствараем праграму</h2>

  <pre><code class="language-bash">
$ rhc app-create myapp wildfly
</code></pre>

  <p>Будзе створана загатоўка <i>JEE</i>-праграмы для працы з сэрвэрам <i>WildFly</i> наступнай структуры:</p>
  <pre>
|-- deployments/       Location for built WARs
|-- src/               Maven source structure
|-- pom.xml            Maven build file
`-- .openshift/        Location for OpenShift specific files
   |-- config/         Location for configuration files such as standalone.xml
   |-- action_hooks/   See the Action Hooks documentation
   `-- markers/        See the Markers documentation
</pre>
  <p>Дадаем <i>PostgreSQL</i>:</p>

  <pre><code class="language-bash">
$ rhc cartridge add postgresql-9.2 -a myapp
</code></pre>

  <p>Адлеглыя <i>WildFly</i> і <i>PostgreSQL</i> будуць цалкам наладжаныя на працу. Застаецца наладзіць лякальныя <i>WildFly</i> і <i>PostgreSQL</i>.</p>

  <h2 id="OpenShift_LocalConfig">Наладжваем лякальны асяродак</h2>
  <div class="refs">
    <ul>
      <li><a href="http://www.mastertheboss.com/jboss-server/jboss-datasource/configuring-a-datasource-with-postgresql-and-jboss-wildfly">Link 1</a></li>
      <li><a href="http://www.quizful.net/post/datasource-in-wildfly-jboss-using-postgresql">Link 2</a></li>
      <li><a href="http://devcolibri.com/4661">Link 3</a></li>
    </ul>
  </div>
  <p><a href="https://jdbc.postgresql.org/download.html">Запампоўваем</a> <i>JDBC</i>-драйвэр для <i>PostgreSQL</i> той вэрсіі, якая лякальна ўсталяваная (няхай гэта будзе <code>postgresql-9.1-903.jdbc4.jar</code>), і зьмяшчаем яго ў тэчку <code>/tmp</code>. Далей запускаем кансоль кіраваньня <i>WildFly</i>:</p>

  <pre><code class="language-bash">
/opt/wildfly-8.2.0/bin $ bash jboss-cli.sh
</code></pre>

  <p>І пасьлядоўна наступныя каманды ў самой кансолі (для зручнасьці агляду тут устаўлены пераносы радку, але на самай справе рабіць іх ня трэба):</p>
  <img style="margin-top: 10px;" src="wildfly_postgres.jpg">
  <p>Юзэр <code>_USER_NAME_</code> з паролем <code>_PASSWORD_</code> і экзэмпляр базы <code>_DB_NAME_</code> ужо павінны быць створаныя ў лякальным <i>PostgreSQL</i>.</p>
</section>