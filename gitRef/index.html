<!doctype html>

<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="be-tarask" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
       Remove this if you use the .htaccess -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Даведнік па Git</title>
  <meta name="description" content="Даведнік па Git">
  <meta name="author" content="Юрцэвіч Дзьмітры">

  <!--  Mobile viewport optimized: j.mp/bplateviewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Place favicon.ico & apple-touch-icon.png in the root of your domain and delete these references -->
  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">

  <!-- CSS : implied media="all" -->
  <link rel="stylesheet" href="../css/boilerplate.css?v=2">
  <link rel="stylesheet" href="../css/screen.css?v=1">
  <link rel="stylesheet" href="../css/shCore.css?v=1">
  <link rel="stylesheet" href="../css/shThemeDefault.css?v=1">

  <!-- Uncomment if you are specifically targeting less enabled mobile browsers
  <link rel="stylesheet" media="handheld" href="css/handheld.css?v=2">  -->

  <!-- All JavaScript at the bottom, except for Modernizr which enables HTML5 elements & feature detects -->
  <script src="../js/libs/modernizr-1.6.min.js"></script>

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
</head>

<body>
  <div id="container">
    <article id="content">
      <header>
        Даведнік па Git
      </header>

      <section>
        <h1 id="Links">Карысныя спасылкі</h1>
        <p>Усталёўшчык Git і інструкцыі ўсталяваньня можна атрымаць тут: <a href="http://git-scm.com/download/">http://git-scm.com/download</a></p>
        <p>Афіцыйны навучальны дапаможнік (<strong>пачаткоўцам</strong>): <a href="http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html">http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html</a></p>
        <p>Афіцыйны даведнік (<strong>адмыслоўцам</strong>): <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">http://www.kernel.org/pub/software/scm/git/docs/user-manual.html</a></p>
        <p>Даведнік па камандах: <a href="http://git-scm.com/docs">http://git-scm.com/docs</a></p>
        <p>Шпаргалка па асноўных камандах (у <i>PDF</i>): <a href="https://na1.salesforce.com/help/doc/en/salesforce_git_developer_cheatsheet.pdf">https://na1.salesforce.com/help/doc/en/salesforce_git_developer_cheatsheet.pdf</a></p>
        <p>Інтэрактыўная шпаргалка на <b>OverAPI</b>: <a href="http://overapi.com/git/">http://overapi.com/git/</a></p>
        <p>Вольная электронная кніга «<cite>Pro Git</cite>»: <a href="http://git-scm.com/book/ru">http://git-scm.com/book/ru</a></p>
        <p>Шэраг навучальных дапаможнікаў ад <b>Atlassian</b>: <a href="https://www.atlassian.com/git/">https://www.atlassian.com/git/</a></p>
        <p>Інтэрактыўныя курсы ад <b>CodeSchool</b>: <a href="http://try.github.io/">Try Git</a>, <a href="https://www.codeschool.com/courses/git-real">Git Real</a>, <a href="https://www.codeschool.com/courses/git-real-2">Git Real 2</a></p>
      </section>

      <section>
        <h1 id="Intro">Уводзіны</h1>

        <h2 id="Intro_AboutVersionControl">Пра кантроль вэрсіяў</h2>
        <p>Сыстэма кантролю вэрсіяў&nbsp;(СКВ)&nbsp;&ndash; гэта сыстэма, якая рэгіструе зьмены ў адным ці некалькіх файлах з тым, каб у далейшым можна было вярнуцца да былых вэрсіяў (калі пэўныя зьмены прывялі праект у непрацоўны выгляд і выправіць іх прынамсі хутка не ўяўляецца магчымым; ці калі стала зразумелым, што пэўныя зьмены былі непатрэбныя) альбо проста праглядзець гісторыю зьменаў (напрыклад, высьветліць хто і чаму ўнёс пэўную зьмену ў праграму). Дадзены даведнік будзе разглядаць ужываньне СКВ для коду праграмы, але ў самым агульным выпадку СКВ можна ўжываць для захаваньня зьменаў файлаў любых тыпаў&nbsp;&ndash; дакумэнтаў, выяваў і інш.</p>
        <p>Усе існыя СКВ дзеляцца на наступныя тыпы:</p>

        <h3 id="Intro_AboutVersionControl_Local">Лякальныя сыстэмы</h3>
        <p>Калі зьмены робяцца на адным кампутары і, адпаведна, няма неабходнасьці сынхранізаваць зьмены паміж некалькімі ўдзельнікамі, тады вэрсіі можна захоўваць праз простае капіяваньне тэчак на лякальным кампутары. Звычайна да асноўнага імені тэчкі дадаецца дата і час кожнай зьмены, каб падзяляць іх. Але такі падыход хаця і вырашае асноўную задачу (дазваляе захоўваць гісторыю зьменаў), але робіць гэта не эфэктыўна і не прадухіляе карыстальніка ад элемэнтарных памылак (памылкова ўнесьці зьмены ў файл, які знаходзіцца ня ў той тэчцы; не туды скапіяваць тэчку і перазапісаць пэўную вэрсію, назаўжды згубіўшы яе).</p>
        <p>Таму нават у выпадку лякальнага захаваньня зьменаў варта карыстацца адпаведнымі сродкамі. Напрыклад, стандартная пастаўка <a href="http://www.apple.com/osx/">Mac OS X</a> утрымлівае прыладу <i>rcs</i>, якая апэрыруе патчамі паміж вэрсіямі файла (патч&nbsp;&ndash; гэта розьніца паміж вэрсіямі). Патчы захоўваюцца ў адмысловым фармаце на дыску і дазваляюць аднавіць любую вэрсію файлу зь яго гісторыі зьменаў, пасьлядоўна накладаючы патчы.
          <figure style="text-align: center;">
            <img alt="Схема лякальнай СКВ" title="Схема лякальнай СКВ" src="local_vcs.png"/>
            <figcaption class="imgcaption">Схема лякальнай СКВ</figcaption>
          </figure>
        </p>

        <h3 id="Intro_AboutVersionControl_Centralized">Цэнтралізаваныя сыстэмы</h3>
        <p>Але ж часьцей за ўсё існуе неабходнасьць сынхранізаваць зьмены паміж некалькімі ўдзельнікамі і захаваньне зьменаў на лякальным кампутары зусім не падыходзіць для гэтых мэтаў. Таму наступным крокам на шляху разьвіцьця СКВ стала стварэньне цэнтралізаваных сыстэмаў, пры якіх гісторыя зьменаў захоўваецца на цэнтральным сэрвэры. Адміністратары такіх сыстэмаў маюць магчымасьць наладзіць хто да якой часткі праекту мае доступ. Кіраўнікі праектаў маюць разуменьне хто чым займаецца на праекце.
          <figure style="text-align: center;">
            <img alt="Схема цэнтралізаванай СКВ" title="Схема цэнтралізаванай СКВ" src="central_vcs.png"/>
            <figcaption class="imgcaption">Схема цэнтралізаванай СКВ</figcaption>
          </figure>
        </p>
        <p>Аднак, пры такім падыходзе ёсьць сур'ёзны недахоп (які прысутнічае і ў лякальных сыстэмах)&nbsp;&ndash; гісторыя зьменаў захоўваецца ў адным месцы. Калі ўдзельнік праекту губляе сувязь з гэтым цэнтральным сэрвэрам ці, яшчэ горш, сэрвэр выключаецца (напрыклад на тэхнічнае абслугоўваньне), тады, па-першае ўдзельнік на гэты пэрыяд часу губляе доступ на гісторыі зьменаў, а па-другое, ня можа ўнесьці (захаваць) ў гісторыю свае зьмены. І зусім кепска, калі дыску гэтага сэрвэру, на якім захоўвалася гісторыя зьменаў, здарыцца зламацца. Тады ўся гісторыя зьменаў будзе незваротна згублена, апроч хіба што некалькіх вэрсіяў, якія былі ў якасьці працоўных выцягнутыя ўдзельнікамі на свае лякальныя кампутары.</p>

        <h3 id="Intro_AboutVersionControl_Distributed">Разьмеркаваныя сыстэмы</h3>
        <p>У гэтай сытуацыі ў гульню ўступаюць разьмеркаваныя СКВ. У такіх сыстэмах як <i>Git</i>, <i><a href="http://mercurial.selenic.com/" title="Хатняя старонка Mercurial СКВ">Mercurial</a></i>, <i><a href="http://bazaar.canonical.com/en/" title="Хатняя старонка Bazaar СКВ">Bazaar</a></i> альбо <i><a href="http://darcs.net/" title="Хатняя старонка Darcs СКВ">Darcs</a></i> кліенты ня проста выцягваюць апошнія вэрсіі файлаў, але цалкам капіююць сабе ўвесь рэпазыторый. Таму ў выпадку, калі «памірае» сэрвэр, празь які ішла праца, любы кліенцкі рэпазыторый можа быць скапіяваны назад на сэрвэр, каб аднавіць базу даных.
          <figure style="text-align: center;">
            <img alt="Схема разьмеркаванай СКВ" title="Схема разьмеркаванай СКВ" src="distributed_vcs.png"/>
            <figcaption class="imgcaption">Схема разьмеркаванай СКВ</figcaption>
          </figure>
        </p>
      </section>

      <section>
        <h1 id="Configuration">Наладкі</h1>
        <div class="refs">
          <ul>
            <li><a href="http://git-scm.com/book/ru/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%9F%D0%B5%D1%80%D0%B2%D0%BE%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-Git">ProGit</a></li>
            <li><a href="https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-config">Atlassian</a></li>
          </ul>
        </div>
        <p>Наладкі зьмяняюцца пры выкананьні каманды <code>git config</code> і захоўваюцца ў наступных файлах:
          <ul>
            <li><em><code>&lt;ТЭЧКА_РЭПАЗЫТОРЫЮ&gt;/&lt;ТЭЧКА_GIT&gt;/config</code></em> (звычайна <code>.git/config</code> у корне рэпазыторыю)&nbsp;&mdash; наладкі, спэцыфічныя для гэтага рэпазыторыю;</li>
            <li><em><code>&lt;ХАТНЯЯ_ТЭЧКА_КАРЫСТАЛЬНІКА&gt;/.gitconfig</code></em> (зьмяняюцца пры выкарыстаньні опцыі <code>--global</code>)&nbsp;&mdash; наладкі, спэцыфічныя для карыстальніка;</li>
            <li><em><code>/etc/gitconfig</code></em> (зьмяняюцца пры выкарыстаньні опцыі <code>--system</code>)&nbsp;&mdash; наладкі, характэрныя для ўсёй сыстэмы;</li>
          </ul>
        </p>

        <h2 id="Configuration_identity">Асабістыя даныя карыстальніка</h2>
        <p>Перш за ўсё пазначце свае ідэнтыфікацыйныя даныя:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          git config --global user.name "Alesj Zagorski"
          git config --global user.email a.zagorski@example.com
        ]]></script>

        <h2 id="Configuration_merge">Прылада параўнаньня (merge tool)</h2>
        <p>Акрамя гэтага можна пазначыць сваю ўлюбёную прыладу параўнаньня файлаў:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          git config --global merge.tool meldMerge
          git config --global mergetool.meldMerge.cmd meldMerge "$LOCAL" "$BASE" "$REMOTE" "$MERGED"
        ]]></script>

        <h2 id="Configuration_Other">Яшчэ наладкі</h2>
        <p>Пры каміце зьмяняе ўсе <i>CR/LF</i> (<i>Windows</i>-стыль для пераводу радка), якія патрапіліся ў кодзе, на адзіночны <i>LF</i> (<i>Linux</i>-стыль для пераводу радка):</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          git config --global core.autocrlf input
        ]]></script>
        <p>Пры чэкаўце зьмяняе ўсе <i>LF</i> на <i>CR/LF</i>, а пры каміце робіць наадварот:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          git config --global core.autocrlf true
        ]]></script>
        <p>Наладжвае <i>Git</i> такім чынам, каб ён фарбаваў лог:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          git config --global color.ui true
        ]]></script>

        <h2 id="Configuration_list">Прагляд наладкаў</h2>
        <p>Праглядзець усе цяперашнія наладкі можна камандай:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          git config --list
        ]]></script>
        <p>Пры гэтым вынік папярэдняй каманды будзе выглядаць неяк так:</p>
        <script type="syntaxhighlighter" class="brush: text"><![CDATA[
          core.symlinks=false
          core.autocrlf=true
          color.diff=auto
          pack.packsizelimit=2g
          help.format=html
          http.sslcainfo=/bin/curl-ca-bundle.crt
          sendemail.smtpserver=/bin/msmtp.exe
          user.name=Alesj Zagorski
          user.email=a.zagorski@example.com
          merge.tool=meldMerge
        mergetool.meldMerge.cmd=meldMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
        ]]></script>
        <p>А цяперашняе значэньне пэўнага атрыбуту наступным чынам (напрыклад, імя карыстальніка):</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          git config user.name
        ]]></script>
      </section>

      <section>
        <h1 id="Repo" data-content-item-open>Стварэньне рэпазыторыяў</h1>
        <div class="refs">
          <ul>
            <li><a href="http://git-scm.com/book/ru/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-Git-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F">ProGit</a></li>
          </ul>
        </div>
        <p>Існуюць дзьве галоўныя магчымасьці, каб стварыць рэпазыторый. Першая&nbsp;&mdash; стварыць новы рэпазыторый ў лякальнай тэчцы (ў пустой, ці з ужо існуючым праектам). Другая&nbsp;&mdash; кланаваць існуючы «аддалены» рэпазыторый.</p>

        <h2 id="Repo_init">Стварэньне лякальнага рэпазыторыю</h2>
        <div class="refs">
          <ul>
            <li><a href="https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init">Atlassian</a></li>
          </ul>
        </div>
        <p>Для таго, каб стварыць новы лякальны рэпазыторый, трэба ў тэчцы праекту (ці ў пустой тэчцы, у якой плянуецца стварыць праект) запусьціць каманду:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          git init
        ]]></script>
        <p>У выніку будзе створана схаваная тэчка рэпазыторыю <code>.git</code></p>

        <h2 id="Repo_clone">Кланаваньне аддаленага рэпазыторыю</h2>
        <div class="refs">
          <ul>
            <li><a href="https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone">Atlassian</a></li>
          </ul>
        </div>
        <p><a href="#Remotes">Аддалены</a> ў дадзеным выпадку дастаткова адноснае разуменьне, таму што такім рэпазыторыем можа быць і існуючы ў лякальнай файлавай сыстэме (хаця гэта і ня вельмі верагодны выпадак). Але галоўнае для гэтага мэтаду&nbsp;&mdash; што «эталонны» рэпазыторый ужо павінен недзе існаваць:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          git clone &lt;ШЛЯХ_ДА_РЭПАЗЫТОРЫЮ&gt; [&lt;ІМЯ_ЛЯКАЛЬНАГА_РЭПАЗЫТОРЫЮ&gt;]
        ]]></script>
        <p>Напрыклад, у выпадку каманды:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          git clone git://github.com/schacon/grit.git mygrit
        ]]></script>
        <p>у цяперашняй тэчцы будзе створана тэчка <code>mygrit</code>, у якую будзе кланаваны рэпазыторый, які знаходзіцца па адрасе <code>github.com/schacon/grit.git</code> з выкарыстаньнем пратаколу <code>git://</code>. Магчымы таксама пратакол <code>http(s)://</code> ці ўвогуле без пратаколу ў выпадку лякальнага зьмяшчэньня «аддаленага» рэпазыторыю. Калі імя ствараемага рэпазыторыю (апошні парамэтар) не пазначана, будзе ўжытае імя аддаленага рэпазыторыю.</p>
        <p>Акрамя сьцягваньня аддаленага рэпазыторыю ў лякальнае месцазнаходжаньне гэтая каманда створыць спасылку на аддалены рэпазыторый пад імем «origin», а таксама пераключыцца на першапачатковую <a href="#Branching">галіну</a> аддаленага рэпазыторыю (верагодней за ўсё «master»).</p>
      </section>

      <section>
        <h1 id="FileStatusLifecycle" data-content-item-open>Жыцьцёвы цыкл стану файлаў</h1>
        <div class="refs">
          <ul>
            <li><a href="http://git-scm.com/book/ru/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D1%8C-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B2-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B9">ProGit</a></li>
          </ul>
        </div>
        <p>Такім чынам, вы стварылі новы рэпазыторый і гатовыя ўносіць зьмены, каб стварыць яшчэ адзін карысны праект. У гэты момант важна разабрацца са станамі, у якіх могуць знаходзіцца файлы вашага праекту, з пункту гледжаньня <i>Git</i>. Два асноўных стана&nbsp;&mdash; гэта <i>адсочваемы</i> і <i>неадсочваемы</i>. Назвы гавораць самі за сябе, за зьменамі ў адсочваемых файлах <i>Git</i> сочыць, а за зьменамі ў неадсочваемых, адпаведна, не. Адразу варта адзначыць, што ў выпадку, калі рэпазыторый ствараецца як клон аддаленага (ужо існуючага) рэпазыторыю, усе файлы ў тэчцы створанага рэпазыторыю аўтаматычна пераходзяць у стан сачэньня. Калі ж вы ствараеце абсалютна новы рэпазыторый (каманда <code>git init</code>), усе раней існуючыя файлы ў тэчцы рэпазыторыю застаюцца ў неадсочваемым стане і якія б зьмены вы ў іх ня ўнесьлі, <i>Git</i> аб іх ня будзе ведаць датуль, пакуль вы не перавядзеце іх яўна ў адсочваемы стан.</p>
        <p>Адсочваемы стан у сваю чаргу падзяляецца на <i>нязьменены</i> (першапачатковы альбо зафіксаваны стан), <i>зьменены</i> (у файл унесьлі зьмены, але пакуль яшчэ ня далі ніякіх інструкцыяў, што з гэтымі зьменамі рабіць), <i>праіндэксаваны</i> (карыстальнік праінструктаваў <i>Git</i>, што зьбіраецца зафіксаваць зьмены ў файле). Калі зьмены ў праіндэксаваным файле фіксуюцца, файл пераходзіць ізноў у нязьменены стан. Акрамя гэтага зьмены ў зьмененым альбо праіндэксаваным файле могуць быць адмененыя, тады файл таксама пераходзіць у нязьменены стан.</p>
        <p>Усё вышэйсказанае пра станы файлаў адлюстравана ў наступнай схеме:
          <figure style="text-align: center;">
            <img alt="Жыцьцёвы цыкл стану файлаў" title="Жыцьцёвы цыкл стану файлаў" src="lifecycle.png"/>
            <figcaption class="imgcaption">Жыцьцёвы цыкл стану файлаў</figcaption>
          </figure>
        </p>

        <h2 id="FileStatusLifecycle_CheckStatus">Праверка статусу</h2>
        <div class="refs">
          <ul>
            <li><a href="https://www.atlassian.com/git/tutorials/inspecting-a-repository/git-status">Atlassian</a></li>
          </ul>
        </div>
        <p>Атрымаць справаздачу аб тым, у якім статусе знаходзяцца файлы праекту, можна камандай <code>git status</code>. Калі вы выканаеце гэтую каманду адразу пасьля стварэньня новага рэпазыторыю ў пустой тэчцы, вы пабачыце прыкладна наступнае:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [6]"><![CDATA[
          $ git status
          # On branch master
          #
          # Initial commit
          #
          nothing to commit (create/copy files and use "git add" to track)
        ]]></script>
        <p>У вывадзе пазначана ў якой <a href="#Branching">галіне</a> мы знаходзімся (па змоўчваньні гэта заўсёды «master»), а таксама што <i>Git</i> не знайшоў ніякіх зьменаў, якія можна было б праіндэксаваць альбо зафіксаваць (<i>nothing to commit</i>).</p>
        <p>Цяпер створым новы файл <code>README.txt</code> у корані праекту і запусьцім тую ж самую каманду:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [6, 10]"><![CDATA[
          $ git status
          # On branch master
          #
          # Initial commit
          #
          # Untracked files:
          #   (use "git add <file>..." to include in what will be committed)
          #
          # README.txt
          nothing added to commit but untracked files present (use "git add" to track)
        ]]></script>
        <p>Гэтым разам <i>Git</i> заўважыў, што зьявіўся новы файл, за якім не было каманды сачыць (<i>Untracked files</i>), і вывеў назву гэтага файлу.</p>

        <h2 id="FileStatusLifecycle_AddingNewFiles">Далучэньне новых файлаў да рэпазыторыю</h2>
        <div class="refs">
          <ul>
            <li><a href="https://www.atlassian.com/git/tutorials/saving-changes/git-add">Atlassian</a></li>
          </ul>
        </div>
        <p>Прыйшоў час далучыць файл да рэпазыторыю, іншымі словамі перавесьці яго з неадсочваемага стану ў адсочваемы. Для гэтага выкарыстоўваецца каманда <code>git add</code>. Забяжым наперад і адзначым, што гэтая каманда ў <i>Git</i> шматфункцыянальная і выкарыстоўваецца ў тым ліку для таго, каб праіндэксаваць зьмены ў файле. Гэта можа бянтэжыць, таму паспрабуйце адразу гэта прыняць як факт, хоць і дзіўны. Такім чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git add README.txt
        ]]></script>
        <p>Цяпер, калі вывесьці справаздачу аб статусе праекту, атрымаем наступнае:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [6, 9]"><![CDATA[
          $ git status
          # On branch master
          #
          # Initial commit
          #
          # Changes to be committed:
          #   (use "git rm --cached <file>..." to unstage)
          #
          # new file:   README.txt
        ]]></script>
        <p>Пры гэтым такі файл апынаецца ў праіндэксаваным стане і наступным крокам яго цяперашні зьмест можа быць зафіксаваны ў рэпазыторыі. Каманда <code>git add</code> можа прымаць і сьпіс файлаў, і маскі файлаў:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [6, 9]"><![CDATA[
          git add *.txt       # дадаць файлы цяперашняй тэчцы, якія маюць пашырэньне .txt
          git add docs/*.txt  # дадаць файлы, якія маюць пашырэньне .txt, і знаходзяцца ў тэчцы docs
          git add docs/       # дадаць файлы, якія знаходзяцца ў тэчцы docs, незалежна ад пашырэньня
          git add "*.txt"     # дадаць файлы ўсёй герархіі праекту, якія маюць пашырэньне .txt
          git add -all        # дадаць усе новыя файлы ўсёй герархіі праекту
        ]]></script>

        <h2 id="FileStatusLifecycle_StagingChangedFiles">Індэксацыя зьмененых файлаў</h2>
        <p>Хаця апэрацыі далучэньня новых і індэксацыі зьмененых файлаў па сутнасьці сваёй адрозьніваюцца адна ад другой, у <i>Git</i> для іх ажыцьцяўленьня ўжываецца адна і тая ж каманда <code>git add</code>. Уявім, што ў нашым рэпазыторыі ўжо ёсьць адсочваемы і нязьменены файл <code>TODO.txt</code>. Унясем у яго пэўныя зьмены і запытаем у <i>Git</i> пра статус рэпазыторыю:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [8, 12]"><![CDATA[
          $ git status
          # On branch master
          # Changes to be committed:
          #   (use "git reset HEAD <file>..." to unstage)
          #
          # new file:   README.txt
          #
          # Changes not staged for commit:
          #   (use "git add <file>..." to update what will be committed)
          #   (use "git checkout -- <file>..." to discard changes in working directory)
          #
          # modified:   TODO.txt
        ]]></script>
        <p>У выніку <i>Git</i> нам кажа (радкі 8 і 12), што файл <code>TODO.txt</code> зьменены (<i>modified</i>), але зьмены яшчэ не праіндэксаваныя (<i>Changes not staged</i>), каб мець магчымасьць іх зафіксаваць. Таму праіндэксуем іх:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [8, 12]"><![CDATA[
          $ git add TODO.txt
        ]]></script>
        <p>Гэтым разам запыт на статус нам выдасьць наступны вынік:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          $ git status
          # On branch master
          # Changes to be committed:
          #   (use "git reset HEAD <file>..." to unstage)
          #
          # new file:   README.txt
          # modified:   TODO.txt
        ]]></script>
        <p>Які кажа нам пра тое, што ў рэпазыторыі існуюць адзін новы і адзін зьменены файлы, якія былі праіндэксаваныя і гатовыя да фіксацыі.</p>
        <p>Але цяпер уявім, што вы забыліся ўнесьці пэўныя зьмены ў файл <code>TODO.txt</code> і не жадаеце фіксаваць яго бяз гэтых зьменаў. Унясем зьмены і ізноў запытаемся пра статус рэпазыторыю:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [7, 13]"><![CDATA[
          $ git status
          # On branch master
          # Changes to be committed:
          #   (use "git reset HEAD <file>..." to unstage)
          #
          # new file:   README.txt
          # modified:   TODO.txt
          #
          # Changes not staged for commit:
          #   (use "git add <file>..." to update what will be committed)
          #   (use "git checkout -- <file>..." to discard changes in working directory)
          #
          # modified:   TODO.txt
        ]]></script>
        <p>Што-што? Ці не падводзіць нас зрок? Файл <code>TODO.txt</code> пазначаны двойчы і як праіндэксаваны, чые зьмены могуць быць зафіксаванымі, і як зьменены, але не праіндэксаваны. На самай справе ніякай памылкі тут няма. Калі мы цяпер зробім фіксацыю гэтага файлу, у рэпазыторый трапіць не цяперашні яго стан, але праіндэксаваны на папярэднім кроку. Акрамя гэтых праіндэксаваных зьменаў, існуюць яшчэ і не праіндэксаваныя, пра гэта нам <i>Git</i> і кажа. Каб гэтыя апошнія, непраіндэксаваныя зьмены таксама трапілі ў рэпазыторый, трэба ізноў выканаць каманду індэксацыі <code>git add TODO.txt</code>.</p>

        <h2 id="FileStatusLifecycle_ViewingChanges">Прагляд зьменаў</h2>
        <p>Часам абагульняючай справаздачы пра статус праекту, якая выводзіцца камандай <code>git status</code>, недастаткова і нам патрэбна зразумець што менавіта зьмянілася ў зьмененых файлах. На дапамогу прыходзіць каманда <code>git diff</code>. Каб пабачыць, якія зьмены мы зрабілі але яшчэ не праіндэксавалі, трэба выканаць каманду <code>git diff</code> без аргумэнтаў:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [8]"><![CDATA[
          $ git diff
          diff --git a/TODO.txt b/TODO.txt
          index 788496a..34e164a 100644
          --- a/TODO.txt
          +++ b/TODO.txt
          @@ -1 +1,2 @@
           1. Зрабіць пэўную рэч
          +2. Зрабіць нешта яшчэ
        ]]></script>
        <p>У восьмым радку нам гавораць, што ў файл <code>TODO.txt</code> дадаўся радок «2. Зрабіць нешта яшчэ» (прэфікс «+» кажа пра тое, што дадалося, а прэфікс «-»&nbsp;&mdash; што зьнікла).</p>
        <p>Каб пабачыць, чым праіндэксаваныя зьмены адрозьніваюцца ад апошняга зафіксаванага стану, трэба дадаць парамэтар <code>--cached</code> (пачынаючы з вэрсіі 1.6.1 у <i>Git</i> існуе раўназначны парамэтар <code>--staged</code>):</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [3, 10]"><![CDATA[
          $ git diff --cached
          diff --git a/README.txt b/README.txt
          new file mode 100644
          index 0000000..e69de29
          diff --git a/TODO.txt b/TODO.txt
          index e69de29..788496a 100644
          --- a/TODO.txt
          +++ b/TODO.txt
          @@ -0,0 +1 @@
          +1. Зрабіць пэўную рэч
        ]]></script>
        <p>У трэцім радку нам гавораць, што быў праіндэксаваны новы файл <code>README.txt</code>, а ў дзесятым радку кажуць пра тое, што ў файл <code>TODO.txt</code> дадалі радок «1. Зрабіць пэўную рэч», і таксама праіндэксавалі гэтую зьмену.</p>

        <h2 id="FileStatusLifecycle_CommitingChanges">Фіксацыя зьменаў</h2>
        <div class="refs">
          <ul>
            <li><a href="https://www.atlassian.com/git/tutorials/saving-changes/git-commit">Atlassian</a></li>
          </ul>
        </div>
        <p>Такім чынам, мы дакладна ведаем што ў якіх файлах было зьменена, і застаўся апошні крок у жыцьцёвым цыкле стану файлаў <i>Git</i>-рэпазыторыю&nbsp;&mdash; канчаткова зафіксаваць гэтыя зьмены. Для фіксацыі зьменаў існуе каманда <code>git commit</code>. Калі выканаць гэтую каманду без парамэтраў, <i>Git</i> адчыніць тэкставы рэдактар (які пазначаны ў парамэтры <a href="#Configuration">наладак</a> <code>core.editor</code>) з прапановай увесьці камэнтар для каміту (фіксацыі):</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          # Please enter the commit message for your changes. Lines starting
          # with '#' will be ignored, and an empty message aborts the commit.
          # On branch master
          # Changes to be committed:
          #   (use "git reset HEAD <file>..." to unstage)
          #
          # new file:   README.txt
          # modified:   TODO.txt
          #
        ]]></script>
        <p>Уводзім нейкі камэнтар і зачыняем акно рэдактару, захоўваючы зьмены. <i>Git</i> выдасьць наступны вынік:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git commit
          [master bd5cc27] Add README.txt, modify TODO.txt
           2 files changed, 2 insertions(+)
           create mode 100644 README.txt
        ]]></script>
        <p>Тое ж самае можна зрабіць такім чынам, каб <i>Git</i> не адчыняў акно рэдактару, праз дадатковы парамэтар:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git commit -m "Add README.txt, modify TODO.txt"
        ]]></script>
        <p>Яшчэ варыяцыі каманды фіксацыі, якія могуць стацца карыснымі...</p>
        <p>Адначасова праіндэксаваць і зафіксаваць усе зьмены ўва ўсіх адсочваемых файлах у адной камандзе можна наступным чынам (<strong>але дадзеная каманда не дадае новыя файлы да рэпазыторыю</strong>):</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git commit -a -m "Add README.txt, modify TODO.txt"
        ]]></script>
        <p>Калі мы забылі нешта зрабіць у межах ужо зробленай апошняй фіксацыі, дадатковыя зьмены (ужо праіндэксаваныя) ў гэтую фіксацыю можна дадаць такім чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git commit --amend -m "Modify TODO &amp; add README."
        ]]></script>
        <p>То бок у дадзеным выпадку будзе зроблена не новая фіксацыя, але дапоўнена апошняя. Калі пазначыць камэнтар у гэтай камандзе, тады камэнтар апошняй фіксацыі будзе ім перакрыты.</p>

        <h2 id="FileStatusLifecycle_RevertingChanges">Адмена зьменаў</h2>
        <div class="refs">
          <ul>
            <li><a href="http://git-scm.com/book/ru/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9E%D1%82%D0%BC%D0%B5%D0%BD%D0%B0-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9">ProGit</a></li>
            <li><a href="https://www.atlassian.com/git/tutorials/undoing-changes">Atlassian</a></li>
          </ul>
        </div>
        <aside>У малюнках, якія будуць прыводзіцца ніжэй, лініямі з подпісамі ўверсе (<i>master</i>, напр.) будуць азначацца галіны і іх імёны. Кругі на лініі&nbsp;&mdash; гэта каміты альбо фіксацыі, шэрым колерам тыя зь іх, якія нас не цікавяць на дадзены момант, іншымі колерамі&nbsp;&mdash; якія маюць нейкае значэньне для дадзенага прыкладу. У прамых дужках зьлева ад камітаў&nbsp;&mdash; кароткая форма іх хэшаў. Стрэлкай пазначаецца апошняя фіксацыя рэпазыторыю, якая звычайна завецца <i>HEAD</i>. Блакітны блёк паказвае стан індэксу, а чырвоны&nbsp;&mdash; цяперашні працоўны стан (цяперашні стан файлавай сыстэмы).</aside>
        <p>Да гэтага часу мы з вамі разглядзелі поўны цыкл станаў, якія могуць прымаць файлы з пункту гледжаньня <i>Git</i>, але гэта толькі адна з магчымых, аптымістычная пасьлядоўнасьць, калі ўсё ідзе гладка. Але існуе яшчэ адна, пэсымістычная пасьлядоўнасьць, калі зьмены трэба не праіндэксаваць, альбо зафіксаваць, але адмяніць.</p>

        <h3 id="FileStatusLifecycle_RevertingChanges_WorkingTree">Адмена працоўных зьменаў</h3>
        <p>Спачатку самы просты выпадак&nbsp;&mdash; у нас быў файл у зафіксаваным стане і мы ўнесьлі ў яго зьмены, якія яшчэ не праіндэксавалі:
          <figure class="git_branching">
            <img alt="Стан рэпазыторыю пасьля зьменаў у файле" title="Стан рэпазыторыю пасьля зьменаў у файле" src="checkout1_1.png"/>
          </figure>
        </p>
        <p>Адмяніць гэтыя зьмены і, адпаведна, перавесьці файл у папярэдні зафіксаваны стан можна наступным чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git checkout -- TODO.txt
        ]]></script>
        <aside>Замест імені аднаго файлу можна пазначыць пералік імёнаў некалькіх файлаў, альбо маску, як апісана ў <a href="#FileStatusLifecycle_AddingNewFiles">гэтым разьдзеле</a>.</aside>
        <p>У выніку атрымаецца:
          <figure class="git_branching">
            <img alt="Стан рэпазыторыю пасьля адмены зьменаў у файле" title="Стан рэпазыторыю пасьля адмены зьменаў у файле" src="checkout1_2.png"/>
          </figure>
        </p>

        <h3 id="FileStatusLifecycle_RevertingChanges_StagedChanges">Адмена праіндэксаваных зьменаў</h3>
        <p>Цяпер уявім, што мы не адмянілі працоўныя зьмены ў папярэднім кроку, але ўжо пасьпелі праіндэксаваць іх:
          <figure class="git_branching">
            <img alt="Стан рэпазыторыю пасьля індэксацыі зьменаў у файле" title="Стан рэпазыторыю пасьля індэксацыі зьменаў у файле" src="checkout2_1.png"/>
          </figure>
        </p>
        <p>Адмяніць гэтую індэксацыю можна наступным чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git reset --mixed HEAD TODO.txt
        ]]></script>
        <aside>Калі пры выкананьні каманды <code>git reset</code> не пазначыць імені файлу(-аў), у выніку будзе зроблена тое ж самае (ачыстка ці перамяшчэньне індэксу да пэўнай фіксацыі), але не для абранага(-ых) файлу(-аў), але для усіх зьмененых у праекце.</aside>
        <p>Пры гэтым зьмены ў файле застануцца, але застануцца толькі ў працоўнай вэрсіі, індэкс больш не будзе іх утрымліваць:
          <figure class="git_branching">
            <img alt="Стан рэпазыторыю пасьля адмены індэксацыі" title="Стан рэпазыторыю пасьля адмены індэксацыі" src="checkout1_1.png"/>
          </figure>
        </p>
        <p>Таксама варта дадаць, што парамэтар <code>--mixed</code>, а таксама імя апошняй фіксацыі <code>HEAD</code> зьяўляюцца змоўчнымі і тую ж самую каманду можна было б выканаць наступным чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git reset TODO.txt
        ]]></script>

        <h3 id="FileStatusLifecycle_RevertingChanges_StagedAndWorkingTreeChanges">Адмена праіндэксаваных і працоўных зьменаў</h3>
        <p>Ізноў вернемся да стану, калі ў нас ёсьць праіндэксаваныя зьмены:
          <figure class="git_branching">
            <img alt="Стан рэпазыторыю пасьля індэксацыі зьменаў у файле" title="Стан рэпазыторыю пасьля індэксацыі зьменаў у файле" src="checkout2_1.png"/>
          </figure>
        </p>
        <p>Адначасова адмяніць і працоўныя, і праіндэксаваныя зьмены можна камандай:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git reset --hard TODO.txt
        ]]></script>
        <aside>У дадзеным выпадку выкарыстоўваецца парамэтар <code>--hard</code>, які не зьяўляецца змоўчным і таму абавязковы для пазначэньня. <br /> <br /> Каманду можна выконваць і без пазначэньня імёнаў пэўных файлаў, тады будуць адмененыя зьмены ўва ўсіх зьмененых файлах.</aside>
        <p>У выніку атрымаецца:
          <figure class="git_branching">
            <img alt="Стан рэпазыторыю пасьля адмены зьменаў у файле" title="Стан рэпазыторыю пасьля адмены зьменаў у файле" src="checkout1_2.png"/>
          </figure>
        </p>

        <h3 id="FileStatusLifecycle_RevertingChanges_MovingStagingArea">Зьмяшчэньне ў індэкс стану пэўнай фіксацыі</h3>
        <p>Дый увогуле каманда <code>git reset</code> мае больш агульны сэнс і можна яе ўяўляць як перамяшчэньне індэксу, напрыклад каманда:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git reset HEAD~ TODO.txt
        ]]></script>
        <aside>Гэтую каманду можна выконваць без пазначэньня імён пэўных файлаў, тады ўсё пазначанае ў гэтым разьдзеле будзе выканана не для пэўных файлаў, а для ўсяго рэпазыторыю.</aside>
        <p>Прывядзе да таго, што індэкс будзе ўтрымліваць стан папярэдняй (тыльда ў канцы <code>HEAD</code>) фіксацыі:
          <figure class="git_branching">
            <img alt="Перамяшчэньне індэксу да стану папярэдняй фіксацыі" title="Перамяшчэньне індэксу да стану папярэдняй фіксацыі" src="checkout2_3.png"/>
          </figure>
        </p>
        <aside><strong>БУДЗЬЦЕ УВАЖЛІВЫМІ!</strong> Пасьлядоўнае выкананьне <code>git reset &lt;commit-hash&gt;</code> і <code>git commit</code> прывядзе да таго, што ўсе зьмены ў фіксацыях паміж пазначанай і апошняй уключна будуць адмененыя, хаця і застануцца ў гісторыі.</aside>
        <p>І, як пабочны эфэкт гэтага, выкананьне каміту ў наступны момант прывядзе да таго, што папярэдняя фіксацыя будзе яшчэ раз зафіксавана і перакрые цяперашнюю (стан камітаў <code>[fe287f0...]</code> і <code>[bfb2e2b...]</code> будзе поўнасьцю ідэнтычным):
          <figure class="git_branching">
            <img alt="Каміт пасьля перамяшчэньня індэксу да стану папярэдняй фіксацыі" title="Каміт пасьля перамяшчэньня індэксу да стану папярэдняй фіксацыі" src="checkout2_4.png"/>
          </figure>
        </p>

        <h3 id="FileStatusLifecycle_RevertingChanges_MovingStagingAreaAndWorkingDirectory">Зьмяшчэньне ў індэкс і ў працоўную галіну стану пэўнай фіксацыі</h3>
        <p>Амаль тое ж самае, што апісвалася ў папярэднім разьдзеле, можна выканаць іншай камандай:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git checkout HEAD~ TODO.txt
        ]]></script>
        <p>Адрозьненьнем будзе тое, што ня толькі індэкс, але і працоўная <a href="#Branching">галіна</a> будзе ўтрымліваць стан пазначанай фіксацыі (папярэдняй ў дадзеным прыкладзе&nbsp;&mdash; <code>HEAD~</code>). І яшчэ адным немалаважным адрозьненьнем будзе тое, што гэтую каманду немагчыма ўжыць без пазначэньня імён файлаў, для якіх мы жадаем яе выканаць, дакладней магчыма, але <a href="#FileStatusLifecycle_Detached">сэнс яе будзе зусім іншы</a>.</p>
        <p>Калі ў якасьці парамэтру пазначыць апошнюю фіксацыю:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git checkout HEAD TODO.txt
        ]]></script>
        <p>тады вынік каманды будзе дакладна такім жа, як і вынік каманды (<a href="#FileStatusLifecycle_RevertingChanges_StagedAndWorkingTreeChanges">глядзі разьдзел</a>):</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git reset --hard TODO.txt
        ]]></script>
        <p>То бок зьмены ў індэксе і ў працоўнай <a href="#Branching">галіне</a> будуць згубленыя, у выніку індэкс і працоўная галіна будуць зьмяшчаць стан апошняй фіксацыі.</p>

        <h3 id="FileStatusLifecycle_RevertingChanges_RevertingCommitsLocally">Адмена лякальных фіксацыяў</h3>
        <p>Дагэтуль мы разглядалі магчымасьці адмены пэўных зьменаў, не зьмяняючы папярэдняй гісторыі камітаў. Але <i>Git</i> дазваляе адмяняць каміты, якія былі зробленыя раней і ўжо зафіксаваныя ў гісторыі. Прычым ёсьць 2 шляхі, як гэта можна рабіць. Адзін, для лякальных фіксацыяў&nbsp;&mdash; тых, што маюцца пакуль што толькі ў лякальнай гісторыі, мы разгледзім у дадзеным разьдзеле. Іншы, для фіксацыяў, якія ўжо былі зьмешчаныя ў <a href="#Remotes">аддалены, альбо публічны рэпазыторый</a>&nbsp;&mdash; у <a href="#FileStatusLifecycle_RevertingChanges_RevertingCommitsRemotely">наступным разьдзеле</a>.</p>
        <p>Улічваючы, што адмена лякальных фіксацыяў фізычна выдаляе іх з гісторыі камітаў, яе ня варта ўжываць для «цэнтральнага» рэпазыторыю, таму што гэта можа значна ўскладніць сумесную працу ў камандзе, калі нехта ўжо сьцягнуў сабе такую фіксацыю і разьлічвае, што яна там ёсьць і будзе заставацца далей. Памятаем, што тэхнічна ў <i>Git</i> няма цэнтральнага рэпазыторыю, пад такім разумеецца той рэпазыторый, які каманда распрацоўкі дамовілася лічыць цэнтральным, і які для кожнага з каманды зьяўляецца <a href="#Remotes">аддаленым</a>.</p>

        <h4 id="FileStatusLifecycle_RevertingChanges_RevertingCommitsLocally_Soft">«Адмяні мяне далікатна»</h4>
        <p>Адмена лякальных фіксацыяў ў сваю чаргу таксама дзеліцца на 2 варыянты. Спачатку разгледзім «далікатны». Уявім сябе наступны стан рэпазыторыю і яго гісторыю:
          <figure class="git_branching">
            <img alt="Стан рэпазыторыю перад адменай" title="Стан рэпазыторыю перад адменай" src="checkout3_1.png"/>
          </figure>
        </p>
        <p>Калі выканаць наступную каманду:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git reset --soft HEAD~
        ]]></script>
        <p>Апошняя фіксацыя будзе фізычна выдаленая з гісторыі камітаў, а яе стан застанецца ў індэксе і ў працоўнай галіне:
          <figure class="git_branching">
            <img alt="Далікатная адмена апошняй фіксацыі" title="Далікатная адмена апошняй фіксацыі" src="checkout3_2.png"/>
          </figure>
        </p>
        <p>У якасьці парамэтру можна пазначыць ня толькі перадапошні, але і любы іншы каміт з гісторыі камітаў. Тады індэкс і працоўная <a href="#Branching">галіна</a> будзе ўтрымліваць зьмены ня толькі апошняга, але сукупна ўсіх адмененых камітаў. Такім чынам, асноўнае прызначэньне гэтай каманды&nbsp;&mdash; перарабіць адзін ці некалькі камітаў альбо аб'яднаць некалькі апошніх камітаў у адзін.</p>
        <p>Яшчэ раз зьвяртаю ўвагу, што каманда, якую мы толькі што разглядзелі, фізычна зьмяняе гісторыю камітаў, і хаця яна робіць гэта далікатна, захоўваючы адмененыя зьмены ў індэксе і ў працоўнай вобласьці, ужываць яе трэба ўважліва, асабліва памятаючы пра недапушчальнасьць адмяняць каміты, якія раней ужо былі заліты ў <a href="#Remotes">аддалены рэпазыторый</a>.</p>

        <h4 id="FileStatusLifecycle_RevertingChanges_RevertingCommitsLocally_Hard">«Адмяні мяне брутальна»</h4>
        <p>Але ў <i>Git</i> ёсьць яшчэ і каманда брутальнай адмены фіксацыяў. Ізноў вернемся да зыходнай сытуацыі:
          <figure class="git_branching">
            <img alt="Стан рэпазыторыю перад адменай" title="Стан рэпазыторыю перад адменай" src="checkout3_1.png"/>
          </figure>
        </p>
        <p>Калі замест парамэтра <code>--soft</code>, як у папярэднім прыкладзе, ужыць парамэтар <code>--hard</code>:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git reset --hard HEAD~2
        ]]></script>
        <p>Фіксацыі ня толькі будуць адмененыя, але і ўсе зьмены, якія былі імі зробленыя, будуць назаўжды згубленыя:
          <figure class="git_branching">
            <img alt="Брутальная адмена апошняй фіксацыі" title="Брутальная адмена апошняй фіксацыі" src="checkout3_3.png"/>
          </figure>
        </p>
        <p>Нечага і казаць, што калі ўжо далікатную адмену трэба рабіць уважліва, дык перад тым, як рабіць брутальную, варта не адзін раз усё ўзважыць.</p>
        <p>Таксама зьвярніце ўвагу, што ў адрозьненьні ад папярэдняга прыкладу ў якасьці ілюстрацыі мы зрабілі адмену не аднаго, але двух апошніх камітаў: <code>~2</code> пасьля <code>HEAD</code>. І ўвогуле, можна карыстацца не адноснымі імёнамі (столькі і столькі камітаў назад ад апошняга), а скарочанымі хэшамі камітаў для пазначэньня таго, да якога каміту зрабіць адкат. У наступным прыкладзе эфэкт быў бы дакладна такім жа, як і ў папярэднім:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git reset --hard bfb2e2b
        ]]></script>

        <h3 id="FileStatusLifecycle_RevertingChanges_RevertingCommitsRemotely">Адмена аддаленых фіксацыяў</h3>
        <p>У папярэднім разьдзеле мы зьвярталі асаблівую ўвагу на недапушчальнасьць выдаляць фіксацыі, які былі ўжо зьмешчаныя ў <a href="#Remotes">аддалены рэпазыторый</a>. Але ўсё ж існуе «правільны» спосаб адмяніць такія фіксацыі, калі раптам зьявілася патрэба. Уявім наступны стан рэпазыторыю, прычым гэта стан аддаленага ці публічнага рэпазыторыю, зафіксаваную гісторыю якога мы «не маем права» зьмяняць:
          <figure class="git_branching">
            <img alt="Стан рэпазыторыю перад адменай" title="Стан рэпазыторыю перад адменай" src="revert_1.png"/>
          </figure>
        </p>
        <p>І, напрыклад, мы заўважылі, што фіксацыя <code>fe287f0...</code> увяла ў код сур'ёзную праблему і варта яе выдаліць, ці ў дадзеным выпадку лепш сказаць выключыць. Тады можна выканаць наступную каманду:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git revert fe287f0
        ]]></script>
        <p>У гэтым выпадку <i>Git</i> сам прааналізуе, якія зьмены былі зроблены фіксацыяй <code>fe287f0...</code>, зьменіць код такім чынам, каб гэтыя зьмены выключыць, і зробіць новы каміт, які зафіксуе выключэньне памылковых зьменаў:
          <figure class="git_branching">
            <img alt="Стан рэпазыторыю перад адменай" title="Стан рэпазыторыю перад адменай" src="revert_2.png"/>
          </figure>
        </p>
        <p>Зьвярніце ўвагу, што як каміт <code>fe287f0...</code>, які мы плянавалі «адмяніць», гэтак і наступны пасьля яго каміт <code>fdb2291...</code> засталіся ў гісторыі камітаў. Стан жа рэпазыторыю пасьля гэтага адкату будзе дакладна такім жа, як калі б каміту <code>fe287f0...</code> увогуле не было. Варта дадаць, што <i>Git</i> здолее зрабіць адкат аўтаматычна толькі ў выпадку, калі ён відавочны. Калі ж існуюць канфлікты (нейкія файлы зьмяняліся як у каміце <code>fe287f0...</code>, гэтак і ў пазьнейшых камітах), <i>Git</i> праінфармуе пра іх і прапануе выправіць.</p>

        <h2 id="FileStatusLifecycle_Detached">Ізаляваны стан</h2>
        <p>Існуе яшчэ адзін стан, у якім можа знаходзіцца рэпазыторый (менавіта ўвесь рэпазыторый, а не асобны(-я) файл(-ы))&nbsp;&mdash; гэта так званы ізаляваны стан (<i>detached HEAD state</i>), у які рэпазыторый можна перавесьці пры дапамозе наступнай каманды:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git checkout <COMMIT_HASH>
        ]]></script>
        <p>У гэтым выпадку рэпазыторый прыме стан фіксацыі, хэш якой быў пазначаны ў камандзе, але гэта ізаляваны (ад гісторыі камітаў) стан. Усе зьмены, якія будуць цяпер уносіцца ў рэпазыторый, застануцца ў небыцьці, іх немагчыма будзе зафіксаваць. Ізаляваны стан ужываецца, напрыклад, для таго, каб мець магчымасьць пратэставаць як праект вёў сябе ў пэўны момант сваёй гісторыі, але каб пры гэтым не нашкодзіць працоўнай <a href="#Branching">галіне</a>.</p>
        <p>Вярнуць рэпазыторый ізноў у працоўны стан (да апошняй працоўнай фіксацыі) можна наступнай камандай:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git checkout master
        ]]></script>

        <h2 id="FileStatusLifecycle_RemovingFiles">Выдаленьне файлаў</h2>
        <p>Калі па нейкай прычыне праект больш ня мае патрэбы ў нейкім файле, выдаліць яго з праекту можна наступным чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git rm README.txt
        ]]></script>
        <p>Гэтая каманда выдаляе файл лякальна і перастае сачыць за ім, застанецца толькі закаміціць гэтую зьмену.</p>

        <h2 id="FileStatusLifecycle_IgnoringFiles">Ігнараваньне файлаў</h2>
        <p>Пры распрацоўцы праектаў акрамя файлаў, якія трэба захоўваць у рэпазыторыі, існуе шэраг файлаў, якія наадварот ня варта там захоўваць. Да такіх файлаў могуць адносіцца логі выкананьня праграмы, часовыя файлы, файлы наладак праекту (калі ўдзельнікі праекту вольныя выкарыстоўваць розныя сродкі распрацоўкі) і г.д. Зразумела, можна не дадаваць такія файлы да рэпазыторыю, але яны заўсёды будуць выводзіцца <i>Git</i>'ам ў справаздачы аб статусе, і чым большы праект, тым больш нязручна альбо нават немагчыма будзе весьці далейшую распрацоўку. <i>Git</i> мае сродак, каб цалкам ігнараваць пэўныя файлы, быццам іх не існуе. Гэта файл <code>.gitignore</code> у корані праекту, які ўтрымлівае маскі файлаў для ігнараваньня. Вось прыклад зьмесьціва гэтага файлу:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          # камэнтар — такі радок утрымлівае адвольны тэкст і не зьяўляецца маскай ігнараваньня

          # ігнараваць файлы, імёны якіх сканчваюцца на .tmp
          *.tmp

          # АЛЕ не ігнараваць файл important.tmp, нягледзячы на тое, што мы загадалі ігнараваць 
          # усе .tmp-файлы ў папярэднім правіле
          !important.tmp

          # ігнараваць толькі файл TODO.txt, які знаходзіцца ў корані праекту, 
          # не адносіцца да файлаў кшталту subdir/TODO.txt
          /TODO.txt

          # Ігнараваць усе файлы ў тэчцы logs/
          logs/

          # ігнараваць doc/notes.txt, але не doc/server/arch.txt
          doc/*.txt

          # ігнараваць усе .txt-файлы у тэчцы doc/, незалежна ад герархіі
          doc/**/*.txt
        ]]></script>
        <p>Часам бывае такое, што мы спачатку дадалі пэўны файл да рэпазыторыю, але пазьней вырашылі, што ня варта захоўваць яго ў рэпазыторыі, хаця лякальна ён павінен застацца. Тады можна выканаць наступную каманду:</p>
        <script type="syntaxhighlighter" class="brush: shell"><![CDATA[
          $ git rm --cached development.log
        ]]></script>
        <p>якая выдаліць файл <code>development.log</code> з рэпазыторыю, прычым <i>Git</i> ня толькі перастане сачыць за ім, але і фізычна выдаліць ўсю інфармацыю з рэпазыторыю, якая тычыцца гэтага файлу. Пасьля гэтага застанецца толькі дадаць адпаведнае правіла у <code>.gitignore</code>.</p>
      </section>

      <section>
        <h1 id="Remotes" data-content-item-open>Аддаленыя рэпазыторыі</h1>
        <div class="refs">
          <ul>
            <li><a href="http://git-scm.com/book/ru/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%83%D0%B4%D0%B0%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F%D0%BC%D0%B8">ProGit</a></li>
            <li><a href="https://www.atlassian.com/git/tutorials/syncing">Atlassian</a></li>
          </ul>
        </div>
        <p>Аддаленыя рэпазыторыі, гэта нішто іншае як лякальныя імя і спасылка да фізычна аддаленага рэпазыторыю. Напрыклад, калі мы <a href="#Repo_clone">клануем аддалены рэпазыторый</a>, <i>Git</i> аўтаматычна стварае лякальную спасылку <code>origin</code> да рэпазыторыю, <i>URL</i> якога быў пазначаны пры кланаваньні.</p>

        <h2 id="Remotes_Listing">Прагляд</h2>
        <p>Каб праглядзець сьпіс існуючых лякальна спасылак на аддаленыя рэпазыторыі, трэба выканаць каманду:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [2]"><![CDATA[
          $ git remote
          origin
        ]]></script>
        <p>Якая выдасьць, што у дадзены момант існуе адзіная спасылка&nbsp;&mdash; <code>origin</code>.</p>
        <p>Да гэтай каманды можна дадаць парамэтар <code>-v</code>:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [2,3]"><![CDATA[
          $ git remote -v
          origin  git@github.com:yurtsevich/Manuals.git (fetch)
          origin  git@github.com:yurtsevich/Manuals.git (push)
        ]]></script>
        <p>Тады акрамя імені <i>Git</i> выдасьць яшчэ і адпаведную спасылку.</p>

        <h2 id="Remotes_Creating">Стварэньне</h2>
        <p>Стварыць новую спасылку на аддалены рэпазыторый можна наступным чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git remote add <імя> <URL>
        ]]></script>
        <p>Напрыклад:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          $ git remote add zagorski https://github.com/zagorski/git-test.git
        ]]></script>
        <p>створыць спасылку <code>zagorski</code> на рэпазыторый, які месьціцца па спасылцы <code>https://github.com/zagorski/git-test.git</code>.</p>

        <h2 id="Remotes_Renaming">Перайменаваньне</h2>
        <p>Перайменаваць аддалены рэпазыторый можна наступным чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git remote rename <старое_імя> <новае_імя>
        ]]></script>

        <h2 id="Remotes_Renaming">Выдаленьне</h2>
        <p>Выдаліць лякальную спасылку на аддалены рэпазыторый можна наступным чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git remote rm <імя>
        ]]></script>

        <h2 id="Remotes_Fetching">Атрыманьне чужых зьменаў</h2>
        <p>Атрымаць ўсе зафіксаваныя зьмены (пачынаючы з папярэдняга <code>pull</code>) з аддаленага рэпазыторыю «origin» у лякальную <a href="#Branching">галіну</a> «master» можна наступнай камандай:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git pull origin master
        ]]></script>
        <p>На самай справе гэта не атамарная апэрацыя, яна складаецца зь некалькіх іншых апэрацыяў. Па-першае, пры дапамозе каманды <code>git fetch</code> зьмены з аддаленага рэпазыторыю сьцягваюцца на лякальную машыну (у галіну «origin/master»), а затым адбываецца спроба аўтаматычнага <a href="#MergeAndRebase">зьліцьця</a> гэтай лякальнай копіі аддаленага рэпазыторыю са зьменамі лякальнай актыўнай галіны пры дапамозе каманды <code>git merge origin/master</code>.</p>

        <h2 id="Remotes_Pushing">Публікацыя ўласных зьменаў</h2>
        <p>Наадварот перамясьціць ўсе зафіксаваныя зьмены (пачынаючы з папярэдняга <code>push</code>) зь лякальнай <a href="#Branching">галіны</a> «master» у аддалены рэпазыторый «origin» можна пры дапамозе каманды:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git push origin master
        ]]></script>
      </section>

      <section>
        <h1 id="Branching" data-content-item-open>Галінаваньне</h1>
        <div class="refs">
          <ul>
            <li><a href="http://git-scm.com/book/ru/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B5%D1%82%D0%BA%D0%B0%3F">ProGit</a></li>
            <li><a href="https://www.atlassian.com/git/tutorials/using-branches">Atlassian</a></li>
          </ul>
        </div>
        <p>Галіна ў <i>Git</i> уяўляе зь сябе асобную лінію распрацоўцы. Новы функцыянал альбо выпраўленьне памылкі, незалежна ад таго, наколькі дробнымі ці буйнымі будуць адпаведныя зьмены, варта рабіць у асобных галінах. І толькі калі праца над імі цалкам скончана, зьліваць гэтыя часовыя галіны ў асноўную. У такім разе вы гарантуеце, што сырыя, нестабільныя зьмены не трапяць у асноўную галіну.</p>
        <p>
          <figure class="git_branching">
            <img alt="Прыклад галінаваньня" title="Прыклад галінаваньня" src="branch_1.png"/>
          </figure>
          У вышэйпрыведзеным малюнку паказаны рэпазыторый з дзьвюма (акрамя асноўнай) ізаляванымі галінамі распрацоўцы&nbsp;&mdash; адна для выпраўленьня нязначнай памылкі («small_bug»), іншая для рэалізацыі новага функцыяналу («big_feature»). 
        </p>

        <h2 id="Branching_Listing">Прагляд</h2>
        <p>Наступная каманда выводзіць сьпіс галінаў цяперашняга лякальнага рэпазыторыю і пазначае якая зь іх на дадзены момант актыўная (сымбаль зорачкі перад імем галіны):</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [2]"><![CDATA[
          $ git branch
          * master
        ]]></script>

        <h2 id="Branching_Creating">Стварэньне</h2>
        <p>Стварыць новую галіну (пад імем «cat»), адгалінаванай ад актыўнай галіны, можна пры дапамозе наступнай каманды:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git branch cat
        ]]></script>
        <p>Пры гэтым рэпазыторый не будзе пераключаны на гэтую толькі што створаную галіну, але застанецца ў цяперашняй актыўнай.</p>

        <h2 id="Branching_Switching">Пераключэньне</h2>
        <p>Пераключыцца з актыўнай галіны ў галіну пад імем «cat» (якая пасьля выкананьня гэтай апэрацыі стане актыўнай) можна наступнай камандай:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git checkout cat
        ]]></script>
        <p>Наступная каманда выканае адначасова дзьве папярэднія апэрацыі&nbsp;&mdash; створыць новую галіну пад імем «dog» і пераключыцца з актыўнай галіны ў толькі што створаную:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git checkout -b dog
        ]]></script>
        <p>Калі цяпер вывесьці сьпіс галінаў, атрымаем наступны вынік:</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [3]"><![CDATA[
          $ git branch
          cat
          * dog
          master
        ]]></script>

        <h2 id="Branching_Deleting">Выдаленьне</h2>
        <p>Пасьля <a href="#MergeAndRebase">зьліцьця</a> пэўнай галіны з «master» яна можа быць выдалена (цалкам зьнішчана з гісторыі):</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git branch -d dog
        ]]></script>
        <p>Калі ў галіне «cat» раптам засталіся незафіксаваныя зьмены, <i>Git</i> не дазволіць выканаць гэтую апэрацыю, але існуе спосаб настаяць на выдаленьні ў такім выпадку, пазначыўшы опцыю <code>-D</code> замест <code>-d</code>:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git branch -D dog
        ]]></script>

        <h2 id="Branching_Remote">Аддаленыя галіны</h2>
        <p>Пры працы з галінамі ў аддаленым рэпазыторыі існуюць пэўныя асаблівасьці. Па-першае, наступным чынам можна вывесьці асноўную інфармацыю пра аддалены рэпазыторый («origin» у дадзеным выпадку), якая будзе ўлучаць у сябе інфармацыю пра яго галіны (разьдзел «Remote branches»), інфармацыю аб тым, за якімі зь іх вы сочыце («tracked»), а таксама інфармацыю аб тым, якія лякальныя галіны зьвязаны зь якімі аддаленымі галінамі (разьдзелы «Local branch...» і «Local refs...»):</p>
        <script type="syntaxhighlighter" class="brush: shell; highlight: [6,10,15,16,18]"><![CDATA[
          $ git remote show origin
          * remote origin
            Fetch URL: /media/E/Dropbox/Langaroo/Langaroo.git
            Push  URL: /media/E/Dropbox/Langaroo/Langaroo.git
            HEAD branch: master
            Remote branches:
              javascript                           new (next fetch will store in remotes/origin)
              js_dialogs_refactor                  new (next fetch will store in remotes/origin)
              languages_and_mails_ref              new (next fetch will store in remotes/origin)
              master                               tracked
              one_training_per_dictionary_refactor new (next fetch will store in remotes/origin)
              shared_dictionaries                  new (next fetch will store in remotes/origin)
              training_steps_refactor              new (next fetch will store in remotes/origin)
              trainings_refactoring                new (next fetch will store in remotes/origin)
              uiref                                tracked
            Local branch configured for 'git pull':
              master merges with remote master
            Local refs configured for 'git push':
              master                  pushes to master                  (fast-forwardable)
              training_steps_refactor pushes to training_steps_refactor (local out of date)
              uiref                   pushes to uiref                   (up to date)
        ]]></script>

        <h3 id="Branching_Remote_Listing">Прагляд</h3>
        <p>Вывесьці сьпіс усіх лякальных спасылак на аддаленыя галіны (усіх аддаленых рэпазыторыяў) можна наступнай камандай:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          $ git branch -r
            heroku/master
            origin/HEAD -> origin/master
            origin/master
            origin/uiref
        ]]></script>

        <h3 id="Branching_Remote_Creating">Стварэньне</h3>
        <p>Пры неабходнасьці стварыць аддаленую галіну і пачаць сачыць за ёй можна скарыстацца наступнымі камандамі. Спачатку створым новую лякальную галіну:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git checkout -b shopping_cart
        ]]></script>
        <p>А пасьля створым аднайменную аддаленую галіну і зьвяжам лякальную зь ёю:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git push origin shopping_cart
        ]]></script>
        <p>Калі іншы ўдзельнік каманды захоча працаваць са створанай вамі аддаленай галіной, яму дастаткова скарыстацца камандай пераключэньня ў аднайменную лякальную галіну&nbsp;&mdash; <i>Git</i> аўтаматычна зьвяжа яе з адпаведнай аддаленай:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git checkout shopping_cart
        ]]></script>

        <h3 id="Branching_Remote_Deleting">Выдаленьне</h3>
        <p>Выдаліць аддаленую галіну «shopping_cart» з аддаленага рэпазыторыю «origin» можна наступным чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git push origin :shopping_cart
        ]]></script>
        <p>А выдаліць лякальныя спасылкі на ўжо выдаленыя аддаленыя галіны аддаленага рэпазыторыю «origin» можна такім чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git remote prune origin
        ]]></script>
      </section>
        
      <section>
        <h1 id="MergeAndRebase" data-content-item-open>Зьліцьцё і перамяшчэньне галінаў</h1>

        <h2 id="MergeAndRebase_Merge" data-content-item-open>Зьліцьцё</h2>
        <p>Каманда зьліцьця выглядае наступным чынам:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git merge some_branch
        ]]></script>
        <p>Пры зьліцьці зьмены з пазначанай у камандзе галіны («some_branch») заўсёды заліваюцца ў цяперашнюю галіну, але якім чынам адбываецца зьліцьцё падзяляецца на 2 спосабы.</p>

        <h3 id="MergeAndRebase_Merge_FastForwarding">Прасоўваньне наперад</h3>
        <p>Уявім сабе, што мы адгалінаваліся ад асноўнай галіны, зрабілі ў новай галіне пэўныя зьмены, а асноўная за гэты час не зьмянілася:
          <figure class="git_branching">
            <img alt="Асноўная галіна не зьмянілася за час рэдагаваньня дадатковай" title="Асноўная галіна не зьмянілася за час рэдагаваньня дадатковай" src="merge_1.png"/>
          </figure>
        </p>
        <p>Мы праверылі, што новы функцыянал працуе правільна і жадаем яго зьмясьціць у асноўную галіну. Для гэтага пераключаемся ў асноўную галіну:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git checkout master
        ]]></script>
        <p>
          <figure class="git_branching">
            <img alt="Пераключэньне ў асноўную галіну" title="Пераключэньне ў асноўную галіну" src="merge_2.png"/>
          </figure>
        </p>
        <p>і выконваем каманду зьліцьця:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          git merge feature
        ]]></script>
        <p>У гэты момант ніякага зьліцьця на самай справе не адбываецца. Давайце разьбяромся, для гэтага паглядзіце на папярэдні малюнак, пры гэтым трэба памятаць, што галіны ў нашых схемах «рухаюцца» зьнізу ўверх. Пры гэтым, як відаць з малюнка, з галавы (паказальнік <code>HEAD</code>) асноўнай галіны можна трапіць у галаву галіны «feature», якую мы зьліваем, заўсёды рухаючыся наперад. Таму <i>Git</i> у такім выпадку ня робіць зьліцьцё, а проста перамяшчае галаву асноўнай галіны ў галаву той, што зьліваецца:
          <figure class="git_branching">
            <img alt="Прасоўваньне наперад" title="Прасоўваньне наперад" src="merge_3.png"/>
          </figure>
        То бок прасоўвае паказальнік наперад (<i>fast forwarding</i> у ангельскай тэрміналёгіі).</p>

        <h3 id="MergeAndRebase_Merge_Real">Паўнавартаснае</h3>
        <p>Калі ж за час працы над галіной «feature», у асноўную галіну былі ўнесеныя зьмены:
          <figure class="git_branching">
            <img alt="Асноўная галіна зьмянілася за час рэдагаваньня дадатковай" title="Асноўная галіна зьмянілася за час рэдагаваньня дадатковай" src="merge_4.png"/>
          </figure>
        </p>
        <p>Тады простае прасоўваньне наперад немагчымае: нельга трапіць з галавы «master» у галаву «feature», рухаючыся выключна наперад. У гэтым выпадку пры выкананьні зьліцьця <i>Git</i> спрабуе сабраць усе зьмены, якія былі зробленыя ў галіне «feature» з моманту адгалінаваньня ад «master», накласьці іх на цяперашні стан «master» і зафіксаваць гэтыя зьмены пры дапамозе новага каміту:
          <figure class="git_branching">
            <img alt="Паўнавартаснае зьліцьцё" title="Паўнавартаснае зьліцьцё" src="merge_5.png"/>
          </figure>
        </p>

        <h4 id="MergeAndRebase_Merge_Real_Conflicts">Канфлікты і іх вырашэньне</h4>
        <p>Пры паўнавартасным зьліцьці магчымыя канфлікты&nbsp;&mdash; гэта калі адзін і той жа кавалак коду ў пэўным файле быў зьменены ў абедзьвюх галінах пасьля іх адгалінаваньня. У выпадку ўзьнікненьня канфлікту <i>Git</i> спыніцца і прапануе выправіць канфлікт:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          $ git merge feature
          Auto-merging README.txt
          CONFLICT (content): Merge conflict in README.txt
          Automatic merge failed; fix conflicts and then commit the result.
        ]]></script>
        <p>Калі ў гэты момант выканаць каманду <code>git status</code>:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          $ git status
          # On branch master
          # You have unmerged paths.
          #   (fix conflicts and run "git commit")
          #
          # Unmerged paths:
          #   (use "git add <file>..." to mark resolution)
          #
          # both modified:      README.txt
          #
          no changes added to commit (use "git add" and/or "git commit -a")
        ]]></script>
        <p>Можна ўбачыць, што <i>Git</i> не зрабіў каміт, але спыніўся як раз перад ім. Цяпер трэба ўручную ўнесьці неабходныя зьмены ў канфліктны файл (<code>README.txt</code>). Трэба заўважыць, што ён зараз утрымлівае вэрсіі зьменаў з абедзьвюх галінаў, абгорнутых у адмысловы сынтаксіс <i>Git</i>:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          Нейкае апісаньне...

          <<<<<<< HEAD
          Дадатковае апісаньне з master.
          =======
          Паралельная зьмена з feature.
          >>>>>>> feature

          Працяг апісаньня...
        ]]></script>
        <p>Усё, што стаіць паміж радкамі <code><<<<<<< HEAD</code> і <code>=======</code>&nbsp;&mdash; гэта зьмены, якія былі зробленыя ў галіне «master», а тое, што стаіць паміж <code>=======</code> і <code>>>>>>>> feature</code>&nbsp;&mdash; гэта зьмены, якія былі зробленыя ў галіне «feature». Якім чынам канфлікт павінен быць выпраўлены, залежыць ад сытуацыі. Уявім, што фінальная вэрсія нашага файлу <code>README.txt</code> павінна ўтрымліваць зьмены з абедзьвюх галінаў, тады пакінем у файле такі зьмест:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          Нейкае апісаньне...

          Дадатковае апісаньне з master. Паралельная зьмена з feature.

          Працяг апісаньня...
        ]]></script>
        <p>Цяпер зробім адзнаку для <i>Git</i>, што канфлікт вырашаны, дадаўшы зьмены да індэксу праз каманду <code>git add README.txt</code>, і напрыканцы выканаем каміт: <code>git commit -m "Merge commit"</code>. Канфлікт вырашаны, зьмены з галіны «feature» зьлітыя ў асноўную галіну:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          $ git status
          # On branch master
          nothing to commit, working directory clean
        ]]></script>

        <h2 id="MergeAndRebase_CherryPick">Выбарачнае зьліцьцё</h2>
        <p>Існуе яшчэ каманда выбарачнага зьліцьця асобных камітаў адной галіны ў іншую:</p>
        <p><code>git cherry-pick 53212e5</code>&nbsp;&mdash; зьлівае каміт, хэш якога пазначаны апошнім у камандзе, зь іншай галіны ў цяперашнюю.</p>
        <p><code>git cherry-pick --edit 53212e5</code>&nbsp;&mdash; тое ж самае, што і папярэдняя каманда, але ў дадатак адкрыецца акно для зьмены камэнтара каміту, які мы зьліваем.</p>
        <p><code>git cherry-pick --no-commit 53212e5 55ae374</code>&nbsp;&mdash; адначасова зьлівае зьмены з двух камітаў іншай галіны ў цяперашнюю, пры гэтым зьлітыя зьмены не каміцяцца, але толькі індэксуюцца, каб пазьней закаміціць іх асобнай камандай.</p>
        <p><code>git cherry-pick -x 53212e5</code>&nbsp;&mdash; пры зьліцьці каміту, дадае адпаведны камэнтар з пазначэньнем поўнага хэшу гэтага каміту (мае сэнс толькі калі аддалены каміт зьліваецца ў лякальную галіну, інакш лякальны хэш ня будзе мець ніякага сэнсу для іншых удзельнікаў каманды).</p>
        <p><code>git cherry-pick --signoff 53212e5</code>&nbsp;&mdash; пры зьліцьці каміту, дадае інфармацыю пра аўтара зыходнага каміту і пра аўтара зьліцьця.</p>
        
        <h2 id="MergeAndRebase_Rebase">Перамяшчэньне</h2>
        <p>Для перамяшчэньня характэрна тое, што месца адгалінаваньня пэўнай галіны перамяшчаецца з аднаго каміту ў іншы. Гэты спосаб эквівалентны зьліцьцю, у сэнсе таго, што ў выніку будзем мець той жа самы стан актыўнай галіны. Адрозьненьнем жа зьяўляецца тое, што гісторыя камітаў будзе выглядаць не разгалінаванай, але лінейнай:
          <figure class="git_branching">
            <img alt="Ілюстрацыя перамяшчэньня галінаў" title="Ілюстрацыя перамяшчэньня галінаў" src="rebase_1.png"/>
          </figure>
        </p>
        <p>Каб зрабіць перамяшчэньне цяперашняй працоўнай галіны «feature» у асноўную «master», трэба выканаць наступную каманду (актыўнай галіной у гэты момант павінна быць «feature»&nbsp;&mdash; <code>git checkout feature</code>):</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          $ git rebase master
        ]]></script>
        <p>Калі паглыбіцца ў дэталі, то пры гэтым адбываецца наступнае: зьмены цяперашняй галіны, якія былі зроблены ў ёй пасьля адгалінаваньня ад «master», перамяшчаюцца ў часовае сховішча; пасьля гэтага паказальнік цяперашняй галіны перамяшчаецца ў <code>HEAD</code> галіны «master», а потым наноў ужываюцца зьмены з часовага сховішча.</p>
        <p>Калі ў часе зьліцьця <i>Git</i> сутыкнуўся з канфліктам, ён спыніцца і запытае выправіць канфлікт. Пасьля выпраўленьня (напрыклад у файле <code>README.txt</code>) трэба праіндэксаваць зьмены (зьвярніце ўвагу, што на дадзеным этапе мы знаходзімся ня ў пэўнай галіне, а пасярод перамяшчэньня, так бы мовіць у працоўным асяродку <i>Git</i>'а):</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          $ git add README.txt
        ]]></script>
        <p>а пасьля гэтага даць каманду скончыць працэс зьліцьця:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          $ git rebase --continue
        ]]></script>

        <h2 id="MergeAndRebase_InteractiveRebase">Інтэрактыўная перабудова</h2>
        <div class="refs">
          <ul>
            <li><a href="http://git-scm.com/book/en/v2/Git-Tools-Rewriting-History">ProGit</a></li>
          </ul>
        </div>
        <p>Хаця для выкананьня перабудовы камітаў выкарыстоўваецца тая ж каманда <code>rebase</code>, я вынес апісаньне ў асобны разьдзел, таму што сутнасьць перабудовы зусім іншая ў параўнаньні з перамяшчэньнем. Наступная каманда прапануе інтэрактыўную перабудову двух апошніх камітаў цяперашняй галіны.</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          $ git rebase -i HEAD~2
        ]]></script>
        <p>У выніку ў новым тэкставым акне будзе выведзена наступная інфармацыя для магчымай праўкі:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          pick f7f3f6d changed my name a bit
          pick 310154e updated README formatting and added blame
          pick a5f4a0d added cat-file

          # Rebase 710f0f8..a5f4a0d onto 710f0f8
          #
          # Commands:
          #  p, pick = use commit
          #  r, reword = use commit, but edit the commit message
          #  e, edit = use commit, but stop for amending
          #  s, squash = use commit, but meld into previous commit
          #  f, fixup = like "squash", but discard this commit log message
          #  x, exec = run command (the rest of the line) using shell
          #
          # These lines can be re-ordered; they are executed from top to bottom.
          #
          # If you remove a line here THAT COMMIT WILL BE LOST.
          #
          # However, if you remove everything, the rebase will be aborted.
          #
          # Note that empty commits are commented out
        ]]></script>
        <p>Калі ўсё пакінуць як ёсьць (каманду <code>pick</code>), тады 2 апошніх каміта будуць ізноў ужыты па новай. Але ёсьць і іншыя магчымасьці (чытай ніжэй).</p>

        <h3 id="MergeAndRebase_InteractiveRebase_ReorderAndExclude">Перастаноўка і выключэньне</h3>
        <p>Самае простае, што можна зрабіць&nbsp;&mdash; гэта зьмяніць парадак камітаў ці ўвогуле выключыць які(-я)-небудзь зь іх. Для гэтага зьменім першыя тры радкі ў зьявіўшымся акне на наступнае:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          pick 310154e updated README formatting and added blame
          pick f7f3f6d changed my name a bit
        ]]></script>
        <p>У гэтым выпадку, калі захаваць зьмены ў акне і закрыць яго, каміты <code>310154e</code> і <code>f7f3f6d</code> будуць памененыя месцамі, а каміт <code>a5f4a0d</code> увогуле будзе выключаны і не ўжыты.</p>

        <h3 id="MergeAndRebase_InteractiveRebase_Reword">Замена камэнтароў да камітаў</h3>
        <p>Наступнае, што можна зрабіць&nbsp;&mdash; гэта зьмяніць камэнтар да камітаў. Для гэтага ужывем каманду <code>reword</code> для таго каміту, камэнтар якога жадаем зьмяніць:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          reword f7f3f6d changed my name a bit
          pick 310154e updated README formatting and added blame
          pick a5f4a0d added cat-file
        ]]></script>
        <p>У гэтым выпадку, калі захаваць зьмены ў акне і закрыць яго, для каміта <code>f7f3f6d</code> будзе запытаны новы камэнтар.</p>

        <h3 id="MergeAndRebase_InteractiveRebase_Squash">Злучэньне камітаў</h3>
        <p>Таксама можна злучыць некалькі камітаў у адзін. Для гэтага ужывем каманду <code>squash</code>:</p>
        <script type="syntaxhighlighter" class="brush: shell;"><![CDATA[
          pick f7f3f6d changed my name a bit
          squash 310154e updated README formatting and added blame
          squash a5f4a0d added cat-file
        ]]></script>
        <p>У гэтым выпадку, калі захаваць зьмены ў акне і закрыць яго, зьмены камітаў <code>310154e</code> і <code>a5f4a0d</code> будуць злучаны са зьменамі каміту <code>f7f3f6d</code> і ўсе яны будуць ужыты як адзін каміт.</p>

        <h3 id="MergeAndRebase_InteractiveRebase_Edit">Рэдагаваньне камітаў</h3>
        <p>Пры дапамозе каманды <code>edit</code> асобныя каміты могуць быць разьбітыя на некалькі камітаў ці ўвогуле быць зьмененыя цалкам (больш падрабязна глядзі адпаведны <a href="http://git-scm.com/book/en/v2/Git-Tools-Rewriting-History">разьдзел кнігі <i>ProGit</i></a>)</p>
      </section>

      <section>
        <h1 id="ViewingCommitHistory">Прагляд гісторыі зьменаў</h1>
        <div class="refs">
          <ul>
            <li><a href="http://git-scm.com/book/ru/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2">ProGit</a></li>
          </ul>
        </div>
        <aside>Каманды ў наступных разьдзелах не зьяўляюцца ключавымі, таму прыводзяцца тут тэзісна, без асаблівых падрабязнасьцяў.</aside>
        <p><code>git log --pretty=oneline</code>&nbsp;&mdash; выводзіць кожны запіс логу у адзін радок.</p>
        <p><code>git log --oneline --graph</code>&nbsp;&mdash; выводзіць кожны запіс логу у адзін радок пры гэтым паказвае гісторыю камітаў у выглядзе графу.</p>
        <p>Пры вывадзе логу можна задаваць якім прамежкам часу трэба абмежавацца:</p>
        <p><code>git log --until=1.minute.ago</code>&nbsp;&mdash; усе логі ад пачатку і да кропкі часу, якая была 1 хвіліну назад.</p>
        <p><code>git log --since=1.day.ago</code>&nbsp;&mdash; усе логі за апошнія суткі.</p>
        <p><code>git log --since=1.month.ago --until=2.weeks.ago</code>&nbsp;&mdash; усе логі пачынаючы ад кропкі часу 1 месяц назад і да кропкі часу 2 тыдні назад.</p>
        <p><code>git log --since=2000-01-01 --until=2012-12-21</code>&nbsp;&mdash; усе логі пачынаючы ад даты 01.01.2010 і да даты 21.12.2012.</p>
        <p>---</p>
        <p>Пры запыце паказаць зьмены можна карыстацца наступнымі магчымасьцямі:</p>
        <p><code>git diff HEAD^</code>&nbsp;&mdash; паказаць чым адрозьніваецца цяперашні стан ад перадапошняга каміту.</p>
        <p><code>git diff HEAD^^</code>&nbsp;&mdash; паказаць чым адрозьніваецца цяперашні стан ад стану ў 3 каміты назад.</p>
        <p><code>git diff HEAD~5</code>&nbsp;&mdash; паказаць чым адрозьніваецца цяперашні стан ад стану ў 5 камітаў назад.</p>
        <p><code>git diff HEAD^..HEAD</code>&nbsp;&mdash; паказаць чым адрозьніваецца перадапошні каміт ад апошняга.</p>
        <p><code>git diff 4fb063f..f5a6ff9</code>&nbsp;&mdash; паказаць чым адрозьніваюцца 2 каміта па скаротам іх хэшаў.</p>
        <p><code>git diff master temp</code>&nbsp;&mdash; таксама можна параўнаць дзьве галіны.</p>
        <p>---</p>
        <p><code>git blame index.html --date short</code>&nbsp;&mdash; паказвае падрабязную інфармацыю па ўсёй гісторыі зьменаў ў пэўным файле.</p>
        <br />
        <p>Ачыстка гісторыі (<i>purging history</i>). Часьцей за ўсё яна абгрунтавана датычна лякальнага рэпазыторыю, альбо цэнтральнага калі напрыклад выдаляецца вялікі файл, каб гісторыя не захоўвала яго, ці выдаляецца файл, які парушае аўтарскія правы - таксама, каб гісторыя не захоўвала яго. У астатніх выпадках зьмена гісторыі цэнтральнага рэпазыторыю непажадана.</p>
        <p><code>git filter-branch --tree-filter 'rm -f passwords.txt'</code>&nbsp;&mdash; <i>Git</i> будзе вымаць з рэпазыторыю ў працоўную тэчку кожны з камітаў, запускаць пазначаную каманду (выдаленьне файлу <code>passwords.txt</code> з кораня праекта) і затым наноў рабіць гэты каміт. Опцыя <code>-f</code> патрэбная на выпадак, калі нейкі каміт не ўтрымлівае файлу <code>passwords.txt</code>, каб выкананьне ачысткі гісторыі не «зламалася» з-за гэтага.</p>
        <p><code>git filter-branch --tree-filter 'rm -f passwords.txt' -- --all</code>&nbsp;&mdash; тое ж, што і папярэдняя каманда, але выдаленьне файлу будзе адбывацца ня толькі ўва ўсіх камітах актыўнай галіны, але ўвогуле ўсіх галінаў праекта. Замест <code>--all</code> можна пазначыць любую галіну, у якой мы жадаем пачысьціць гісторыю.</p>
        <p>Каб <i>Git</i> не вымаў кожны з камітаў і не каміціў яго наноў, а зрабіў чыстку наўпрост у рэпазыторыі каманду можна зьмяніць наступным чынам:</p>
        <p><code>git filter-branch --index-filter 'git rm --cached --ignore-unmatch passwords.txt'</code>&nbsp;&mdash; прызначэньне опцыі <code>--ignore-unmatch</code> аналягічна прызначэньню опцыі <code>-f</code> у камандах, прыведзеных вышэй.</p>
        <p>Калі робіцца чыстка гісторыі, <i>Git</i> стварае рэзэрвовую копію дрэва гісторыі. Пры спробе запусьціць яшчэ адну чыстку, ён выдасьць паведамленьне, што не можа стварыць яшчэ адзін бэкап. Каб пазьбегнуць гэтага можна дадаць опцыю <code>-f</code> у саму каманду <code>filter-branch</code>:</p>
        <p><code>git filter-branch -f --tree-filter 'rm -f passwords.txt'</code></p>
        <p>У выніку чысткі гісторыі некаторыя каміты могуць стаць пустымі. Напрыклад, нейкі каміт утрымліваў толькі выдаленьне нейкага аднаго файлу, а мы потым гэты файл выдалілі з гісторыі. Каб увогуле сьцерці такія пустыя каміты з гісторыі, можна скарыстацца наступнай камандай:</p>
        <p><code>git filter-branch -f --prune-empty -- --all</code></p>
        <p><code>git reflog</code>&nbsp;&mdash; тое ж, што і звычайны лог, але выводзіць абсалютна ўсю гісторыю зьмены <code>HEAD</code>, улічваючы нават выдаленыя каміты.</p>
        <p><code>git log --walk-reflogs</code>&nbsp;&mdash; тое ж, што <code>reflog</code>, праз каманду звычайнага логу.</p>
      </section>

      <section>
        <h1 id="Tags">Тэгі</h1>
        <p>У <i>Git</i> тэгамі завуцца спасылкі на пэўныя каміты, звычайна для адсечкі рэлізаў.</p>
        <p><code>git tag</code>&nbsp;&mdash; выводзіць сьпіс тэгаў.</p>
        <p><code>git tag -a v0.0.3 -m "version 0.0.3"</code>&nbsp;&mdash; стварае тэг «v0.0.3» з пазнакай адпаведнага камэнтару.</p>
        <p><code>git push --tags</code>&nbsp;&mdash; пераносіць новыя тэгі на аддалены рэпазыторый.</p>
      </section>

      <section>
        <h1 id="Staching">Часовае сховішча</h1>
        <p><code>git stash save</code>&nbsp;&mdash; захоўвае ў часовым сховішчы яшчэ ня скончаныя і, адпаведна, не зафіксаваныя зьмены ў адной з галінаў, перад тым як пераключыцца ў іншую (напрыклад, узьнікла такая неадкладная патрэба). Гэты пачак захаваных зьменаў атрымлівае імя выгляду <code>stash@{0}</code> і такіх пачкаў раней захаваных зьменаў можа быць некалькі (мяняюцца нумары ў дужках у імені).</p>
        <p><code>git stash list</code>&nbsp;&mdash; выводзіць сьпіс усіх зьменаў, якія былі раней зьмешчаны ў часовае сховішча.</p>
        <p><code>git stash apply</code>&nbsp;&mdash; бярэ зьмены з часовага сховішча пад імем <code>stash@{0}</code> і вяртае іх ў актыўную галіну (АЛЕ ў часовым сховішчы гэтыя зьмены працягваюць заставацца). Калі трэба выняць зьмены пад іншым імем, гэтае імя дадаецца ў каманду апошнім аргумэнтам.</p>
        <p><code>git stash drop</code>&nbsp;&mdash; выдаленьне зьменаў пад імем <code>stash@{0}</code> з часовага сховішча.  Калі трэба выдаліць зьмены пад іншым імем, гэтае імя дадаецца ў каманду апошнім аргумэнтам.</p>
        <p><code>git stash pop</code>&nbsp;&mdash; аб'ядноўвае дзьве папярэднія каманды ў адну (спачатку выконвае <code>git stash apply</code>, а затым <code>git stash drop</code>).</p>
        <p><code>git stash save --keep-index</code>&nbsp;&mdash; захоўвае ў часовым сховішчы зьмены, за выключэньнем ужо праіндэксаваных, якія пакідаюцца ў актыўнай галіне для магчымага каміту.</p>
        <p><code>git stash save --include-untracked</code>&nbsp;&mdash; захоўвае ў часовым сховішчы зьмены, за якімі <i>Git</i> ужо сочыць, і ў дадатак новыя файлы, якія яшчэ не былі дададзеныя ў рэпазыторый.</p>
        <p><code>git stash save "Some comment"</code>&nbsp;&mdash; пры захоўваньні зьменаў у часовым сховішчы, да іх можна дадаць камэнтар.</p>
        <p><code>git stash list --stat</code>&nbsp;&mdash; акрамя самога сьпісу зьменаў выводзіць яшчэ дадатковую інфармацыю пра іх.</p>
        <p><code>git stash show</code>&nbsp;&mdash; выводзіць дадатковую інфармацыю пра зьмену, захаваную ў часовым сховішчы.</p>
        <p><code>git stash clear</code>&nbsp;&mdash; выдаляе ўсе зьмены з часовага сховішча.</p>
      </section>

      <section>
        <h1 id="Submodules">Падмодулі</h1>
        <p>Падмодулі (<i>submodules</i>)&nbsp;&mdash; гэта асобныя рэпазыторыі, якія прызначаны для захоўваньня даных, якія выкарыстоўваюцца некалькімі праектамі. Можна іх яшчэ назваць бібліятэкамі. Ствараюцца падмодулі гэтак жа сама, як і звычайныя рэпазыторыі, а спаслацца на іх зь іншага праекту (рэпазыторыю) можна наступным чынам:</p>
        <p><code>git submodule add git@example.com:css.git</code>&nbsp;&mdash; дадзеная каманда створыць асобную тэчку <code>css</code> у корані цяперашняга рэпазыторыю і спампуе туды зьмест падмодуля. Пасьля выкананьня гэтай каманды трэба закаміціць зьмены і запушыць іх на аддалены рэпазыторый.</p>
        <p>Зьвязваньне цяперашняга рэпазыторыю з падмодулем стварае толькі загатоўку паўнавартаснай працы, што трэба зрабіць далей:</p>
        <p><code>cd css</code>&nbsp;&mdash; уваходзім у створаную тэчку.</p>
        <p><code>git checkout master</code>&nbsp;&mdash; ...і ствараем асноўную галіну. Пасьля гэтага мы можам рабіць неабходныя зьмены ў падмодулі і каміціць іх звычайным чынам:</p>
        <p><code>git commit -am "Update menu font"</code>&nbsp;&mdash; ... а пасьля пушыць зьмены ў падмодулі на сэрвэр: <code>git push"</code>.</p>
        <p>Але гэта ня ўсё, пасьля гэтага трэба вярнуцца ў бацькоўскі рэпазыторый: <code>cd ..</code>, праіндэксаваць зьмены ў гэтым бацькоўскім рэпазыторыі (зьмяніўся зьмест падмодулю): <code>git commit -m "Update menu fonr in css"</code> і запушыць іх на сэрвэр: <code>git push</code>.</p>
        <p>Калі нехта клянуе сабе аддалены рэпазыторый, які ўтрымлівае падмодулі, перад пачаткам лякальнай працы з праектам неабходна запусьціць гэтую каманду: <code>git submodule init</code>, каб <i>Git</i> зрабіў усе неабходныя наладкі, а пасьля гэтую каманду: <code>git submodule update</code>, каб <i>Git</i> сьцягнуў зьмест гэтых падмодуляў.</p>
        <p>Падобна, калі 2 удзельніка каманды працуюць над рэпазыторыям, які ўлучае ў сябе падмодуль, і адзін зь іх робіць зьмену ў падмодулі, тады іншаму недастаткова проста сьцягнуць зьмены як звычайна: <code>git pull</code>, але трэба яшчэ дадаткова зрабіць лякальнае аднаўленьне падмодулю: <code>git submodule update</code>.</p>
        <p>У выпадку падмодуляў вельмі важна памятаць, што пушыць трэба 2 разы&nbsp;&mdash; адзін раз сам падмодуль, іншы раз бацькоўскі рэпазыторый. Праблема ў тым, што <i>Git</i> дазволіць запушыць бацькоўскі рэпазыторый без папярэдняга пушаньня падмодулю, і ў гэтым выпадку далейшая праца ўсёй каманды будзе спынена, пакуль памылка не будзе выпраўлена. Каб не зрабіць такой памылкі, можна заўсёды пушыць бацькоўскі рэпазыторый з наступнай опцыяй, якая не дазволіць гэта зрабіць, пакуль не запушаны падмодуль: <code>git push --recurse-submodules=check</code>.</p>
        <p>Але ёсьць яшчэ больш зручны спосаб не зрабіць памылкі: <code>git push --recurse-submodules=on-demand</code>. Гэтая каманда аўтаматычна запушыць усе падмодулі пры неабходнасьці.</p>
        <p>Для доўгіх камандаў, як у папярэдніх выпадках, можна рабіць скароты: <code>git config alias.pushall "push --recurse-submodules=on-demand"</code>. Наступным разам дастаткова будзе набраць: <code>git pushall</code>, каб <i>Git</i> запушыў падмодулі і бацькоўскі рэпазыторый за адну каманду.</p>
        <br />

      </section>

      <footer>
        <div id="copyright">
          <p>Copyright &copy; 2010-2015 <a href="http://www.yurtsevich.info">yurtsevich.info</a></p>
          <p>
            <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.be">
              <img src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png"
                  style="border-style: none;" alt="Common Creatives. Attribution + Noncommercial (by-nc)" />
            </a>
          </p>
          <p><cite>Тэхнічны даведнік па Git</cite> публікуецца пад ліцэнзіяй <cite>Commons Creative Attribution-NonCommercial 3.0 Unported (CC BY-NC 3.0)</cite>. Вы вольны ў тым, як выкарыстоўваць гэтую працу, у тым ліку капіяваць, распаўсюджваць і зьмяняць яе на свой капыл. Але <strong>толькі ў некамэрцыйных мэтах</strong> і <strong>абавязкова з пазнакай <a href="http://yurtsevich.info/refs/gitRef/">крыніцы</a></strong> матэрыялу.</p>
        </div>
      </footer>

      <!-- Disqus BEGIN -->
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//git-be.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
      <noscript>Калі ласка, актывізуйце JavaScript каб бачыць <a href="http://disqus.com/?ref_noscript">камэнтары праз сыстэму Disqus.</a></noscript>
      <!-- Disqus END -->

    </article>
  </div> <!--! end of #container -->

  <div id="comments_link" class="uv-icon"><a href="#disqus_thread" title="Перайсьці да блёку з камэнтамі"></a></div>

  <!-- Javascript at the bottom for fast page loading -->

  <!-- Uservoice BEGIN -->
  <script>
    // Include the UserVoice JavaScript SDK (only needed once on a page)
    UserVoice=window.UserVoice||[];(function(){var uv=document.createElement('script');uv.type='text/javascript';uv.async=true;uv.src='//widget.uservoice.com/Of84cKdV6fJsdTM8rZd0g.js';var s=document.getElementsByTagName('script')[0];s.parentNode.insertBefore(uv,s)})();

    //
    // UserVoice Javascript SDK developer documentation:
    // https://www.uservoice.com/o/javascript-sdk
    //

    // Set colors
    UserVoice.push(['set', {
      accent_color: '#448dd6',
      trigger_color: 'white',
      trigger_background_color: 'rgba(46, 49, 51, 0.6)'
    }]);

    // Add default trigger to the bottom-right corner of the window:
    UserVoice.push(['addTrigger', { mode: 'contact', trigger_position: 'bottom-right' }]);

    // Or, use your own custom trigger:
    //UserVoice.push(['addTrigger', '#id', { mode: 'contact' }]);

    // Autoprompt for Satisfaction and SmartVote (only displayed under certain conditions)
    UserVoice.push(['autoprompt', {}]);
  </script>
  <!-- Uservoice END -->

  <!-- Grab Google CDN's jQuery. fall back to local if necessary -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="../js/libs/jquery-1.7.1.min.js"%3E%3C/script%3E'))</script>

  <script src="../js/index.js"></script>
  <script src="../js/libs/jquery.tree.js"></script>

  <script src="../js/libs/waypoints.min.js"></script>
  <script src="../js/ref.js"></script>

  <script src="../js/libs/xregexp.js"></script>
  <script src="../js/libs/shCore.js"></script>
  <script src="../js/libs/shAutoloader.js"></script>
  <script type="text/javascript">
    function path()
    {
      var args = arguments,
          result = []
          ;

      for(var i = 0; i < args.length; i++)
          result.push(args[i].replace('@', '../js/libs/'));

      return result
    };

    SyntaxHighlighter.autoloader.apply(null, path(
      'applescript            @shBrushAppleScript.js',
      'actionscript3 as3      @shBrushAS3.js',
      'bash shell             @shBrushBash.js',
      'coldfusion cf          @shBrushColdFusion.js',
      'cpp c                  @shBrushCpp.js',
      'c# c-sharp csharp      @shBrushCSharp.js',
      'css                    @shBrushCss.js',
      'delphi pascal          @shBrushDelphi.js',
      'diff patch pas         @shBrushDiff.js',
      'erl erlang             @shBrushErlang.js',
      'groovy                 @shBrushGroovy.js',
      'java                   @shBrushJava.js',
      'jfx javafx             @shBrushJavaFX.js',
      'js jscript javascript  @shBrushJScript.js',
      'perl pl                @shBrushPerl.js',
      'php                    @shBrushPhp.js',
      'text plain             @shBrushPlain.js',
      'py python              @shBrushPython.js',
      'ruby rails ror rb      @shBrushRuby.js',
      'sass scss              @shBrushSass.js',
      'scala                  @shBrushScala.js',
      'sql                    @shBrushSql.js',
      'vb vbnet               @shBrushVb.js',
      'xml xhtml xslt html    @shBrushXml.js'
    ));

    SyntaxHighlighter.defaults['toolbar'] = false;
    SyntaxHighlighter.all();
  </script>

  <!-- asynchronous google analytics: mathiasbynens.be/notes/async-analytics-snippet
       change the UA-XXXXX-X to be your site's ID -->
  <script>
   var _gaq = [['_setAccount', 'UA-18077954-1'], ['_trackPageview']];
   (function(d, t) {
    var g = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    g.async = true;
    g.src = ('https:' == location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g, s);
   })(document, 'script');
  </script>

  <script src="http://static.getclicky.com/js" type="text/javascript"></script>
  <script type="text/javascript">clicky.init(17136);</script>
</body>
</html>