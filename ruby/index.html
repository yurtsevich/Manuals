---
title: Даведнік па Ruby
description: Даведнік па Ruby па-беларуску
disqus_shortname: davednik-pa-ruby
---

{% include base_path %}

<section>
  <h1 id="TODO">TODO</h1>
  <p><a href="https://github.com/markets/awesome-ruby">Awesome Ruby</a>&nbsp;&ndash; a collection of awesome Ruby libraries, tools, frameworks and software.</p>
  <p><a href="https://blog.engineyard.com/2015/five-ruby-methods-you-should-be-using">Five Ruby Methods You Should Be Using</a></p>
  <p><a href="https://github.com/eventmachine/eventmachine">Eventmachine: Event-Driven I/O Framework/Engine</a></p>
  <p><a href="http://rubysource.com/net-to-ruby-learning-how-to-write-tests-part-ii/?utm_medium=email&utm_campaign=RubySource+20th+December&utm_content=RubySource+20th+December+CID_f2af5bc20b708cababf91ab81601f637&utm_source=Newsletter&utm_term=NET+to+Ruby+Learning+How+to+Write+Tests+Part+II">NET to Ruby: Learning How to Write Tests, Part II</a>&nbsp;&ndash; частку гэтага матэрыялу варта перанесьці ў даведнік па Rails</p>
  <p><a href="http://rubysource.com/functional-programming-techniques-with-ruby-part-i/?utm_medium=email&utm_campaign=RubySource+21st+feb&utm_content=RubySource+21st+feb+CID_fccd7cb097c88cc1751a6adfa2a736c3&utm_source=Newsletter&utm_term=Functional+Programming+Techniques+with+Ruby">Functional Programming Techniques With Ruby: Part I</a></p>
  <p><a href="http://rubysource.com/using-a-graph-database-with-ruby-part-i-introduction/?utm_medium=email&utm_campaign=RubySource+June+26+2012&utm_content=RubySource+June+26+2012+CID_060309c63435e60d57d8bbf94d827e8e&utm_source=Newsletter&utm_term=Using+a+Graph+Database+with+Ruby+Part+I">Using a Graph Database with Ruby. Part I: Introduction</a></p>
</section>

<section>
  <h1 id="Links">Карысныя спасылкі</h1>
  <h2 id="Links_Home">Хатняя старонка</h2>
  <p><a href="http://www.ruby-lang.org/">http://www.ruby-lang.org</a></p>

  <h2 id="Links_Docs">Дакумэнтацыя</h2>
  <p><a href="http://ruby-doc.org/">http://ruby-doc.org</a>&nbsp;&ndash; афіцыйная старонка, на якой сабраныя спасылкі да рознага кшталту дакумэнтацыі і літаратуры.</p>

  <h2 id="Links_API">API</h2>
  <p>Ядро мовы (вэр. 2.1.1): <a href="http://ruby-doc.org/core">http://ruby-doc.org/core</a></p>
  <p>Стандартная бібліятэка (<i>StdLib</i>): <a href="http://www.ruby-doc.org/stdlib/">http://www.ruby-doc.org/stdlib</a></p>
  <p>Інтэрактыўная шпаргалка на <b>OverAPI</b>: <a href="http://overapi.com/ruby/">http://overapi.com/ruby/</a></p>

  <h2 id="Links_CodingStyle">Стыль коду</h2>
  <p>Стыль аздабленьня коду ад <b>GitHub</b>: <a href="https://github.com/styleguide/ruby">https://github.com/styleguide/ruby</a></p>

  <h2 id="Links_Refs">Даведнікі і кнігі</h2>
  <h3 id="Links_Refs_Beginners">Пачаткоўцам</h3>
  <p><a href="http://www.rubyist.net/~slagell/ruby/">Ruby user's guide</a></p>
  <p><a href="http://rubylearning.com/satishtalim/tutorial.html">Core Ruby Programming</a></p>
  <p><a href="http://mislav.uniqpath.com/poignant-guide/">Poignant-guide</a>&nbsp;&ndash; сьцёбны, арыгінальны, але прыдатны толькі для першапачатковага паглыбленьня ў мову вучэбнік.</p>
  <p><a href="http://ruby.learncodethehardway.org/book/">Learn Ruby The Hard Way</a></p>

  <h3 id="Links_Refs_Intermediate">Адмыслоўцам</h3>
  <p><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/">Programming Ruby</a>&nbsp;&ndash; электронны варыянт першага выданьня адпаведнай кнігі ад <a href="http://pragprog.com/">The Pragmatic Programmers</a>.</p>
  <p><a href="http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177">The Ruby Programming Language</a> (першае выданьне папяровай кнігі, напісанай <a href="http://www.amazon.com/David-Flanagan/e/B000APEZR4" title="Старонка, прысьвечаная Дэвіду Флэнэгэну на Amazon.com">Дэвідам Флэнэгэнам</a> і <a href="http://www.amazon.com/Yukihiro-Matsumoto/e/B001IGNN6I" title="Старонка, прысьвечаная Юкіхіро Мацумото на Amazon.com">Юкіхіро Мацумото</a> ад выдавецтва <a href="http://oreilly.com/" title="Хатняя старонка выдавецтва O'Reilly">O'Reilly</a>&nbsp;&ndash; на мой погляд лепшая крыніца, з тых што мне трапляліся, паглыбленага вывучэньня <i>Ruby</i>, але на жаль электроннага варыянту няма ў вольным доступе).</p>

  <h2 id="Links_Courses">Курсы</h2>
  <p>Курс на <a href="http://www.codecademy.com/">codecademy.com</a>: <a href="http://www.codecademy.com/tracks/ruby">http://www.codecademy.com/tracks/ruby</a></p>
  <p><i>Інтэрактыўныя ўрокі</i> для пачаткоўцаў на <b>LearnStreet.com</b>: <a href="http://www.learnstreet.com/lessons/study/ruby">http://www.learnstreet.com/lessons/study/ruby</a></p>
  <p>Сэрыя курсаў на <a href="http://rubymonk.com/">rubymonk.com</a></p>

  <h2 id="Links_Blogs">Блогі</h2>
  <p>Апошнія <i>Ruby &amp; Rails</i> навіны на <b>envylabs.com</b>: <a href="http://ruby5.envylabs.com/">http://ruby5.envylabs.com/</a></p>
  <p>Functional Ruby, Code Beauty, and Ruby Internals&nbsp;&ndash; <a href="http://rubylove.io/">RubyLove</a></p>

  <h2 id="Links_Gems">Gems</h2>
  <p>Хатняя старонка: <a href="http://rubygems.org/">http://rubygems.org</a></p>
  <p>Як шукаць і ўсталёўваць бібліятэкі: <a href="http://www.ruby-lang.org/en/libraries/">http://www.ruby-lang.org/en/libraries</a></p>
  <p>Bundler: <a href="http://gembundler.com/">http://gembundler.com</a></p>
</section>

<section>
  <h1 id="Versions">Вэрсіі Ruby</h1>
  <p>Перад тым, як перайсьці да разгляду самой мовы, спынімся на гісторыі зьменаў яе вэрсіяў.</p>

  <h2 id="Versions_History">Гісторыя</h2>
  <div class="refs">
    <ul>
      <li><a href="https://www.ruby-lang.org/en/news">Home</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)#History">Wiki</a></li>

    </ul>
  </div>
  <table>
    <thead>
    <tr>
      <th colspan="2">Вэрсія</th>
      <th rowspan="2">Выхад</th>
      <th rowspan="2">Закрыцьцё</th>
      <th rowspan="2">Асаблівасьць</th>
    </tr>
    <tr>
      <th>Major</th>
      <th>Minor</th>
    </tr>
    </thead>
    <tbody>
    <tr class="lightgreyed">
      <td colspan="2">1.8</td>
      <td>08.2003</td>
      <td>06.2013</td>
      <td>Гэта была ня першая вэрсія, але тая, якая прыйшлася на пачатак росту папулярнасьці <i>Ruby</i>. На дадзены момант яна аб'яўлена не пажаданай да выкарыстаньня і больш не падтрымліваецца.</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.1</td>
      <td>12.2003</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.2</td>
      <td>12.2004</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.3</td>
      <td>09.2005</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.4</td>
      <td>12.2005</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.5</td>
      <td>08.2006</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.6</td>
      <td>03.2007</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.7</td>
      <td>05.2008</td>
      <td></td>
      <td>Фікс багаў, перанос некаторых паляпшэньняў, якія плянаваліся для 1.9, паляпшэньне прадукцыйнасьці.</td>
    </tr>
    <tr>
      <td colspan="2">1.9</td>
      <td>12.2007</td>
      <td></td>
      <td>Прынцыпова новая, палепшаная вэрсія, якая не мела зваротнай сумяшчальнасьці з вэрсіяй 1.8. Зьмены ў сэмантыцы, у ядры мовы, у базавых клясах. Вэрсія 1.9.0 не зьяўлялася стабільным рэлізам, але толькі рэліз-кандыдатам.</td>
    </tr>
    <tr>
      <td></td>
      <td>1.9.1</td>
      <td>01.2009</td>
      <td></td>
      <td>Пераважна фікс багаў у параўнаньні з 1.9.0. Першы стабільны рэліз вэрсіі 1.9.</td>
    </tr>
    <tr>
      <td></td>
      <td>1.9.2</td>
      <td>08.2010</td>
      <td></td>
      <td>Шмат новых мэтадаў, новы <i>Socket API</i>, новыя кадоўкі, новая кляса <i>Random</i>, кляса <i>Time</i> перапрацавана, і іншае</td>
    </tr>
    <tr>
      <td></td>
      <td>1.9.3</td>
      <td>10.2011</td>
      <td></td>
      <td>Шмат новых і палепшаных мэтадаў</td>
    </tr>
    <tr>
      <td>2.0</td>
      <td>2.0.0</td>
      <td>02.2013</td>
      <td></td>
      <td>Шмат новых асаблівасьцяў і паляпшэньняў.</td>
    </tr>
    <tr>
      <td>2.1</td>
      <td>2.1.0</td>
      <td>12.2013</td>
      <td></td>
      <td>Пераважна паляпшэньне прадукцыйнасьці</td>
    </tr>
    <tr>
      <td></td>
      <td>2.1.1</td>
      <td>02.2014</td>
      <td></td>
      <td>Пераважна фікс багаў і паляпшэньне прадукцыйнасьці</td>
    </tr>
    </tbody>
  </table>

  <h2 id="Versions_RVM">Кіраваньне вэрсіямі (RVM)</h2>
  <div class="refs">
    <ul>
      <li><a href="http://rvm.io/">rvm.io</a></li>
      <li><a href="http://sirupsen.com/get-started-right-with-rvm/">Get started</a></li>
      <li><a href="http://cheat.errtheblog.com/s/rvm">Cheat sheet</a></li>
    </ul>
  </div>
  <aside>Рэалізацыя <i>RVM</i> існуе толькі для <i>Linux</i>-сыстэм. Карыстальнікам <i>Windows</i> варта зьвярнуць увагу на прыладу <a href="https://github.com/vertiginous/pik/">pik</a>.</aside>
  <p>З улікам таго, што новыя вэрсіі зьяўляюцца прыкладна раз на год, складана сабе ўявіць, што пры распрацоўцы нейкага праекту можна абысьціся адной вэрсіяй <i>Ruby</i>. Гэта магчыма хіба толькі для вельмі маленькіх праектаў, якія магчыма ад пачатку да канчатковага рэлізу распрацаваць за тэрмін да году. У астатніх выпадках, верагодней за ўсё, трэба будзе пачынаць з адной вэрсіі, а потым адаптаваць праграму пад іншую(-ыя). Яшчэ ў больш складанай сытуацыі будзе знаходзіцца распрацоўшчык, якому адначасова трэба працаваць на розныя праекты, якія высоўваюць адрозныя патрабаваньні што да вэрсіі <i>Ruby</i>. Ствараць асобныя віртуальныя машыны пад кожны з праектаў з сваім спэцыфічным асяродзьдзем, мякка кажучы ня вельмі зручна. І тут прыходзіць на дапамогу незаменнае прыстасаваньне пад назвай <a href="http://rvm.io/"><i>Ruby Version Manager</i></a> (альбо скарочана <i>RVM</i>).</p>

  <h3 id="Versions_RVM_Installing">Усталяваньне <i>RVM</i></h3>
  <p>Каб усталяваць <i>RVM</i> трэба запусьціць каманду:</p>

  <pre><code class="language-bash">
$ \curl -sSL https://get.rvm.io | bash -s stable
</code></pre>

  <p>Больш падрабязна пра розныя опцыі ўсталяваньня можна паглядзець <a href="http://rvm.io/rvm/install">тут</a>.</p>
  <table>
    <caption>Дзе <i>RVM</i> захоўвае якія даныя</caption>
    <thead>
    <tr>
      <th>Тэчка</th>
      <th>Прызначэньне</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>~/.rvm</code></td>
      <td>Хатняя тэчка <i>RVM</i></td>
    </tr>
    <tr>
      <td><code>~/.rvm/rubies</code></td>
      <td>Тэчка з усталяванымі вэрсіямі <i>Ruby</i></td>
    </tr>
    <tr>
      <td><code>~/.rvm/gems</code></td>
      <td>Тэчка з усталяванымі наборамі гемаў для кожнай з вэрсіі <i>Ruby</i></td>
    </tr>
    <tr>
      <td><code>~/.rvm/gemsets</code></td>
      <td>Тэчка наладак кожнага з набору гемаў</td>
    </tr>
    </tbody>
  </table>

  <h3 id="Versions_RVM_Upgrading">Абнаўленьне <i>RVM</i></h3>
  <div class="refs">
    <ul>
      <li><a href="http://rvm.io/rvm/upgrading">rvm.io</a></li>
    </ul>
  </div>
  <p>Калі пройдзе пэўны час, як вы ўжо працуеце з <i>RVM</i>, можа выйсьці новая альбо нават некалькі новых вэрсіяў прылады. Абнавіцца да новай вэрсіі можна пры дапамозе каманд:</p>

  <pre><code class="language-bash">
$ rvm get stable    # абнаўленьне да апошняй стабільнай вэрсіі
$ rvm get head      # абнаўленьне да апошняй працоўнай вэрсіі
</code></pre>

  <h3 id="Versions_RVM_ListingAvailableVersions">Сьпіс даступных вэрсіяў</h3>
  <p>Каб даведацца якія вэрсіі <i>Ruby</i> можа ўсталяваць <i>RVM</i>, трэба скарыстацца камандай:</p>

  <pre><code class="language-bash">
$ rvm list known
</code></pre>

  <h3 id="Versions_RVM_InstallingNewRubies">Усталяваньне новых вэрсіяў</h3>
  <div class="refs">
    <ul>
      <li><a href="http://rvm.io/rubies/installing">rvm.io</a></li>
    </ul>
  </div>
  <p>Каб усталяваць у сыстэму новую вэрсію <i>Ruby</i>, трэба скарыстацца камандай:</p>

  <pre><code class="language-bash">
$ rvm install 2.1.1   # Дзе 2.1.1 – адна з вэрсіяў Ruby, якая была выведзена
                      # на запыт да сьпісу даступных вэрсіяў
                      # (гл. папярэдні разьдзел)
</code></pre>

  <h3 id="Versions_RVM_RemovingInstalledRubies">Выдаленьне ўсталяваных вэрсіяў</h3>
  <div class="refs">
    <ul>
      <li><a href="http://rvm.io/rubies/removing">rvm.io</a></li>
    </ul>
  </div>
  <p>Каб выдаліць раней усталяваную вэрсію <i>Ruby</i>, трэба скарыстацца камандай:</p>

  <pre><code class="language-bash">
$ rvm remove 2.1.1    # Дзе 2.1.1 – раней усталяваная вэрсія Ruby
</code></pre>

  <h3 id="Versions_RVM_ListingInstalledVersions">Сьпіс усталяваных вэрсіяў</h3>
  <p>Каб даведацца якія вэрсіі <i>Ruby</i> ужо ўсталяваныя <i>RVM</i>, трэба скарыстацца камандамі:</p>

  <pre><code class="language-bash">
$ rvm list            # Сьпіс усіх вэрсіяў рубі
$ rvm list gemsets    # Сьпіс усіх вэрсіяў рубі разам з наборамі гемаў
$ rvm gemset list     # Сьпіс гемаў для рубі, які абраны ў дадзены момант
</code></pre>

  <h3 id="Versions_RVM_SelectingRubyForWork">Выбар вэрсіі для працы</h3>
  <p>Цяпер, калі мы ўсталявалі некалькі вэрсіяў <i>Ruby</i>, нам трэба выбраць патрэбную ў дадзены момант для працы:</p>

  <pre><code class="language-bash">
$ rvm use system            # Кажам RVM, каб ён не кіраваў вэрсіямі,
                            # будзе ўжывацца сыстэмны Ruby.
$ rvm use --default 2.1.1   # У цяперашнім тэрмінальным акне і ўва ўсіх наступных
                            # будзе ўжывацца вэрсія Ruby 2.1.1.
$ rvm use 2.1.0             # Толькі ў цяперашнім тэрмінальным акне
                            # будзе ўжывацца вэрсія Ruby 2.1.0.
$ rvm 2.1.0                 # Тое ж самае, што і папярэдняя каманда.
                            # "use" зьяўляецца змоўчнай дзеяй для RVM
$ rvm default               # Кажа RVM пераключыцца да змоўчнай вэрсіі Ruby
                            # у цяперашнім тэрмінальным акне
</code></pre>

  <h3 id="Versions_RVM_Gemsets">Множныя працоўныя асяродкі</h3>
  <p>Акрамя множных вэрсіяў самога <i>Ruby</i>, <i>RVM</i> таксама дазваляе ўсталёўваць множныя працоўныя асяродкі для адной і той жа вэрсіі. Па-ангельску ў тэрміланёгіі <i>RVM</i> яны завуцца ляканічна <i>gemsets</i>. Калі <i>RVM</i> усталёўвае новую вэрсію <i>Ruby</i>, ён стварае два змоўчных асяродка&nbsp;&ndash; <i>global</i> і <i>default</i>.</p>
  <ul>
    <li><i>global</i>&nbsp;&ndash; гэта супэр-асяродак, які спадкуюць усе астатнія асяродкі дадзенай вэрсіі <i>Ruby</i>.</li>
    <li><i>default</i>&nbsp;&ndash; гэта змоўчны асяродак, які выкарыстоўваецца ў выпадку, калі карыстальнік не абраў асяродку яўным чынам.</li>
  </ul>
  <p>Зьмест гэтых асяродкаў, то бок набор якіх гемаў павіенен для іх ужывацца, утрымліваецца ў тэкставых файлах, якія карыстальнік можа ўручную рэдагаваць:</p>
  <ul>
    <li><code>~/.rvm/gemsets/ruby/1.9.3/global.gems</code></li>
    <li><code>~/.rvm/gemsets/ruby/1.9.3/default.gems</code></li>
  </ul>
  <p>Напрыклад, калі дадаць наступны зьмест у файл <code>~/.rvm/gemsets/ruby/1.9.3/global.gems</code>:</p>

  <pre><code class="language-bash">
bundler
awesome_print
</code></pre>

  <p>Тады, кожны раз, калі ствараецца новы асяродак для <i>Ruby</i> вэрсіі 1.9.3, гэтыя 2 гемы будуць аўтаматычна ўсталяваны ў гэты новы асяродак.</p>
  <p>Прывядзем шэраг камандаў для працы з асяродкамі (<i>gemsets</i>):</p>

  <pre><code class="language-bash">
$ rvm use 2.1.0                       # Спачатку выбіраем Ruby
$ rvm gemset create project_name      # Ствараем асяродак для пэўнага праекту
$ rvm gemset use project_name         # Ужываць у далейшым створаны асяродак для Ruby 2.1.0
$ rvm gemset delete project_name      # Выдаліць раней створаны асяродак
$ rvm 2.1.1@other_project_name        # Ужываць іншую вэрсію Ruby і іншы асяродак
$ rvm 1.9.3@_project --create --rvmrc # Скарочаная форма адначасовага стварэньня і ўжыцьця
                                      # асяродку. Пры гэтым таксама будзе створаны файл
                                      # .rvmrc у тэчцы праекту

$ rvm use 1.9.3@_project --default    # Пазначае які асяродак ужываць па змоўчаньні для
                                      # дадзенай вэрсіі Ruby
</code></pre>

</section>

<section>
  <h1 id="Intro">Што такое Ruby?</h1>

  <h2 id="Intro_OOP">Аб'ектна-арыентаваная мова</h2>
  <p><i>Ruby</i> зьяўляецца цалкам аб'ектна-арыентаванай мовай праграмаваньня ў клясычным выглядзе. Усё, чым апэрыруе праграма на <i>Ruby</i>, зьяўляецца аб'ектам, і вынікі гэтых апэрацый таксама зьяўляюцца аб'ектамі. Аб'ектна-арыентаванае праграмаваньне характаразуецца тым, што распрацоўшчык спрабуе смадэляваць аб'ект рэальнага сьвету (возьмем у прыклад песьню) ў кодзе. У <i>Ruby</i> гэтыя аб'екты прадстаўляюцца клясамі. Клясы ўяўляюць зь сябе камбінацыю з стану (напр., назва песьні) і мэтадаў, якія апэрыруюць гэтым станам (напр., мэтад, каторы прайграе песьню).</p>
  <p>Калі аб'ект смадэляваны і адпаведная кляса напісаная, можна ствараць экзэмпляры гэтай клясы. Гэта адбываецца праз выклік канструктара&nbsp;&ndash; адмысловага мэтаду клясы, які звычайна называецца <code>new</code>.</p>

  <pre><code class="language-ruby">
song1 = Song.new("Ruby Tuesday")
song2 = Song.new("Enveloped in Python")
</code></pre>

  <p>Абедзьве зьменныя <code>song1</code> і <code>song2</code> зьяўляюцца экзэплярамі адной і той жа клясы <code>Song</code>, але маюць унікальныя характарыстыкі. Па-першае, кожны аб'ект (экзэмпляр нейкай клясы) у <i>Ruby</i> мае ўнікальны ідэнтыфікатар (<i>object id</i>). Па-другое, кляса можа ўтрымліваць зьменныя экзэмпляру, якія будуць утрымліваць унікальныя для кожнага экзэмпляру значэньні. Гэтыя зьменныя і выражаюць пазначаны вышэй <i>стан</i> аб'екта. Напрыклад, кляса <code>Song</code> можа ўтрымліваць зьменную, якая захоўвае назву песьні.</p>
  <p>Акрамя гэтага кожная кляса можа вызначаць мэтады экзэмпляраў&nbsp;&ndash; пэўны функцыянал, каторы можа выклікацца як знутры клясы, так і, пры пэўных акалічнасьцях,&nbsp;&ndash; звонку. Гэтыя мэтады маюць доступ да зьменных экзэмпляраў і могуць маніпуляваць імі. Мэтады могуць таксама называцца паведамленьнямі ці запытамі да аб'екта.</p>

  <pre><code class="language-ruby">
"gin joint".length      #=&gt; 9
"Rick".index("c")       #=&gt; 2
-1942.abs               #=&gt; 1942
sam.play(aSong)         #=&gt; "duh dum, da dum de dum ..."
</code></pre>

  <p>Тое, што стаіць да кропкі, называецца <i>атрымальнікам</i> паведамленьня/запыту. Пасьля кропкі ідзе мэтад, які павінен быць выкліканы. Першы з прыкладаў вышэй пытаецца пра даўжыню (мэтад <code>length</code>) радка («<i>gin joint</i>»). У другім прыкладзе ў іншага радка пытаецца пра індэкс літары «<i>c</i>» у ім. У трэцім прыкладзе мы пытаемся ў лічбы пра яе абсалютнае значэньне, а ў чацьвёртым просім <code>sam</code>'а, каб ён прапеў (мэтад <code>play</code>) нам песьню (перададзены ў якасьці парамэтру аб'ект <code>aSong</code>).</p>

  <h2 id="Intro_IntuitiveNotation">Інтуітыўная натацыя</h2>
  <p>Ruby створаны такім чынам, каб код, напісаны на ім, быў інтуітыўна зразумелы. Напрыклад, наступны выраз:</p>

  <pre><code class="language-ruby">
5.times { print "Odelay!" }
</code></pre>

  <p>азначае «пяць (<code>5</code>) разоў (анг. <code>times</code>) надрукуй (анг. <code>print</code>) <code>"Odelay!"</code>». А выраз:</p>

  <pre><code class="language-ruby">
exit unless "restaurant".include? "aura"
</code></pre>

  <p>азначае, што «праграмма павінна скончыць сваё дзеяньне (анг. <code>exit</code>), калі радок <code>"restaurant"</code> не (анг. <code>unless</code>) утрымлівае (анг. <code>include</code>) радок <code>"aura"</code>». А выраз:</p>

  <pre><code class="language-ruby">
['toast', 'cheese', 'wine'].each { |food| print food.capitalize }
</code></pre>

  <p>азначае «з кожным (анг. <code>each</code>) словам <code>'toast'</code>, <code>'cheese'</code>, <code>'wine'</code> зрабіць наступнае: пачатковую літару зрабіць вялікай (анг. <code>capitalize</code>) і надрукаваць вынік (анг. <code>print</code>)».</p>
</section>

<section>
  <h1 id="StructureExecution" data-content-item-open>Структура і выкананьне</h1>

  <h2 id="StructureExecution_Lexic">Лексычная структура</h2>
  <p>Інтэрпрэтатар <i>Ruby</i> разьбірае ўвесь тэкст <i>Ruby</i>-праграмы на <i>лексэмы</i> (ці <i>tokens</i>). Лексэмы ўключаюць камэнтары, літаралы, пунктуацыю, ідэнтыфікатары і ключавыя словы. Разгледзім больш падрабязна кожную з гэтых групаў, а таксама зь якіх сымбаляў яны складаюцца.</p>

  <h3 id="StructureExecution_Lexic_Comments">Камэнтары</h3>
  <p>Камэнтары ў <i>Ruby</i> пачынаюцца са знака <code>#</code> і працягваюцца да канца радку. Сам знак <code>#</code> і ўсё, што ідзе за ім, ігнаруецца інтэрпрэтатарам. Калі знак <code>#</code> сустракаецца ў сымбальнай чарадзе альбо ў рэгулярным выразе, тады ён зьяўляецца часткай чарады ці рэгулярнага выразу і не пачынае камэнтар.</p>
  <p>Камэнтары на шмат радкоў робяцца праз зьмяшчэньне знаку <code>#</code> у пачатку кожнага радку:</p>

  <pre><code class="language-ruby">
#
# This class represents a Complex number
# Despite its name, it is not complex at all.
#
</code></pre>

  <p>У <i>Ruby</i> няма эквіваленту ўнутрырадковага <i>C</i>-падобнага камэнтару: <code>/*...*/</code>.</p>

  <h4 id="StructureExecution_Lexic_Comments_EmbeddedDocuments">Убудаваныя дакумэнты</h4>
  <p><i>Ruby</i> падтрымлівае яшчэ адзін спосаб рабіць шматрадковыя камэнтары, які завецца <i>убудаваныя дакумэнты</i> (<i>embedded documents</i>). Такі камэнтар пачынаецца радком, які ў самым сваім пачатку зьмяшчае <code>=begin</code>, а сканчаецца радком, які ў самым сваім пачатку зьмяшчае <code>=end</code>:</p>
  <p>Камэнтары для дакумэнтацыі павінны зьмяшчацца непасрэдна перад модулем, клясай альбо мэтадам, які яны апісваюць, і маюць адмысловыя правілы фарматаваньня, некаторыя зь якіх глядзі ў прыкладзе:</p>

  <pre><code class="language-ruby">
=begin Someone needs to fix the broken code below!
Any code here is commented out
=end
</code></pre>

  <p>Прычым знак роўнасьці абавязкова павінен быць першым знакам адпаведных радкоў. Як вынікае з назвы гэтыя камэнтары прызначаны ў тым ліку для ўстаўкі вялікіх фрагмэнтаў дакумэнтацыі альбо для ўбудаваньня фрагмэнтаў зь іншых моваў праграмаваньня (як <i>HTML</i> альбо <i>SQL</i>). Гэтыя ўбудаваныя дакумэнты звычайна прызначаныя для апрацоўкі староньнімі прыладамі ці дадаткамі, якія апрацоўваюць зыходны код <i>Ruby</i>, а пасьля лексэмы <code>=begin</code> звычайна пазначаецца ідэнтыфікатар, які кажа для якой прылады ці дадатку прызначаецца дакумэнт.</p>

  <h4 id="StructureExecution_Lexic_Comments_ForDocumentation">Камэнтары для дакумэнтацыі</h4>
  <p>У <i>Ruby</i> маецца магчымасьць вымаць камэнтары з тэксту праграмы, каб ствараць дакумэнтацыю па праграме. <mark>Спасылка на <i>rdoc</i></mark></p>
  <p>Камэнтары для дакумэнтацыі павінны зьмяшчацца непасрэдна перад модулем, клясай альбо мэтадам, які яны апісваюць, і маюць адмысловыя правілы фарматаваньня, некаторыя зь якіх глядзі ў прыкладзе:</p>

  <pre><code class="language-ruby">
#
# Rdoc comments use a simple markup grammar like those used in wikis.
#
# Separate paragraphs with a blank line.
#
# = Headings
#
# Headings begin with an equals sign
#
# == Sub-Headings
# The line above produces a subheading.
# === Sub-Sub-Heading
# And so on.
#
# = Examples
#
# Indented lines are displayed verbatim in code font.
# Be careful not to indent your headings and lists, though.
#
# = Lists and Fonts
#
# List items begin with * or -. Indicate fonts with punctuation or HTML:
# * _italic_ or &lt;i&gt;multi-word italic&lt;/i&gt;
# * *bold* or &lt;b&gt;multi-word bold&lt;/b&gt;
# * +code+ or &lt;code&gt;multi-word code&lt;/code&gt;
#
# 1. Numbered lists begin with numbers.
# 99. Any number will do; they do not have to be sequential.
# 1. There is no way to do nested lists.
#
# The terms of a description list are bracketed:
# [item 1] This is a description of item 1
# [item 2] This is a description of item 2
#
</code></pre>

  <h3 id="StructureExecution_Lexic_Literals">Літаралы</h3>
  <p>Літаралы&nbsp;&ndash; гэта значэньні, якія сустракаюцца непасрэдна ў тэксьце праграмы. Гэта ўключае лікі, сымбальныя чароды і рэгулярныя выразы. (Іншыя літаралы, як масівы альбо хэшы, не зьяўляюцца асобнымі лексэмамі, але зьяўляюцца больш складанымі выразамі.) Сынтакс лічбавых і сымбальных літаралаў у <i>Ruby</i> насамрэч даволі складаны (<mark>глядзі разьдзел ....</mark>), але на дадзеным этапе дастаткова атрымаць спрошчанае іх разуменьне:</p>

  <pre><code class="language-ruby">
1       # Цэлалікавы літарал
1.0     # Рэчаісны літарал
'one'   # Сымбальны літарал
"two"   # Яшчэ адзін сымбальны літарал
/three/ # Літарал рэгулярнага выразу
</code></pre>

  <h3 id="StructureExecution_Lexic_Punctuation">Пунктуацыя</h3>
  <p>У гэтую групу ўваходзяць ня толькі самі знакі пунктуацыі, як коска, кропка, двукроп'е і іншыя, якія служаць для групаваньня альбо аддзяленьня выразаў, аргумэнтаў мэтадаў, індэксаў масіваў, а таксама для абмежаваньня сымбальных чародаў, рэгулярных выразаў і іншага. Уваходзяць сюды і розныя знакі <mark>апэрацыяў</mark>.</p>

  <h3 id="StructureExecution_Lexic_Identifiers">Ідэнтыфікатары</h3>
  <p>Ідэнтыфікатар&nbsp;&ndash; гэта інакш імя. <i>Ruby</i> выкарыстоўвае ідэнтыфікатары, каб даваць імёны зьменным, мэтадам, клясам і іншаму. Яны могуць складацца з літараў, лічбаў і знаку падкрэсьліваньня, пры гэтым у якасьці яго першага сымбалю ня можа быць лічба. Калі ідэнтыфікатар пачынаецца з вялікай літары, інтэрпрэтатар <i>Ruby</i> аўтаматычна ўспрыме яго за імя канстанты. Ніжэй прыводзяцца прыклады розных ідэнтыфікатараў:</p>

  <pre><code class="language-ruby">
i
x2
old_value
_internal   # Могуць пачынацца са знаку падкрэсьліваньня
PI          # Канстанта
</code></pre>

  <p>Па дамоўленасьці, калі ідэнтыфікатар (не канстанта) складаецца зь некалькіх словаў, тады паміж словамі зьмяшчаецца знак падкрэсьліваньня: <code>like_this</code>, а канстанты запісваюцца так: <code>LikeThis</code>, альбо так: <code>LIKE_THIS</code>.</p>
  <p>Як можна было зразумець з вышэйсказанага, у <i>Ruby</i> малыя і вялікія літары маюць адрозьненьне. Напрыклад, ключавое слова <code>end</code> гэта ня тое ж самае, што ключавое слова <code>END</code>.</p>

  <h4 id="StructureExecution_Lexic_Identifiers_Punctuation">Пунктуацыя ў ідэнтыфікатарах</h4>
  <p>У пачатку ці ў канцы ідэнтыфікатараў могуць стаяць знакі пунктуацыі (альбо адмысловыя сымбалі), якія маюць наступнае значэньне:</p>
  <table>
    <tr>
      <td style="width: 30px;"><code>$</code></td>
      <td>Глябальныя зьменныя маюць прэфікс у выглядзе знаку даляру. <i>Ruby</i> вызначае шэраг глябальных зьменных, у якіх дадаткова прысутнічаюць яшчэ іншыя знакі, як <code>$_</code> альбо <code>$-</code>. Па поўны сьпіс прадвызначаных адмысловых глябальных зьменных глядзі <mark>разьдзел 10.2.3</mark>.</td>
    </tr>
    <tr>
      <td style="width: 30px;"><code>@</code></td>
      <td>Зьменныя экзэмпляру клясы маюць прэфікс у выглядзе адзіночнага <i>at</i>-знаку, а зьменныя клясы&nbsp;&ndash; у выглядзе падвойнага <i>at</i>-знаку. Па больш дэталёвую інфармацыю глядзі <mark>разьдзел 7.3.5, 7.3.6</mark>.</td>
    </tr>
    <tr>
      <td style="width: 30px;"><code>?</code></td>
      <td>Па дамоўленасьці імёны мэтадаў, якія вяртаюць значэньні <mark><i>Boolean</i></mark>, сканчаюцца пытальнікам.</td>
    </tr>
    <tr>
      <td style="width: 30px;"><code>!</code></td>
      <td>Па дамоўленасьці імёны мэтадаў, якія павінны ўжывацца з асьцярогаю, сканчаюцца клічнікам. Такім чынам адзначаюцца мэтады, якія зьмяняюць стан аб'екту, у якога яны былі выкліканыя. У адрозьненьне ад тых мэтадаў, якія вяртаюць зьмененую копію зыходнага аб'екту.</td>
    </tr>
    <tr>
      <td style="width: 30px;"><code>=</code></td>
      <td>Па дамоўленасьці імёны мэтадаў, якія прызначаны для прысваеньня значэньняў, сканчаюцца знакам роўнасьці.</td>
    </tr>
  </table>
  <p>Вось прыклады ідэнтыфікатараў, якія ўтрымліваюць гэтыя адмысловыя знакі:</p>

  <pre><code class="language-ruby">
$files      # Глябальная зьменная
@data       # Зьменная экзэмпляру
@@counter   # Зьменная клясы
empty?      # Мэтад, які вяртае булеўскае значэньне
sort!       # Мэтад сартуе зьмест зыходнага аб'екту,
            # а не вяртае адсартаваную копію яго
timeout=    # Мэтад для прысваеньня значэньня
</code></pre>

  <p>Заўважце таксама, што некаторыя <mark>апэрацыі</mark> <i>Ruby</i> рэалізаваныя як мэтады, каб клясы маглі перавызначаць іх пад свае ўласныя патрэбы.</p>

  <h3 id="StructureExecution_Lexic_Keywords">Ключавыя словы</h3>
  <p>Наступныя ключавыя словы маюць адмысловае значэньне ў <i>Ruby</i> і будуць асаблівым чынам апрацаваныя яго парсэрам:</p>
  <table class="list" id="keywords">
    <tbody>
    <tr>
      <td><code>__LINE__</code></td>
      <td><code>begin</code></td>
      <td><code>else</code></td>
      <td><code>in</code></td>
      <td><code>rescue</code></td>
      <td><code>undef</code></td>
    </tr>
    <tr>
      <td><code>__ENCODING__</code></td>
      <td><code>break</code></td>
      <td><code>elsif</code></td>
      <td><code>module</code></td>
      <td><code>retry</code></td>
      <td><code>unless</code></td>
    </tr>
    <tr>
      <td><code>__FILE__</code></td>
      <td><code>case</code></td>
      <td><code>end</code></td>
      <td><code>next</code></td>
      <td><code>return</code></td>
      <td><code>until</code></td>
    </tr>
    <tr>
      <td><code>BEGIN</code></td>
      <td><code>class</code></td>
      <td><code>ensure</code></td>
      <td><code>nil</code></td>
      <td><code>self</code></td>
      <td><code>when</code></td>
    </tr>
    <tr>
      <td><code>END</code></td>
      <td><code>def</code></td>
      <td><code>false</code></td>
      <td><code>not</code></td>
      <td><code>super</code></td>
      <td><code>while</code></td>
    </tr>
    <tr>
      <td><code>alias</code></td>
      <td><code>defined?</code></td>
      <td><code>for</code></td>
      <td><code>or</code></td>
      <td><code>then</code></td>
      <td><code>yield</code></td>
    </tr>
    <tr>
      <td><code>and</code></td>
      <td><code>do</code></td>
      <td><code>if</code></td>
      <td><code>redo</code></td>
      <td><code>true</code></td>
      <td></td>
    </tr>
    </tbody>
  </table>
  <p>У дапаўненьне маюцца яшчэ 3 лексэмы, падобныя да ключавых словаў:</p>
  <table class="list" id="keywords_alike">
    <tbody>
    <tr>
      <td><code>=begin</code></td>
      <td><code>=end</code></td>
      <td><code>__END__</code></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    </tbody>
  </table>
  <p>2 зь якіх <code>=begin</code> і <code>=end</code> ужо згадваліся вышэй&nbsp;&ndash; яны адкрываюць і закрываюць так званыя <a href="#StructureExecution_Lexic_Comments_EmbeddedDocuments">убудаваныя дакумэнты</a> (альбо шматрадковыя камэнтары). А лексэма <code>__END__</code> пазначае канец праграмы (і пачатак сэкцыі з данымі), калі яна зьмяшчаецца ў самым пачатку радку, прычым пасьля яе на гэтым радку таксама нічога не павінна зьмяшчацца, нават прагалы.</p>
  <p>Акрамя вышэйазначанага шмат важных асаблівасьцяў і магчымасьцяў <i>Ruby</i> рэалізаваныя як мэтады клясаў <mark><code>Kernel</code>, <code>Module</code>, <code>Class</code> і <code>Object</code></mark>. Такім чынам, добрай практыкай будзе падыход, пры якім яны лічацца таксама зарэзэрваванымі словамі з асаблівым сэнсам і не выкарыстоўваюцца для ўласнага найменьня:</p>
  <table class="list" id="reserved">
    <caption>Гэта мэтады, якія выглядаюць як выразы ці ключавыя словы</caption>
    <tbody>
    <tr>
      <td><code>at_exit</code></td>
      <td><code>attr_reader</code></td>
      <td><code>include</code></td>
      <td><code>loop</code></td>
      <td><code>protected</code></td>
      <td><code>require</code></td>
    </tr>
    <tr>
      <td><code>attr</code></td>
      <td><code>attr_writer</code></td>
      <td><code>lambda</code></td>
      <td><code>private</code></td>
      <td><code>public</code></td>
      <td><code>throw</code></td>
    </tr>
    <tr>
      <td><code>attr_accessor</code></td>
      <td><code>catch</code></td>
      <td><code>load</code></td>
      <td><code>proc</code></td>
      <td><code>raise</code></td>
      <td></td>
    </tr>
    </tbody>
  </table>
  <table class="list" id="global_methods">
    <caption>Гэта найбольш ужываныя глябальныя мэтады</caption>
    <tbody>
    <tr>
      <td><code>Array</code></td>
      <td><code>block_given?</code></td>
      <td><code>exit</code></td>
      <td><code>iterator?</code></td>
      <td><code>readline</code></td>
      <td><code>sub!</code></td>
    </tr>
    <tr>
      <td><code>Float</code></td>
      <td><code>callcc</code></td>
      <td><code>exit!</code></td>
      <td><code>load</code></td>
      <td><code>readlines</code></td>
      <td><code>syscall</code></td>
    </tr>
    <tr>
      <td><code>Integer</code></td>
      <td><code>caller</code></td>
      <td><code>fail</code></td>
      <td><code>open</code></td>
      <td><code>scan</code></td>
      <td><code>system</code></td>
    </tr>
    <tr>
      <td><code>String</code></td>
      <td><code>chomp</code></td>
      <td><code>fork</code></td>
      <td><code>p</code></td>
      <td><code>select</code></td>
      <td><code>test</code></td>
    </tr>
    <tr>
      <td><code>URI</code></td>
      <td><code>chomp!</code></td>
      <td><code>format</code></td>
      <td><code>print</code></td>
      <td><code>sleep</code></td>
      <td><code>trap</code></td>
    </tr>
    <tr>
      <td><code>abort</code></td>
      <td><code>chop</code></td>
      <td><code>getc</code></td>
      <td><code>printf</code></td>
      <td><code>split</code></td>
      <td><code>warn</code></td>
    </tr>
    <tr>
      <td><code>autoload</code></td>
      <td><code>chop!</code></td>
      <td><code>gets</code></td>
      <td><code>putc</code></td>
      <td><code>sprintf</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>autoload?</code></td>
      <td><code>eval</code></td>
      <td><code>gsub</code></td>
      <td><code>puts</code></td>
      <td><code>srand</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>binding</code></td>
      <td><code>exec</code></td>
      <td><code>gsub!</code></td>
      <td><code>rand</code></td>
      <td><code>sub</code></td>
      <td></td>
    </tr>
    </tbody>
  </table>
  <table class="list" id="object_methods">
    <caption>А гэта найбольш ужываныя мэтады аб'ектаў</caption>
    <tbody>
    <tr>
      <td><code>allocate</code></td>
      <td><code>equal?</code></td>
      <td><code>inherited</code></td>
      <td><code>methods</code></td>
      <td><code>superclass</code></td>
      <td><code>untaint</code></td>
    </tr>
    <tr>
      <td><code>clone</code></td>
      <td><code>extend</code></td>
      <td><code>inspect</code></td>
      <td><code>new</code></td>
      <td><code>taint</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>display</code></td>
      <td><code>freeze</code></td>
      <td><code>instance_of?</code></td>
      <td><code>nil?</code></td>
      <td><code>tainted?</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>dup</code></td>
      <td><code>frozen?</code></td>
      <td><code>is_a?</code></td>
      <td><code>object_id</code></td>
      <td><code>to_a</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>enum_for</code></td>
      <td><code>hash</code></td>
      <td><code>kind_of?</code></td>
      <td><code>respond_to?</code></td>
      <td><code>to_enum</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>eql?</code></td>
      <td><code>id</code></td>
      <td><code>method</code></td>
      <td><code>send</code></td>
      <td><code>to_s</code></td>
      <td></td>
    </tr>
    </tbody>
  </table>

  <h3 id="StructureExecution_Lexic_Whitespaces">Прагалы</h3>
  <p>Прагалы, знакі табуляцыі, пераносы радку&nbsp;&ndash; усе яны не зьяўляюцца лексэмамі, але падзяляюць лексэмы адну ад другой, якія б інакш зьліліся ў адну лексэму. Акрамя гэтай функцыі ў агульным выпадку прагалы ігнаруюцца інтэрпрэтатарам, але некаторыя зь іх выконваюць яшчэ дадатковыя, пры гэтым важныя функцыі. <i>Ruby</i> мае выразную, але і складаную граматыку, і існуюць выпадкі, калі ўстаўка ці выдаленьне некаторых відаў прагалаў можа зьмяніць сэнс праграмы. Хаця гэтых выпадкаў і ня шмат, іх трэба ведаць.</p>

  <h4 id="StructureExecution_Lexic_Whitespaces_Newlines">Пераносы радку</h4>
  <p>Найбольш важная залежнасьць ад прагалаў&nbsp;&ndash; гэта пераносы радку ў якасьці маркераў канца выразаў. У мовах праграмаваньня як <i>C</i> ці <i>Java</i> кожны выраз павінен сканчацца кропкай з коскай. Гэтак жа можна рабіць і ў <i>Ruby</i>, але гэта абавязкова толькі ў выпадку, калі патрэбна зьмясьціць некалькі выразаў у адным радку. Інакш, па дамоўленасьці, кропка з коскай не павінна ўжывацца. Але без кропкі з коскай інтэрпрэтатар павінен сам нейкім чынам зразумець дзе знаходзіцца канец выразу. Таму, калі фрагмэнт коду на адным радку можа быць сынтаксічна завершаным выразам, <i>Ruby</i> трактуе знак пераносу радку як азнаку канца выразу. Інакш ён працягвае аналізаваць код на наступным радку.</p>
  <p>Калі кожны выраз зьмяшчаецца на асобным радку, тады ня ўзьнікне праблемаў, але калі ёсьць выразы, якія займаюць больш аднаго радку, трэба зрабіць перанос выразу такім чынам, каб <i>Ruby</i> ня здолеў інтэрпрэтаваць фрагмэнт на першым з гэтых радкоў як асобны выраз. Напрыклад, наступны код складзе <code>x</code> з <code>y</code> і назначыць суму зьменнай <code>total</code>:</p>

  <pre><code class="language-ruby">
total = x +   # Няпоўны выраз, таму пераходзім на наступны радок, каб скончыць яго
  y
</code></pre>

  <p>А вось наступны код назначыць значэньне зьменнай <code>x</code> зьменнай <code>total</code>, а потым вылічыць значэньне зьменнай <code>y</code> і нічога з гэтым ня зробіць:</p>

  <pre><code class="language-ruby">
total = x     # Поўны выраз. Перанос радку трактуецца як маркер канца выразу.
  + y         # Хаця і безсэнсоўны, але поўны выраз.
</code></pre>

  <h2 id="StructureExecution_Syntax">Сынтаксычная структура</h2>
  <p>Вышэй мы разглядалі лексэмы&nbsp;&ndash; элемэнтарныя цаглінкі <i>Ruby</i>-праграмы. Зараз коратка разгледзім як гэтыя цагліны складаюцца разам у большыя, сынтаксычныя структуры <i>Ruby</i>-праграмы&nbsp;&ndash; ад прасьцейшых выразаў да буйных модуляў.</p>
  <ol>
    <li>
      <p>Базавым элемэнтам сынтаксу ў <i>Ruby</i> зьяўляецца <strong><a href="#ExpressionsAndOperators">выраз</a></strong>. Інтэрпрэтатар <i>Ruby</i> апрацоўвае выразы і атрымлівае ў выніку значэньні. Самымі простымі зьяўляюцца прымітыўныя выразы, якія прадстаўляюць значэньні наўпрост&nbsp;&ndash; лікі, сымбальныя чароды, зьменныя (якія дасылаюць наўпрост да пэўнага значэньня) і некаторыя ключавыя словы, якія прадстаўляюць адмысловыя значэньні (<mark><code>true</code>, <code>false</code>,<code>nil</code>, <code>self</code></mark>). Акрамя гэтага існуюць і больш складаныя, састаўныя выразы:</p>

      <pre><code class="language-ruby">
[1, 2, 3, 4, 5]           # літарал масіву
{1 =&gt; "one", 2 =&gt; "two"}  # літарал хэшу
1..5                      # літарал дыяпазону
</code></pre>

      <p><strong><a href="#ExpressionsAndOperators_Operators">Апэрацыі</a></strong> прызначаныя для выкананьня вылічэньняў са значэньнямі. Састаўныя выразы складаюцца ў тым ліку пры дапамозе камбінаваньня апэрацыяў зь іншымі выразамі:</p>

      <pre><code class="language-ruby">
1         # Прымітыўны выраз
x         # Яшчэ адзін прымітыўны выраз
x = 1     # Састаўны выраз прысваеньня
x = x + 1 # Больш складаны састаўны выраз, які складаецца з выразу дадаваньня (х + 1)
          # і выразу прысваеньня х = (х + 1)
</code></pre>

    </li>
    <li>
      <aside><sup>1</sup>Ува ўсёй сукупнасьці дадзеных даведнікаў у якасьці адпаведніку тэрміну <i>statement</i> ангельскай кампутарнай тэрміналёгіі ўжываюцца як <i>апэратар</i> (як больш пазнавальны тэрмін з расейскай мовы), гэтак і <i>інструкцыя</i> (як больш адпавядаючы сэнсу кіруючай канструкцыі).</aside>
      <p>Выразы ў камбінацыі з <a href="#StructureExecution_Lexic_Keywords">ключавымі словамі</a> могуць утвараць інструкцыі для выкананьня, альбо <strong><a href="#ExpressionsAndOperators_Operators">апэратары</a></strong><sup>1</sup>. Гэтак, <code>if</code>-апэратар выкарыстоўваецца для ўмоўнага выкананьня пэўнага коду, а <code>while</code>-апэратар&nbsp;&ndash; для цыклічнага выкананьня коду:</p>

      <pre><code class="language-ruby">
if x &gt; 5 then   # Калі ўмоўны выраз вяртае значэньне true,
  x = x - 1     # тады выканаць гэтую інструкцыю.
end             # Пазначае канец умоўнага выкананьня.

while x &lt; 5 do  # Пакуль умоўны выраз вяртае значэньне true...
  print x       # выканаць гэтую інструкцыю,
  x = x + 1     # потым гэтую інструкцыю.
end             # Пазначае канец цыклічнага выкананьня.
</code></pre>

      <p>У <i>Ruby</i> інструкцыі (апэратары) тэхнічна таксама зьяўляюцца выразамі і вяртаюць значэньні, хаця ня ўсе зь іх зьяўляюцца асэнсаванымі&nbsp;&ndash; напрыклад, <code>while</code>-апэратар заўсёды вяртае значэньне <code>nil</code>.</p>
    </li>
    <li>
      Амаль заўсёды маецца неабходнасьць згрупаваць выразы і інструкцыі ў адасобленыя адзінкі з уваходнымі парамэтрамі, каб іх можна было выклікаць шматкроць і са зьменлівымі ўваходнымі данымі. У <i>Ruby</i>, як аб'екта-арыентаванай мове, гэтыя адзінкі завуцца <strong><a href="#MethodsAndProcs_Methods">мэтадамі</a></strong>. Акрамя гэтага маюцца мэтад-падобныя адзінкі <a href="#MethodsAndProcs_ProcsAndLambdas"><strong>працэдуры</strong> і <strong>лямбды</strong></a>.
    </li>
    <li>
      І напрыканцы ўзаемазьвязаныя мэтады могуць аб'ядноўвацца ў <a href="#ClassesAndModules_Classes"><strong>клясы</strong></a>, а клясы і асобныя мэтады могуць аб'ядноўвацца ў <a href="#ClassesAndModules_Modules"><strong>модулі</strong></a>.
    </li>
  </ol>

  <h3 id="StructureExecution_Syntax_Blocks">Групаваньне зьместу праз блёкі</h3>
  <p>Праграмы на <i>Ruby</i> маюць блёчную структуру, у тым сэнсе, што модулі, клясы, мэтады і большасьць інструкцыяў маюць блёкі злучанага зь імі коду. Існуе 2 тыпы блёкаў. Па-першае, гэта блёкі, які перадаюцца ітэрацыйным мэтадам. Яны могуць заключацца альбо ў фігурныя дужкі (калі укладзеныя выразы зьмяшчаюцца на адзіна радок), альбо паміж ключавымі словамі <code>do</code>…<code>end</code> (шматрадковы блёк):</p>

  <pre><code class="language-ruby">
5.times { print "Ruby!" }

1.upto(10) do |x|
  print x
end
</code></pre>

  <p>Іншым тыпам блёкаў зьяўляюцца целы модуляў, клясаў, мэтадаў і апэратараў. Яны ніколі не заключаюцца ў фігурныя дужкі, але пры дапамозе ключавых словаў. Таксама блёкі могуць быць укладзеныя адны ў іншыя:</p>

  <pre><code class="language-ruby">
module Stat                           # Пачатак аб'яўленьня модулю
  class Data                          # Пачатак аб'яўленьня клясы ў модулі
    def init(file_name)               # Пачатак аб'яўленьня мэтаду ў клясе
      IO.foreach(file_name) do |line| # Блёк ітэратару ў мэтадзе
        if line[0,1] == "%"           # Умоўны апэратар у блёку
          next                        # Просты выраз ува ўмоўным апэратары
        end                           # Канец блёку ўмоўнага апэратару
      end                             # Канец блёку ітэратару
    end                               # Канец цела мэтаду
  end                                 # Канец цела клясы
end                                   # Канец цела модулю
</code></pre>

  <h2 id="StructureExecution_Files">Структура файлаў</h2>

  <h2 id="StructureExecution_Encoding">Кадоўка файлаў</h2>

  <h2 id="StructureExecution_Execution">Выкананьне праграмы</h2>
</section>

<section>
  <h1 id="ExpressionsAndOperators" data-content-item-open>Выразы і апэрацыі</h1>

  <p>Сынтакс <i>Ruby</i> цэнтруецца вакол выразаў. Напрыклад, элемэнты кіраваньня плыньню праграмы, кшталту <code>if</code> у любой іншай мове праграмаваньня называюцца апэратарамі (умоўным апэратарам у дадзеным выпадку), а ў <i>Ruby</i> гэта таксама выразы і яны вяртаюць значэньні:</p>

  <pre><code class="language-ruby">
minimum = if x &lt; y then x else y end
</code></pre>

  <p>Хаця ня ўсе зь іх вяртаюць зьмястоўныя значэньні. Напрыклад, апэратар цыкла <code>while</code> ці вызначэньне <a href="#MethodsAndProcs_Methods">мэтаду</a> вяртаюць <code>nil</code>.</p>

  <h2 id="ExpressionsAndOperators_Literals">Літаралы</h2>

  <h2 id="ExpressionsAndOperators_Variables">Зьменныя</h2>
  <p>Зьменныя&nbsp;&ndash; гэта імёны аб'ектаў ці значэньняў. Яны могуць састаяць з літараў, лічбаў і знака падкрэсьліваньня. Прыклад:</p>

  <pre><code class="language-ruby">
single_fee = 2.50                       #=&gt; даем імя значэньню кошта ўваходнага білета
attendees = 4                           #=&gt; даем імя колькасьці наведнікаў
overall_fee = single_fee * attendees    #=&gt; разьлічваем агульны кошт уваходу групы
                                        #=&gt; наведнікаў, пры гэтым зьвяртаемся да
                                        #=&gt; значэньняў кошту ўваходнага білета і колькасьці
                                        #=&gt; наведнікаў у групе праз іх імёны
</code></pre>

  <p><strong>УВАГА!</strong> Зьменныя больш нізкага ўзроўню ня проста перакрываюць зьменныя з тым жа імем больш высокага ўзроўню (як, напрыклад, у <a href="../java/index.html"><i>Java</i></a>):</p>

  <pre><code class="language-ruby">
verb = 'rescued'
['sedated', 'sprinkled', 'electrocuted'].each do |verb|
  puts "Dr. Cham " + verb + " his niece Hannah."
end
puts "Yes, Dr. Cham " + verb + " his niece Hannah."
</code></pre>

  <p>але перавызначаць/заціраюць яе:</p>

  <pre><code class="language-ruby">
Dr. Cham sedated his niece Hannah.
Dr. Cham sprinkled his niece Hannah.
Dr. Cham electrocuted his niece Hannah.
Yes, Dr. Cham electrocuted his niece Hannah.
</code></pre>

  <p>Як бачым, у апошнім радку ў якасьці значэньня зьменнай <code>verb</code> больш высокага ўзроўню падставіцца <i>"electrocuted"</i>&nbsp;&ndash; апошняе значэньне ітэратару, а не першапачатковае <i>"rescued"</i>, як магло б падацца.</p>
  <p>Спроба зьвярнуцца да яшчэ не аб'яўленай зьменнай выкліча памылку, але тут ёсьць адзін &laquo;хітрык&raquo;&nbsp;&ndash; дастаткова каб інтэпрэтатар Ruby &laquo;убачыў&raquo; аб'яўленьне зьменнай і не абавязкова, каб гэта аб'яўленьне выканалась праграмай:</p>

  <pre><code class="language-ruby">
a = 0.0 if false        # Гэтае прысваеньне ніколі не будзе выканана
print a                 # Выдадзе на экран nil: зьменная існуе, але не ініцыялізавана
print b                 # NameError: не існуе такой зьменнай ці мэтаду
</code></pre>

  <h3 id="ExpressionsAndOperators_Variables_InstanceVar">Зьменныя экзэмпляраў</h3>
  <p>Зьменныя, каторыя пачынаюцца са знака &#64;, зьяўляюцца зьменнымі <strong>экзэмпляраў</strong> <a href="#ClassesAndModules_Classes">клясаў</a>:</p>

  <pre><code class="language-ruby">
@x, @y
</code></pre>

  <p>Яны пазначаюць характарыстыку гэтага асабістага экзэмпляру. Напрыклад, каб пазначыць шырыню ўваходных дзьвярэй трэба ўвесьці зьменную <code class="var">&#64;width</code> у экзэмпляр <code>front_door</code> клясы <code>Door</code>.</p>

  <h3 id="ExpressionsAndOperators_Variables_ClassVar">Зьменныя клясаў</h3>
  <p>Зьменныя яшчэ больш высокага ўзроўню (у параўнаньні зь лякальнымі і экзэплярнымі)&nbsp;&ndash; зьменныя <strong><a href="#ClassesAndModules_Classes">клясаў</a></strong>. Яны пачынаюцца з падвойнага знака &#64;:</p>

  <pre><code class="language-ruby">
@@x, @@y
</code></pre>

  <p>І пазначаюць характарыстыку ўсёй клясы (усіх экзэмпляраў гэтай клясы). Зьяўляюцца аналягамі статычных зьменных у <a href="../java/index.html"><span class="term">Java</span></a>.</p>

  <h3 id="ExpressionsAndOperators_Variables_GlobalVar">Глябальныя зьменныя</h3>
  <p>Ну і зьменнымі найбольш высокага ўзроўню зьяўляюцца глябальныя зьменныя. Яны пачынаюцца са знака &#36; і даступны зь любога месца праграмы:</p>

  <pre><code class="language-ruby">
$x, $y
</code></pre>

  <h2 id="ExpressionsAndOperators_Consts">Канстанты</h2>
  <p>Канстанты як зьменныя, але пачынаюцца зь вялікай літары і не павінны зьмяняць сваё значэньня цягам працы праграмы. Хаця апошняе строга не забаронена&nbsp;&ndash; пры зьмене значэньня канстанты інтэрпрэтатар Ruby выдасьць толькі папярэджаньне. Акрамя гэтага ёсьць яшчэ адна асаблівасьць&nbsp;&ndash; імя канстант вядзецца запісваць ня проста зь вялікай літары, а ўсімі вялікімі літарамі:</p>

  <pre><code class="language-ruby">
EMPIRE_STATE_BUILDING = "350 5th Avenue, NYC, NY"
</code></pre>

  <p>Канстанта можа быць вызначана як на глябальным узроўні (<i>global scope</i>), так і на ўзроўні клясаў ці модуляў:</p>

  <pre><code class="language-ruby">
Conversions::CM_PER_INCH              # Зьвяртаньне да канстанты, вызначанай у модулі/клясе Conversions

Conversions::Area::HECTARES_PER_ACRE  # Укладзеная герархія модуляў

::ARGV                                # Зьвяртаньне да глябальнай канстанты ARGV
</code></pre>

  <h2 id="ExpressionsAndOperators_Operators" data-content-item-open>Апэрацыі</h2>
  <p>Апэрацыі выкарыстоўваюцца ў праграме для выкананьня матэматычных і лягічных апэрацый, для параўнаньня і інш. Шмат зь іх рэалізваныя праз <a href="#MethodsAndProcs_Methods">мэтады</a>, і <a href="#ClassesAndModules_Classes">клясы</a> могуць вызначаць (ці перавызначаць) іх на свой капыл. Напрыклад, апэрацыі <code>+</code> і <code>*</code> дзейнічаюць па-рознаму для <a href="#Types_Numbers">лікаў</a> і <a href="#Types_Strings">сымбальных чародаў</a>. А ўва ўласных варыянтах гэтых клясаў можна ўвогуле вызначыць свае варыянты гэтых мэтадаў. Іншы прыклад, каторы ілюструе гэты падыход&nbsp;&ndash; апэрацыя <code>&lt;&lt;</code>. Лікавыя клясы <code>Fixnum</code> і <code>Bignum</code> рэалізуюць яе для бітавага зруху ўлева, у той час як іншыя клясы (<a href="#Types_Strings">сымбальныя чароды</a>, <a href="#Types_Arrays">масівы</a>) рэалізуюць яе як дадаваньне зьместу.</p>

  <h3 id="ExpressionsAndOperators_Operators_UnaryMinus">Унарныя <code>+</code> і <code>-</code></h3>
  <p>Унарная апэрацыя <code>-</code>, каторая зьмяшчаецца перад лікам, зьмяняе яго знак на адваротны. Унарны <code>+</code> перад лікам таксама дазваляецца, але ён не аказвае ніякага ўзьдзеяньня. Каб адрозьніваць гэтыя апэрацыя ад адпаведных арытмэтычных, мэтады, якія вызначаюць гэтыя апэрацыі, маюць назвы <code>-@</code> і <code>+@</code>.</p>

  <h3 id="ExpressionsAndOperators_Operators_Exponentiation">Cтупеняваньне: <code>**</code></h3>
  <p>Апэрацыя <code>**</code> падвышае першы аргумэнт у ступень другога. Другі аргумэнт можа быць дробавым (кубічны корань ад <code>x</code>: <code>x**(1.0/3.0)</code>), а таксама адмоўным (<code>x**-y</code> эквівалентна <code>1/(x**y)</code>).</p>

  <h3 id="ExpressionsAndOperators_Operators_Arithmetic">Арытмэтычныя: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> і <code>%</code></h3>
  <p>Апэрацыя <code>+</code>, <code>-</code>, <code>*</code> і <code>/</code> выконваюць адпаведна арытмэтычнае складаньне, адніманьне, памнажэньне і дзяленьне сваіх лікавых аргумэнтаў. Цэлалікавае дзяленьне дае заўсёды цэлалікавы вынік, а астача адкідваецца. Астачу цэлалікавага дзяленьня можна вызначыць пры дапамозе апэрацыі <code>%</code>.</p>
  <p>Сымбальныя чароды выкарыстоўваюць апэрацыю <code>+</code> для спалучэньня некалькіх чародаў, апэрацыю <code>*</code> для паўтарэньня чародаў і апэрацыю <code>%</code> у якасьці аргумэнту мэтаду <code>sprintf</code>.</p>
  <p>У выпадку масіваў апэрацыя <code>+</code> спалучае масівы, апэрацыя <code>-</code> аднімае масівы. Паводзіны апэрацыі <code>*</code> залежаць ад другога аргумэнту. Калі другім аргумэнтам зьяўляецца лік, тады у выніку атрымліваецца іншы масіў, у каторым першапачатковы паўтараецца столькі разоў, як гэты лік. Калі ж другі аргумэнт&nbsp;&ndash; сымбальная чарада, тады гэтая апэрацыя эквівалентна мэтаду <code>join</code>.</p>

  <h3 id="ExpressionsAndOperators_Operators_ShiftAppend">Зрух і дадаваньне: <code>&lt;&lt;</code> і <code>&gt;&gt;</code></h3>
  <p>Апэрацыі <code>&lt;&lt;</code> і <code>&gt;&gt;</code> у выпадку лікавых апэрандаў робяць бітавы зрух першага апэранду адпаведна ўлева і ўправа на колькасьць бітаў, пазначаных другім апэрандам.</p>
  <p>У выпадку сымбальных чародаў і масіваў апэрацыя <code>&lt;&lt;</code> дадае да левага свайго апэранду зьмест правага апэранду:</p>

  <pre><code class="language-ruby">
message = "hello"       #=&gt; "hello"
messages = []           #=&gt; []
message &lt;&lt; " world"     #=&gt; "hello world"
messages &lt;&lt; message     #=&gt; ["hello world"]
</code></pre>

  <h3 id="ExpressionsAndOperators_Operators_Bitwise">Бітавыя: <code>~</code>, <code>&amp;</code>, <code>|</code> і <code>^</code></h3>
  <p>Лягічныя пабітавыя апэрацыі (адпаведна) NOT, AND, OR і XOR.</p>

  <h3 id="ExpressionsAndOperators_Operators_Comparison">Параўнаньне: <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> і <code>&lt;=&gt;</code></h3>
  <p>Апэрацыі праверкі ці першы аргумэнт (адпаведна) большы за другі, большы альбо роўны другому, меншы другога, меншы альбо роўны другому. Апошняя з гэтых апэрацыяў (<code>&lt;=&gt;</code>) мае трохі адрознае значэньне. Гэта ўнівэрсальная апэрацыя параўнаньня: калі левы апэранд меньшы за правы, яна вяртае <code>-1</code>, калі левы апэранд большы за правы, яна вяртае <code>1</code>, і калі яны роўныя, вяртае <code>0</code>.</p>

  <h3 id="ExpressionsAndOperators_Operators_Equality">Роўнасьць: <code>==</code>, <code>!=</code>, <code>=~</code>, <code>!~</code> і <code>===</code></h3>
  <p>Апэрацыя <code>==</code> правярае ці яе апэранды &laquo;роўныя&raquo; (у разуменьні левага апэранду). Апэрацыя <code>!=</code> вяртае супрацьлеглае значэньне апэрацыі <code>==</code>.</p>
  <p>Апэрацыя <code>=~</code> правярае ці сымбальная чарада адпавядае шаблёну (<i>Regexp</i>), а апэрацыя <code>!~</code> робіць адваротнае.</p>
  <p>Апэрацыя <code>===</code> правярае ці ўваходзіць пэўнае значэньне ў пазначаны дыяпазон.</p>

  <h3 id="ExpressionsAndOperators_Operators_Boolean">Лягічныя: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>, <code>and</code>, <code>or</code>, <code>not</code></h3>
  <p>Вынікам апэрацыі <code>&amp;&amp;</code> будзе <code>true</code>, калі абодва яе аргумэнта маюць значэньне <code>true</code>, інакш вынікам будзе <code>false</code>. Вынікам апэрацыі <code>||</code> будзе <code>true</code>, калі хаця б адзін зь яе аргумэнтаў мае значэньне <code>true</code>, а вынікам <code>false</code> будзе толькі тады, калі абодва аргумэнта таксама маюць значэньне <code>false</code>. Апэрацыя <code>!</code> робіць булеўскае адмаўленьне свайго адзінага аргумэнта, то бок вяртае <code>false</code>, калі аргумэнт мае значэньне <code>true</code>, і, наадварот, вяртае <code>true</code>, калі калі аргумэнт мае значэньне <code>false</code>.</p>
  <p>Апэрацыі <code>and</code>, <code>or</code> і <code>not</code> зьяўляюцца меньш прыярытэтнымі эквівалентамі адпаведна апэрацый <code>&amp;&amp;</code>, <code>||</code> і <code>!</code>.</p>

  <h3 id="ExpressionsAndOperators_Operators_Ranges">Дыяпазону: <code>..</code> i <code>...</code></h3>
  <p>Гэтая апэрацыя служыць для стварэньня <a href="#Types_Ranges">дыяпазонаў</a> як аб'ектаў, дыяпазонных выразаў, а таксама ўмоўных дыяпазонаў.</p>

  <pre><code class="language-ruby">
1..10                 # новы Range аб'ект, аналяг: Range.new(1,10)
x+1..x*x              # дыяпазонны выраз
x==3..x==5            # умоўны дыяпазон
</code></pre>

  <p>Апэрацыя мае 2 варыянты: уключны (<code>..</code>) і выключны (<code>...</code>):</p>

  <pre><code class="language-ruby">
1..10                 # значэньні ад 1 да 10 уключна
1...10                # значэньні ад 1 да 9 уключна (без уліку апошняга значэньня)
</code></pre>

  <h3 id="ExpressionsAndOperators_Operators_Conditional">Умоўная: <code>?:</code></h3>
  <p>Гэта адзіная тэрнарная (мае 3 апэранда) апэрацыя ў Ruby. Першы апэранд зьмяшчаецца перад пытальнікам, другі&nbsp;&ndash; паміж пытальнікам і двукроп'ем, а трэці&nbsp;&ndash; пасьля двукроп'я. Апэрацыя спачатку вылічвае свой першы апэранд, калі ён ня роўны <code>false</code> ці <code>nil</code>, тады апэрацыя вяртае другі свой апэранд, у адваротным выпадку&nbsp;&ndash; свой трэці апэранд. Можна сказаць, што гэтая апэрацыя зьяўляецца кароткай формай <a href="#StatementsAndControl_Conditionals">ўмоўнага апэратара</a> (<code>if/then/else</code>). Прыклады:</p>

  <pre><code class="language-ruby">
"You have #{n} #{n==1 ? 'message' : 'messages'}"

# Наконт прагалаў паміж апэрандамі і знакамі апэрацыі:
x==3?y:z      # Гэта дазваляльна
3==x?y:z      # Сынтаксычная памылка: x? інтэрпрэтуецца як імя мэтаду
(3==x)?y:z    # Дазваляльна: дужкі выпраўляюць праблему
3==x ?y:z     # ...як і прагал перад пытальнікам

# Наконт парадку разбору пры ўкладзеных апэрацыях:
max = x&gt;y ? x&gt;z ? x : z : y&gt;z ? y : z
max = x&gt;y ? (x&gt;z ? x : z) : (y&gt;z ? y : z)   # Эквівалентна папярэдняму
</code></pre>

  <h3 id="ExpressionsAndOperators_Operators_Defined">Праверка вызначэньня: <code>defined?</code></h3>
  <p>Апэрацыя правярае ці вызначаны яе адзіны апэранд. </p>

  <pre><code class="language-ruby">
# Прысвойвае значэньне f(x) зьменнай y, але толькі ў тым выпадку, калі
# ў праграме ёсьць вызначэньне і мэтаду f, і зьменнай x
y = f(x) if defined? f(x)
</code></pre>

  <h3 id="ExpressionsAndOperators_Operators_Assignments">Прысваеньня</h3>
  <p>Апэрацыі прысваеньня звычайна даволі інтуітыўна зразумелыя, але што тычыцца гэтых апэрацыяў у Ruby, трэба спыніцца на некалькіх асаблівасьцях. Па-першае, значэньнем выразу прысваеньня зьяўляецца правы апэранд апэрацыі. Па-другое, апэрацыя прысваеньня зьяўляецца права-асацыятыўнай. Гэтыя дзьве асаблівасьці прыводзяць да таго, што выразы наступнага выгляду дазваляльныя ў <i>Ruby</i>:</p>

  <pre><code class="language-ruby">
x = y = z = 0           # Прысвойвае значэньне 0 зьменным x, y, і z
x = (y = (z = 0))       # Эквівалентна папярэдняму з пазнакай парадку прысваеньня
</code></pre>

  <a href="#MethodsAndProcs_Methods">мэтады</a>, і <a href="#ClassesAndModules_Classes">клясы</a>

  <h4 id="ExpressionsAndOperators_Operators_Assignments_LocalVars">Прысваеньне лякальным зьменным</h4>
  <p>Наступнай асаблівасьцю зьяўляецца той факт, што ў Ruby няма яўных мэханізмаў у сынтаксе адрозьніць <a href="#ExpressionsAndOperators_Variables">зьменную</a> ад <a href="#MethodsAndProcs_Methods">мэтаду</a>. Гэта прыводзіць да таго, што выраз <code>x</code> у Ruby можа зьвяртацца да аднайменнай лякальнай зьменнай, альбо да аднайменнага мэтаду. Каб вырашыць гэтую неадназначнасьць, Ruby трактуе такі выраз як зьвяртаньне да лякальнай зьменнай, калі да гэтага было прысваеньне гэтай зьменнай:</p>

  <pre><code class="language-ruby">
class Ambiguous
  def x; 1; end       # Мэтад зь імем "x". Заўсёды вяртае 1

  def test
    puts x            # Прысваеньня зьменнай не было, таму робіць выклік мэтада вышэй: друкуе 1

    # Хаця прысваеньне ніжэй ніколі ня будзе выканана (з-за "if false") парсэр "убачыць"
    # прысваеньне зьменнай x і будзе трактаваць выраз "х" да канца мэтаду
    # як зьвяртаньне да зьменнай.
    x = 0 if false

    puts x            # зараз x - гэта зьменная, але ёй ніколі не было
                      # прысвоена значэньне, таму: друкуе nil

    x = 2             # На гэты раз прысваеньне будзе выканана
    puts x            # Таму гэты выраз прывядзе да друкаваньня 2
  end
end
</code></pre>

  <h4 id="ExpressionsAndOperators_Operators_Assignments_AttrsArrays">Прысваеньне атрыбутам і масівам</h4>
  <p>Прысваеньне <mark>атрыбутам</mark> і <a href="#Types_Arrays">масівам</a> у Ruby зьяўляецца на самай справе кароткай формай выклікаў адпаведных мэтадаў. Уявім, што аб'ект <code>o</code> мае аб'яўленьне мэтаду <code>m=</code>, тады выраз <code>o.m</code> можа зьяўляцца левым апэрандам апэрацыі прысваеньня:</p>

  <pre><code class="language-ruby">
o.m = v
</code></pre>

  <p>Гэта прысваеньне інтэрпрэтатар Ruby пераўтворыць у выклік мэтаду:</p>

  <pre><code class="language-ruby">
o.m=(v)
</code></pre>

  <p>Звычайна аб'яўленьне мэтаду <code>m=</code> ідзе ў пары з аб'яўленьнем мэтаду <code>m</code>, каторы проста вяртае значэньне, апошні раз перададзенае мэтаду <code>m=</code>. Калі аб'ект мае такую пару мэтадаў, кажуць, што аб'ект мае атрыбут <code class="attr">m</code>. Мэтад <code>m=</code> называюць пры гэтым <i>setter</i>, а мэтад <code>m</code>&nbsp;&ndash; <i>getter</i>.</p>
  <p>Прысваеньне элемэнтам масіву таксама адбываецца праз выклік адпаведнага мэтаду. Калі аб'ект <code>o</code> мае аб'яўленьне мэтаду <code>[]=</code>, каторы прымае 2 аргумэнты, тады выраз <code>o[x] = y</code> будзе на самай справе выкананы як:</p>

  <pre><code class="language-ruby">
o.[]=(x,y)
</code></pre>

  <p>Па аналёгіі, калі аб'ект <code>o</code> мае аб'яўленьне мэтаду <code>[]=</code>, каторы прымае 3 аргумэнты, тады выраз <code>o[x,y] = z</code> будзе на самай справе выкананы як:</p>

  <pre><code class="language-ruby">
o.[]=(x,y,z)
</code></pre>

  <h4 id="ExpressionsAndOperators_Operators_Assignments_Abbreviated">Скарочаныя формы прысваеньняў</h4>
  <p>Скарочаныя формы прысваеньняў камбінуюць прысваеньне з іншай апэрацыяй. Найбольш ужываныя з такіх прысваеньняў&nbsp;&ndash; гэта апэрацыі інкрымэнту і дэкрымэнту:</p>

  <pre><code class="language-ruby">
x += 1            # Эквівалентна x = x + 1
x -= 1            # Эквівалентна x = x - 1
</code></pre>

  <p>Яшчэ адна скарочаная форма, каторая ўжываецца часьцей за астатнія, гэта <code>||=</code>. Яна звычайна ўжываецца ў выпадку, калі трэба зьвярнуцца да масіву ці хэшу, каторыя могуць быць яшчэ не ініцыялізаваны (роўныя <code>nil</code>):</p>

  <pre><code class="language-ruby">
results ||= []

# Што эквівалентна:
results = results || []
</code></pre>

  <p>Такі выраз прывядзе да таго, што калі <code class="var">results</code> роўны <code>nil</code>, будзе выкананы правы апэранд булеўскай апэрацыі <code>||</code> і <code class="var">results</code> будзе праініцыялізаваны пустым масівам. Інакш, калі ён ня роўны <code>nil</code> (то бок ужо праініцыялізваны раней), ён застанецца нязьменным.</p>

  <h4 id="ExpressionsAndOperators_Operators_Assignments_Parallel">Паралельныя прысваеньні</h4>
  <p>Гэта прысваеньні, у каторых альбо cправа, альбо зьлева, альбо і там, і там больш чым адзін апэранд. Гэтыя множныя апэранды падзяляюцца паміж сабой коскамі, і перад некаторымі зь іх можа стаяць зорачка (тлумачэньне будзе ніжэй).</p>
  <p>Некаторыя варыянты такіх прысваеньняў даволі відавочныя, але ёсьць і складаныя. Таму разгледзем такія прысваеньні больш падрабязна:</p>

  <pre><code class="language-ruby">
# Аднолькавая колькасьць апэрандаў зьлева і справа:
x, y, z = 1, 2, 3         # x=1; y=2; z=3

x,y = y,x                 # Абмен значэньнямі, апэрацыі выконваюцца паралельна
x = y; y = x              # Ня тое ж самае, што вышэй: апэрацыі выконваюцца пасьлядоўна

# Адзін апэранд зьлева, шмат апэрандаў справа:
x = 1, 2, 3               # x = [1,2,3]
x, = 1, 2, 3              # x = 1; астатнія апэранды справа адкідваюцца

# Шмат апэрандаў зьлева, адзін масіў справа:
x, y, z = [1, 2, 3]       # Тое ж, што і: x,y,z = 1,2,3

# Больш за 1 апэранд зьлева і справа, але не аднолькавая іх колькасьць:
x, y, z = 1, 2            # x=1; y=2; z=nil
x, y = 1, 2, 3            # x=1; y=2; 3 адкідваецца

# Splat-апэрацыя (зорка перад апэрандам):
x, y, z = 1, *[2,3]       # Тое ж, што і: x,y,z = 1,2,3

x,*y = 1, 2, 3            # x=1; y=[2,3]
x,*y = 1, 2               # x=1; y=[2]
x,*y = 1                  # x=1; y=[]

# Толькі Ruby 1.9
*x,y = 1, 2, 3 # x=[1,2]; y=3
*x,y = 1, 2 # x=[1]; y=2
*x,y = 1 # x=[]; y=1

x, y, *z = 1, *[2,3,4]    # x=1; y=2; z=[3,4]

# Дужкі пры паралельным прысваеньні:
x,(y,z) = a, b            # Тое ж, што і: x = a; y,z = b

x,y,z = 1,[2,3]           # Бяз дужак: x=1; y=[2,3]; z=nil
x,(y,z) = 1,[2,3]         # З дужкамі: x=1; y=2; z=3
</code></pre>

</section>

<section>
  <h1 id="StatementsAndControl" data-content-item-open>Апэратары і кіруючыя структуры</h1>

  <h2 id="StatementsAndControl_Conditionals">Умоўнае выкананьне</h2>

  <h2 id="StatementsAndControl_Loops">Цыклі</h2>

  <h2 id="StatementsAndControl_Iterators">Ітэратары і пералічэньні</h2>

  <h2 id="StatementsAndControl_Blocks">Блёкі</h2>
  <p>Пэўны код, заключаны ў фігурныя дужкі альбо паміж ключавымі словамі <code>do</code> і <code>end</code>, называецца блёкам. Блёкі неабходны для групаваньня некалькіх інструкцыяў:</p>

  <pre><code class="language-ruby">
2.times {
  print "Hello!"
  print "Hello!"
}

loop do
  print "Much better."
  print "Ah.  More space!"
  print "My back was killin' me in those crab pincers."
end
</code></pre>

  <p>Блёкі можна асацыяваць з выклікамі мэтадаў. Такія мэтады могуць выклікаць тады гэтыя блёкі пры дапамозе ключавога слова <code>yield</code>:</p>

  <pre><code class="language-ruby">
def sampleMethod
  yield
  yield
end

sampleMethod { puts "In the block" }
</code></pre>

  <p>У выніку будзе выведзена на экран:</p>

  <pre><code class="language-bash">
In the block
In the block
</code></pre>

  <h3 id="StatementsAndControl_Blocks_Arguments">Аргумэнты блёкаў і ітэратары</h3>
  <p>У блёкі могуць перадавацца аргумэнты. У гэтым выпадку яны зьмяшчаюцца ў самым пачатку блёку, заключаюцца ў знакі вертыкальных ліній і падзяляюцца коскамі:</p>

  <pre><code class="language-ruby">
{ |x, y| x + y }
</code></pre>

  <p>У прыкладзе вышэй <code>x</code> і <code>y</code>&nbsp;&ndash; аргумэнты блёку, каторы ўтрымлівае адзіную інструкцыю&nbsp;&ndash; складаньне значэньняў гэтых аргумэнтаў.</p>
  <p>Аргумэнты блёкаў актыўна выкарыстоўваюцца ў ітэратарах:</p>

  <pre><code class="language-ruby">
a = ['ant', 'bee', 'cat', 'dog', 'elk']   # ствараем масіў радкоў
a.each { |animal| puts animal }           # ітэратар праходзіць праз элемэнты масіва,
                                          # якія перадаюцца ў якасьці аргумэнту animal у блёк
</code></pre>

    <p>У выніку на экран будзе выведзена:</p>

    <pre><code class="language-bash">
ant
bee
cat
dog
elk
</code></pre>

  <h2 id="StatementsAndControl_AlteringControlFlow">Зьмена нармальнай хады праграмы</h2>

  <h2 id="StatementsAndControl_Exceptions">Выключэньні і іх апрацоўка</h2>

  <h2 id="StatementsAndControl_Threads">Плыні і ніці</h2>
</section>

<section>
  <h1 id="MethodsAndProcs" data-content-item-open>Мэтады, працэдуры, лямбды і замыканьні</h1>

  <h2 id="MethodsAndProcs_Methods">Мэтады</h2>
  <p><a href="http://rubysource.com/functional-programming-techniques-with-ruby-part-ii/?utm_medium=email&utm_campaign=RubySource+3rd+April&utm_content=RubySource+3rd+April+CID_29d66d58498d41d09092a4ead0696666&utm_source=Newsletter&utm_term=Functional+Programming+Techniques+With+Ruby+Part+2">Functional Programming Techniques With Ruby</a></p>
  <p>Як ужо пазначалася вышэй мэтады&nbsp;&ndash; гэта запыты да аб'ектаў. Каб зрабіць выклік мэтаду, пазначаецца <a href="#ExpressionsAndOperators_Variables">зьменная</a> ці <a href="#ExpressionsAndOperators_Consts">канстанта</a>, пасьля каторай ставіцца кропка і потым імя мэтаду:</p>

  <pre><code class="language-ruby">
front_door.open
</code></pre>

  <p>Выклікі мэтадаў могуць ісьці адзін за адным, таму што, як мы памятаем, вынік мэтаду&nbsp;&ndash; гэта таксама аб'ект:</p>

  <pre><code class="language-ruby">
front_door.open.close
</code></pre>

  <p>Гэты складаны выклік кажа ўваходным дзьвярам адчыніцца і адразу ж зачыніцца. Імёны мэтадаў могуць утрымліваць клічнікі і пытальнікі:</p>

  <pre><code class="language-ruby">
front_door.is_open?
</code></pre>

  <p>Некаторыя мэтады зьяўляюцца ядром мовы і могуць быць выкліканы без пазначэньня экзэмпляру, да каторага яны адносяцца:</p>

  <pre><code class="language-ruby">
print "Hello!"
</code></pre>

  <p>Як гэта працуе? У <i>Ruby</i> на самым версе герархіі клясаў знаходзіцца кляса <code>Object</code>. Усе мэтады гэтай клясы, адпаведна, калі не перавызначыныя яўна, успадкоўваюцца ўсімі іншымі клясамі. Дык вось у <code>Object</code> <mark>дамешваецца</mark> модуль <code>Kernel</code> (<i>kernel</i> па ангельску азначае <i>ядро</i>). Адпаведна, <a href="http://www.ruby-doc.org/core/classes/Kernel.html">усе мэтады ядра мовы</a> даступны глябальна і без патрэбы пазначаць экземпляр нейкай клясы.</p>

  <h3 id="LangParts_Methods_redo">redo</h3>
  <p>Выклік <code>redo</code> у мэтадзе прыводзіць да яго ж выкліку яшчэ раз:</p>

  <pre><code class="language-ruby">
class LotteryTicket

  NUMERIC_RANGE = 1..25

  attr_reader :picks, :purchased

  def initialize(*picks)
    if picks.length != 3
      raise ArgumentError, "three numbers must be picked"
    elseif picks.uniq.length != 3
      raise ArgumentError, "the three pick must be different numbers"
    elseif picks.detect { |p| not NUMERIC_RANGE === p}
      raise ArgumentError, "the three pick must be numbers between 1 and 25"
  end

  @picks = picks
  @purchased = Time.now
end

def self.new_random
  new(rand(25) + 1, rand(25) + 1, rand(25) + 1)
rescue ArgumentError
  redo
end
</code></pre>

  <p>Калі ў выпадку выкліку <code>LotteryTicket.new_random</code> будуць згенерэны хаця б дзьве аднолькавыя лічбы, тады <code>picks.uniq.length != 3</code> прывядзе да кіданьня памылкі, але <code>rescue ArgumentError</code> зловіць яе, а <code>redo</code> выкліча мэтад <code>new_random</code> яшчэ раз і гэта ўсё столькі разоў, пакуль усе 3 лічбы ня будуць унікальнымі.</p>

  <h2 id="MethodsAndProcs_Methods_Arguments">Аргумэнты мэтадаў</h2>
  <p>Некаторыя мэтады патрабуюць дадатковую інфармацыю, каб выканаць свае дзеяньні. Гэтую інфармацыю ім перадаюць пры дапамозе аргумэнтаў, каторыя ідуць пасьля імені мэтаду, заключаюцца ў дужкі (не абавязкова) і падзяляюцца коскамі:</p>

  <pre><code class="language-ruby">
front_door.paint(3, :red)
</code></pre>

  <p>Калі перад аргумэнтам мэтаду стаіць зорачка, гэта азначае, што можа быць любая колькасьць фактычных парамэтраў мэтаду і яны будуць перададзеныя як масіў:</p>

  <pre><code class="language-ruby">
def initialize(*picks)
  if picks.length != 3
    raise ArgumentError, "three numbers must be picked"
  ...
end
</code></pre>


  <!-- TODO!!!! -->

  <h2 id="MethodsAndProcs_ProcsAndLambdas">Працэдуры і лямбды</h2>

  <h2 id="MethodsAndProcs_Closures">Замыканьні</h2>
</section>

<section>
  <h1 id="ClassesAndModules" data-content-item-open>Клясы і модулі</h1>

  <h2 id="ClassesAndModules_Classes">Клясы</h2>

  <h3 id="ClassesAndModules_Classes_Methods">Мэтады</h3>
  <p>Мэтады клясаў (аналяг статычных мэтадаў у <a href="../java/index.html"><span class="term">Java</span></a>) гэта запыты да клясаў, а не іх экзэмпляраў. Выклік адбываецца праз пазначэньне імені клясы, за каторым ідзе падвойнае двукропье і потым імя мэтаду:</p>

  <pre><code class="language-ruby">
Door::new(:oak)
</code></pre>

  <h3 id="ClassesAndModules_Classes_attrs">Атрыбуты</h3>
  <p>Уводзіць у клясу зьменныя <code>a</code> і <code>b</code>:</p>

  <pre><code class="language-ruby">
attr :a, :b
</code></pre>

  <p>Уводзіць у клясу зьменныя <code>a</code> і <code>b</code>, а таксама <i>getter</i>- і <i>setter</i>-мэтады для ніх:</p>

  <pre><code class="language-ruby">
attr_accessor :a, :b
</code></pre>

  <p>Уводзіць у клясу зьменныя <code>a</code> і <code>b</code>, а таксама <i>getter</i>-мэтады для ніх:</p>

  <pre><code class="language-ruby">
attr_reader :a, :b
</code></pre>

  <p>Уводзіць у клясу зьменныя <code>a</code> і <code>b</code>, а таксама <i>setter</i>-мэтады для ніх:</p>

  <pre><code class="language-ruby">
attr_writer :a, :b
</code></pre>

  <h2 id="ClassesAndModules_Modules">Модулі</h2>

  <h2 id="ClassesAndModules_Extending">Пашырэньне</h2>
  <p>Любая кляса, нават базавая, можа быць пашыраная:</p>

  <pre><code class="language-ruby">
class String
  def new_method_name
    p "Hello the World!"
  end
end

"asdf".new_method_name
</code></pre>

  <p>Папярэдні прыклад вывядзе ў кансоль <code>Hello the World!</code></p>

</section>

<section>
  <h1 id="Types">Стандартныя тыпы</h1>
  <p>Стандартныя тыпы, як лікі, радкі сымбаляў і інш.&nbsp;&ndash; гэта базавыя цаглінкі, з каторых будуецца Ruby-праграма.</p>

  <h2 id="Types_Object">Object</h2>
  <p><code>Object</code> у Ruby зьяўляецца базавай для астатніх клясаў, каторыя ўскосна ўспадкоўваюць ад яе. Хаця сама знаходзіцца не ў самым версе герархіі клясаў, а зьяўляецца спадчыннай ад клясы <code>BasicObject</code>.</p>

  <h3 id="Types_Object_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Object.html">Object</a></li>
    </ul>
  </div>
  <p>Разгледзем у гэтым разьдзеле асноўныя мэтады, каторыя вызначаюцца ў <code>Object</code>. Пры разглядзе іншых клясаў мэтады, прыведзеныя тут і сэнс каторых у тых клясах не зьмяняецца, рязглядацца ня будуць.</p>

  <h4 id="Types_Object_Methods_ID">Вызначэньне ID аб'екта</h4>

  <pre><code class="language-ruby">
# ніякія з любых двух аб'ектаў ня маюць аднолькавага ID
"Hello".object_id #=&gt; напр. 22628100
</code></pre>

  <h4 id="Types_Object_Methods_Class">Вызначэньне клясы аб'екта</h4>

  <pre><code class="language-ruby">
1.class           #=&gt; Fixnum
"Hello".class     #=&gt; String
</code></pre>

  <h4 id="Types_Object_Methods_InstanceOf">Праверка прыналежнасьці да клясаў</h4>

  <pre><code class="language-ruby">
module M;    end
class A
  include M
end
class B &lt; A; end
class C &lt; B; end
b = B.new
b.instance_of? A    #=&gt; false
b.instance_of? B    #=&gt; true
b.instance_of? C    #=&gt; false
b.instance_of? M    #=&gt; false
b.kind_of? A        #=&gt; true
b.kind_of? B        #=&gt; true
b.kind_of? C        #=&gt; false
b.kind_of? M        #=&gt; true
</code></pre>

  <p><code>instance_of?</code>&nbsp;&ndash; строгая праверка прыналежнасьці аб'екта да пэўнай клясы (без уліку герархіі і ўключаных модуляў). <code>kind_of?</code> (альбо <code>is_a?</code>)&nbsp;&ndash; мяккая праверка прыналежнасьці аб'екта да клясы, то бок ня толькі непасрэднай клясы, але і ўсёй герархіі клясаў альбо ўключаных модуляў (гл. прыклад вышэй). Будзьце ўважлівымі тыя, хто пераходзіць да вывучэньня Ruby з <a href="../java/index.html"><span class="term">Java</span></a>. Той сэнс, каторы рэалізаваны яваўскім <code>instance_of</code>, у Ruby рэалізуецца мэтадам <code>kind_of?</code> (альбо <code>is_a?</code>), а не <code>instance_of?</code>.</p>

  <h4 id="Types_Object_Methods_Compare">Апэрацыі параўнаньня</h4>

  <pre><code class="language-ruby">
# правярае ці спасылаюцца ідэнтыфікатары (зьменныя) на тыя ж самыя аб'екты
a = "Hello"
b = "Hello"
a.equal? b        #=&gt; false - ня гледзячы на тое, што a і b маюць адно
                  # і тое ж значэньне, спасылаюцца яны на розныя аб'екты

# звычайна, калі не пазначана інакш у адпаведнай клясе, параўнаньне значэньняў аб'ектаў:
1 == 1.0          #=&gt; true
a.eql? b          #=&gt; true (a i b - радкі "Hello", вызначаныя вышэй)

# параўноўвае значэньні аб'ектаў а-ля Comparable:
1 &lt;=&gt; 1           #=&gt; 0
1 &lt;=&gt; 2           #=&gt; -1
2 &lt;=&gt; 1           #=&gt; 1
</code></pre>

  <h4 id="Types_Object_Methods_nil">Праверка на <code>nil</code></h4>
  <p>Аб'ект, каторы нікуды не спасылаецца, ня проста "нішто", як напрыклад у <i>Java</i>, але пусты аб'ект, у каторага можна выклікаць пэўныя мэтады. Адным з такіх мэтадаў і зьяўляецца праверка на тое, пусты аб'ект ці не:</p>

  <pre><code class="language-ruby">
nil.nil?          #=&gt; true

a = 5
a.nil?            #=&gt; false
a = nil
a.nil?            #=&gt; true
</code></pre>

  <h4 id="Types_Object_Methods_Clone">Кланаваньне</h4>

  <pre><code class="language-ruby">
class Klass
    attr_accessor :str
end
s1 = Klass.new
s1.str = "Hello"    #=&gt; s1.str="Hello"
s2 = s1.clone       #=&gt; s2.str="Hello"
s3 = s1.dup         #=&gt; s3.str="Hello"
s2.str[1,4] = "i"   #=&gt; s1.str="Hi", s2.str="Hi", s3.str="Hi"
</code></pre>

  <p>Мэтады <code>clone</code> і <code>dup</code> у <code>Object</code> падобны&nbsp;&ndash; яны капіруюць зьменныя аднаго экзэмпляру ў іншы. Пры гэтым капіруюцца спасылкі, а не значэньні. Але адрозьніваюцца яны тым, што мэтад <code>clone</code> акрамя гэтага капіруе яшчэ і <a href="#Types_Object_Methods_Freeze"><code>frozen</code></a>-стан экзэмпляру, а <code>dup</code> гэтага ня робіць.</p>

  <h4 id="Types_Object_Methods_Freeze">Замарозка</h4>
  <p>Мэтад <code>freeze</code> прадухіляе аб'ект ад далейшых зьменаў.</p>

  <pre><code class="language-ruby">
a = [ "a", "b", "c" ]
a.freeze
a.frozen?           #=&gt; true
a &lt;&lt; "z"            #=&gt; prog.rb:4:in `&lt;&lt;': can't modify frozen array (RuntimeError)
                    #=&gt; from prog.rb:4
</code></pre>

  <h4 id="Types_Object_Methods_StrRepr">Радковае прадстаўленьне аб'ектаў</h4>

  <pre><code class="language-ruby">
class Klass
    attr_accessor :str
end
s1 = Klass.new
s1.str = "Hello"
s1.inspect          #=&gt; "#&lt;Klass:0x2922a68 @str=\"Hello\"&gt;"
s1.to_s             #=&gt; "#&lt;Klass:0x2922a68&gt;"
</code></pre>

  <p>Мэтад <code>inspect</code> вяртае радок, які ўтрымлівае чытэльнае чалавекам прадстаўленьне аб'екта. Мэтад <code>to_s</code>, вызначаны ў <code>Object</code>, вяртае імя клясы і ID аб'екта.</p>

  <h4 id="Types_Object_Methods_ClassStructure">Мэтады інспэкцыі структуры клясы</h4>
  <p>Асобнай групай стаяць мэтады інспэкцыі структуры клясы&nbsp;&ndash; вызначэнье якія ёсьць у аб'екта зьменныя, мэтады і іншыя атрыбуты:</p>

  <pre><code class="language-ruby">
class Klass
  attr_accessor :a1

  def initialize(p1)
    @a2 = 3
    @a3 = p1
  end

  def kMethod()
  end
end
k = Klass.new

# масіў усіх мэтадаў, каторыя могуць быць выкліканыя ў аб'екта:
k.methods           #=&gt; ["kMethod", "freeze", "nil?", "is_a?", "class", ... і гэтак далей

# масіў прыватных, пратэктэд і паблік мэтадаў, каторыя могуць быць выкліканыя ў аб'екта:
k.private_methods
k.protected_methods
k.public_methods

# правярае ці мае аб'ект пэўны мэтад:
k.respond_to?("aMethod")  #=&gt; false
k.respond_to?("kMethod")  #=&gt; true

# масіў зьменных аб'екта (зьвярніце ўвагу, што аб'яўленьне accessor'аў - a1 у нашым
# выпадку, не прыводзіць да ўстаўкі паўнавартасных зьменных):
k.instance_variables      #=&gt; [:@a1, :@a2]

# правярае ці мае аб'ект зьменную:
instance_variable_defined?(:@a1)      #=&gt; true
instance_variable_defined?("@a2")     #=&gt; true
instance_variable_defined?(:@b)       #=&gt; false
</code></pre>

  <h2 id="Types_Numbers">Лікі</h2>
  <figure style="float: right;">
    <img alt="Герархія ўбудаваных лікавых клясаў" title="Герархія ўбудаваных лікавых клясаў" src="{{ base_path }}/assets/images/ruby_numeric_types.png"/>
    <figcaption class="imgcaption">Герархія ўбудаваных лікавых клясаў</figcaption>
  </figure>
  <p>Ruby утрымлівае 5 убудаваных клясаў для прадстаўленьня цэлых і рэчаісных лікаў (гл. схему).</p>

  <h3 id="Types_Numbers_Integers">Цэлыя</h3>
  <p>Цэлыя лікі (экзэмпляры базавай для ўсіх цэлых лічбаў клясы <code>Integer</code>) складаюцца з пасьлядоўнасьці лічбаў, перад каторымі <i>можа</i> стаяць знак плюсу ці мінусу:</p>

  <pre><code class="language-ruby">
1, 23, -10000
</code></pre>

  <p>У мэтах візуальнага падзяленьня тысячаў у ліках дазваляецца выкарыстоўваць знак падкрэсьліваньня:</p>

  <pre><code class="language-ruby">
population = 12_000_000_000
</code></pre>

  <p>Цэлыя могуць быць адвольнай дліны ці памеру (аж да значэньня, каторае абмежавана даступнай свабоднай памяцьцю кампутара). У межах пэўнага дыяпазону (звычайна ад -2<sup>30</sup> да 2<sup>30</sup>-1 ці ад -2<sup>62</sup> да 2<sup>62</sup>-1) цэлыя прадстаўляюцца як аб'екты клясы <code>Fixnum</code>&nbsp;&ndash; малыя цэлыя. Калі ж яны выходзяць за гэты дыяпазон, то Ruby пераводзіць іх у аб'екты клясы <code>Bignum</code>&nbsp;&ndash; вялікія цэлыя, і наадварот. Прычым гэты працэс пераводу лікаў з <code>Fixnum</code> у <code>Bignum</code> і наадварот&nbsp;&ndash; празрысты для распрацоўшчыка, Ruby робіць гэта сам:</p>

  <pre><code class="language-ruby">
num = 8
7.times do
  print num.type, " ", num, "\n"
  num *= num
end
</code></pre>

  <p>У выніку на экран будзе выведзена:</p>

  <pre><code class="language-ruby">
Fixnum 8
Fixnum 64
Fixnum 4096
Fixnum 16777216
Bignum 281474976710656
Bignum 79228162514264337593543950336
Bignum 6277101735386680763835789423207666416102355444464034512896
</code></pre>

  <p>Цэлыя могуць быць таксама запісаныя ў васьмірычным, шаснаццацірычным ці дваічным выглядзе:</p>

  <pre><code class="language-ruby">
0377            # васьмірычны выгляд, з прэфіксам 0
0xaabb          # шаснаццацірычны выгляд, з прэфіксам 0x
0b101_010       # бінарны выгляд, з прэфіксам 0b
</code></pre>

  <p>Акрамя гэтага цэлы лік, як адлюстраваньне коду сымбалю, можна атрымаць паставіўшы знак пытальніку перад гэтым сымбалем:</p>

  <pre><code class="language-ruby">
?a              # код сымбалю 'a' (0x61)
?\n             # код пераводу радка (0x0a)
</code></pre>

  <h3 id="Types_Numbers_Float">Рэчаісныя</h3>
  <p>Рэчаісныя лікі (экзэмпляры клясы <code>Float</code>) складаюцца з пасьлядоўнасьці лічбаў і нефіксаванай кропкі ці навуковай натацыі:</p>

  <pre><code class="language-ruby">
3.14, -808.08, 12.043e-04
</code></pre>

  <p>Зьвярніце ўвагу, што пасьля нефіксаванай кропкі абавязкова павінна стаяць лічба:</p>

  <pre><code class="language-ruby">
1.e3            # у гэтым выпадку Ruby паспрабуе выклікаць мэтад e3 у цэлага 1
</code></pre>

  <h3 id="Types_Numbers_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Numeric.html">Numeric</a></li>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Integer.html">Integer</a></li>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Fixnum.html">Fixnum</a></li>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Bignum.html">Bignum</a></li>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Float.html">Float</a></li>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/BigDecimal.html">BigDecimal</a></li>
    </ul>
  </div>
  <p>Коратка пра мэтады, каторыя прадстаўляюцца лікамі (поўныя сьпісы і тлумачэньні даступныя па спасылкам зьлева):</p>

  <h4 id="Types_Numbers_Methods_Math">Матэматычныя апэрацыі</h4>

  <pre><code class="language-ruby">
1 + 2             #=&gt; 3 (складаньне)
5 - 3             #=&gt; 2 (адніманьне)
2 * 3             #=&gt; 6 (памнажэньне)
5 / 3             #=&gt; 1 (цэлалікавае дзяленьне)
6 / 4.0           #=&gt; 1.25 (рэчаіснае дзяленьне)
2 ** 3            #=&gt; 8 (ступень)
1.next            #=&gt; 2 (інкрэмэнт, тое ж што і 1.succ)
</code></pre>

  <h4 id="Types_Numbers_Methods_Binary">Бінарныя апэрацыі</h4>

  <pre><code class="language-ruby">
1 & 2             #=&gt; 3 (бінарнае AND)
1 ^ 5             #=&gt; 4 (бінарнае XOR)
1 | 3             #=&gt; 3 (бінарнае OR)
~4                #=&gt; 3 (бінарнае адмаўленьне)

4 >> 1            #=&gt; 2 (бінарны зрух управа, "хуткае дзяленьне на адпаведную ступень 2")
4 << 1            #=&gt; 8 (бінарны зрух улева, "хуткае памнажэньне на адпаведную ступень 2")
</code></pre>

  <h4 id="Types_Numbers_Methods_Compare">Апэрацыі параўнаньня</h4>

  <pre><code class="language-ruby">
1 &lt; 2             #=&gt; true (строгае меньш)
1 &gt; 2             #=&gt; false (строгае больш)
1 &lt;= 1            #=&gt; true (меньш альбо роўна)
2 &gt;= 1            #=&gt; true (больш альбо роўна)
1 == 1.0          #=&gt; true (параўнаньне значэньняў)

# параўноўвае значэньні а-ля Comparable:
1 &lt;=&gt; 1           #=&gt; 0
1 &lt;=&gt; 2           #=&gt; -1
2 &lt;=&gt; 1           #=&gt; 1

# параўноўвае тыпы і значэньні (true толькі калі роўныя і тыпы, і значэньні):
1.eql?(1.0)       #=&gt; false
(1.0).eql?(1.0)   #=&gt; true
</code></pre>

  <h4 id="Types_Numbers_Methods_CriteriaCheck">Праверкі адпавяданьня пэўнаму крытэру</h4>

  <pre><code class="language-ruby">
# правярае ці лік цэлы:
1.integer?        #=&gt; true
1.2.integer?      #=&gt; false

# правярае ці лік не нулявы:
1.nonzero?        #=&gt; 1
0.nonzero?        #=&gt; nil

# правярае ці лік нулявы:
1.zero?           #=&gt; false
0.zero?           #=&gt; true

# правярае ці лік цотны/няцотны:
2.even?           #=&gt; true
1.odd?            #=&gt; true
</code></pre>

  <h4 id="Types_Numbers_Methods_NumberTransform">Мэтады лікавых трасфармацый</h4>

  <pre><code class="language-ruby">
# модуль ліку:
-12.abs           #=&gt; 12

# бліжэйшае большае цэлае:
1.2.ceil          #=&gt; 2
(-1.2).ceil       #=&gt; -1

# бліжэйшае меншае цэлае:
1.2.floor         #=&gt; 1
(-1.2).floor      #=&gt; -2

# акругленьне і адкіданьне дробнай часткі:
1.5.round         #=&gt; 2
1.5.truncate      #=&gt; 1 (тое ж што і to_i, to_int для рэчаісных лікаў)
</code></pre>

  <h4 id="Types_Numbers_Methods_Iterators">Ітэратары</h4>

  <pre><code class="language-ruby">
5.times { |i| print i, " " }        #=&gt; 0 1 2 3 4
5.downto(1) { |i| print i, " " }    #=&gt; 5 4 3 2 1
5.upto(10) { |i| print i, " " }     #=&gt; 5 6 7 8 9 10
50.step(80, 5) { |i| print i, " " } #=&gt; 50 55 60 65 70 75 80
</code></pre>

  <h4 id="Types_Numbers_Methods_TypeTransform">Мэтады трасфармацый у іншыя тыпы</h4>

  <pre><code class="language-ruby">
# трансфармацыя ў сымбаль, чый код прадстаўляе лік:
65.chr                      #=&gt; "A"
255.chr(Encoding::UTF_8)    #=&gt; "\303\277"

# трансфармацыя ў радок:
12345.to_s        #=&gt; "12345" (то е ж што і 12345.to_s(10))
12345.to_s(2)     #=&gt; "11000000111001"
12345.to_s(16)    #=&gt; "3039"

# трансфармацыя ў рэчаісны лік (калі Bignum трансфармуецца і яго значэньне не зьмяшчаецца
# у Float, вынік будзе нявызначаны):
5.to_f            #=&gt; 5.0

# трансфармацыя ў цэлы лік:
1.5.to_i          #=&gt; 1 (тое ж што і to_int, trancate для рэчаісных лікаў)
</code></pre>

  <h4 id="Types_Numbers_Methods_DivideModulo">Мэтады дзяленьня і знаходжаньня астачы</h4>
  <p>Асобна спынімся на мэтадах дзяленьня і знаходжаньня астачы (рэшты) ад цэлага дзяленьня. Заўважым, што мэтад <code>divmod</code> вяртае не адно, а масіў значэньняў. Прычым, калі <code>q, r = x.divmod(y)</code>, тады:</p>

  <pre><code class="language-ruby">
q = floor(float(x)/float(y))
x = q*y + r
</code></pre>

  <p>Параўнаўчая табліца:</p>
  <pre>
           &nbsp;&nbsp;a &nbsp;&nbsp;| &nbsp;b | a.divmod(b) | a.div(b), a/b | a.modulo(b), a%b | a.remainder(b)
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;13 &nbsp;&nbsp;| &nbsp;4 | &nbsp;&nbsp;3, &nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;13 &nbsp;&nbsp;| -4 | &nbsp;-4, &nbsp;-3 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
           ------+----+-------------+---------------+------------------+---------------
           -13 &nbsp;&nbsp;| &nbsp;4 | &nbsp;-4, &nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-1
           ------+----+-------------+---------------+------------------+---------------
           -13 &nbsp;&nbsp;| -4 | &nbsp;&nbsp;3, &nbsp;-1 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-1
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;11.5 | &nbsp;4 | &nbsp;&nbsp;2, &nbsp;&nbsp;3.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;11.5 | -4 | &nbsp;-3, &nbsp;-0.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-0.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5
           ------+----+-------------+---------------+------------------+---------------
           -11.5 | &nbsp;4 | &nbsp;-3, &nbsp;&nbsp;0.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-3.5
           ------+----+-------------+---------------+------------------+---------------
           -11.5 | -4 | &nbsp;&nbsp;2, &nbsp;-3.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-3.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-3.5
        </pre>

  <h2 id="Types_Enumerable">Пералічэньне</h2>
  <p><mark>Модуль</mark> <code>Enumerable</code> не зьяўляецца самастойнай клясай, але <mark>дамешкам</mark> да іншых клясаў, каб надаць ім уласьцівасьці калекцыяў аб'ектаў.</p>

  <h3 id="Types_Enumerable_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Enumerable.html">Enumerable</a></li>
    </ul>
  </div>
  <p>Коратка пра мэтады, каторыя прадстаўляюцца пералічэньнямі (поўны сьпіс і тлумачэньне даступныя па спасылцы зьлева).</p>

  <h4 id="Types_Enumerable_Methods_Checking">Праверка элемэнтаў</h4>

  <pre><code class="language-ruby">
# правярае ці ўсе элемэнты задавальняюць умове;
# калі ўмова не задана, правярае ці ўсе элемэнты не nil (і не false):
["ant", "bear", "cat"].all? { |word| word.length &gt;= 3 }   #=&gt; true
[nil, true, 99].all?                                      #=&gt; false

# правярае ці хаця б адзін элемэнт задавальняе умове;
# калі ўмова не задана, правярае ці ёсьць хаця б адзін элемэнт не nil (альбо не false):
["ant", "bear", "cat"].any? { |word| word.length &gt;= 4 }   #=&gt; true
[nil, true, 99].any?                                      #=&gt; true

# правярае ці ніводны элемэнт не задавальняе умове;
# калі ўмова не задана, правярае ці ўсе элемэнты nil (альбо false):
["ant", "bear", "cat"].none? { |word| word.length &gt;= 4 }  #=&gt; false
[nil, false].none?                                        #=&gt; true

# правярае ці дакладна адзін элемэнт задавальняе умове;
# калі ўмова не задана, вярне true толькі, калі дакладна адзін элемэнт не nil (не false):
["ant", "bear", "cat"].one? { |word| word.length == 4 }   #=&gt; true
[nil, true, 99].one?                                      #=&gt; false

# вяртае true, калі хаця б адзін элемэнт пералічэньня роўны парамэтру:
["ant", "bear", "cat"].include?("cat")                    #=&gt; true
</code></pre>

  <h4 id="Types_Enumerable_Methods_Search">Пошук элемэнтаў</h4>

  <pre><code class="language-ruby">
# перадае кожны элемэнт пералічэньня ў блёк і вяртае першы зь іх, для каторага блёк вяртае true;
# калі ніводнага не было знойдзена, вяртаецца nil:
(1..10).detect { |i| i % 5 == 0 and i % 7 == 0 }          #=&gt; nil
(1..100).find { |i| i % 5 == 0 and i % 7 == 0 }           #=&gt; 35

# перадае кожны элемэнт пералічэньня ў блёк і вяртае масіў тых зь іх, для каторых блёк вяртае true:
(1..10).find_all { |i|  i % 3 == 0 }                      #=&gt; [3, 6, 9]

# вяртае індэкс першага з элемэнтаў, каторы задавальняе ўмове блёку, ці роўны аргумэнту:
(1..100).find_index { |i| i % 5 == 0 and i % 7 == 0 }     #=&gt; 34
(1..100).find_index(50)                                   #=&gt; 49

# вяртае максымальны з элемэнтаў пералічэньня:
a = %w(albatross dog horse)
a.max                                                     #=&gt; "horse"
a.max { |a,b| a.length &lt;=&gt; b.length }                     #=&gt; "albatross"

# вяртае мінімальны з элемэнтаў пералічэньня:
a = [1, 3, 5, 7]
a.min                                                     #=&gt; 1
</code></pre>

  <h4 id="Types_Enumerable_Methods_Rundown">Перабор элемэнтаў</h4>

  <pre><code class="language-ruby">
# выклікае ўнутраны блёк для кожнага элемэнту пералічэньня,
# вяртае масіў, які ўтрымлівае вынік выкананьня блёку для кожнага з элемэнтаў:
(1..4).collect {|i| i*i }                                 #=&gt; [1, 4, 9, 16]
</code></pre>

  <h2 id="Types_Strings">Сымбальныя чароды</h2>
  <p>Сымбальныя чароды&nbsp;&ndash; гэта пасьлядоўнасьць любых сымбаляў (літараў, лічбаў, знакаў прыпынку), якія ўзяты ў апострафы ці двукосьсе. Уключаюць у сябе <mark>дамешак</mark> <a href="#Types_Enumerable"><code>Enumerable</code></a>.</p>

  <pre><code class="language-text">
"sealab", '2021', ці "These cartoons are hilarious!"
</code></pre>

  <p>У сымбальных чародах, каторыя ўзятыя ў адзіночныя апострафы, дазваляюцца простыя <i>sequence</i>-пасьлядоўнасьці:</p>

  <pre><code class="language-ruby">
'escape using "\\"'     #=&gt; escape using "\"
'That\'s right'         #=&gt; That's right
</code></pre>

  <p>У сымбальных чародах, ўзятых ў двукосьсе, дазваляецца большая колькасьць <i>sequence</i>-пасьлядоўнасьцяў (напр. "\n"). Акрамя гэтага ў такія чароды можна падставіць любы выраз пры дапамозе <code>#{ }</code>:</p>

  <pre><code class="language-ruby">
"Seconds/day: #{24*60*60}"      #=&gt; Seconds/day: 86400
"#{'Ho! '*3}Merry Christmas"    #=&gt; Ho! Ho! Ho! Merry Christmas
"This is line #$."              #=&gt; This is line 3
</code></pre>

  <p>Каб пазначыць адзін сымбаль/знак (не чараду з аднаго знаку, а менавіта знак), перад ім ставіцца пытальнік:</p>

  <pre><code class="language-ruby">
"hello".index(?e)               #=&gt; 1
</code></pre>

  <h3 id="Types_Strings_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/String.html">String</a></li>
    </ul>
  </div>
  <p>Коратка пра мэтады, каторыя прадстаўляюцца чародамі (поўны сьпіс і тлумачэньне даступныя па спасылцы зьлева).</p>

  <h4 id="Types_Strings_Methods_Size">Памер чарады</h4>

  <pre><code class="language-ruby">
# правярае ці пустая чарада:
"hello".empty?      #=&gt; false
"".empty?           #=&gt; true

# вяртае колькасьць сымбаляў у чарадзе:
"hello".length      #=&gt; 5
"hi".size           #=&gt; 2
</code></pre>

  <h4 id="Types_Strings_Methods_Compare">Параўнаньне чародаў</h4>
  <p>Акрамя <a href="#Types_Object_Methods_Compare">стандартных мэтадаў параўнаньня</a>, у <code>String</code> яшчэ існуе мэтад параўнаньня чародаў аналягічны мэтаду <code>&lt;String&gt;&lt;=&gt;</code>, але без уліку рэгістру літар:</p>

  <pre><code class="language-ruby">
"abcdef".casecmp("abcde")     #=&gt; 1
"aBcDeF".casecmp("abcdef")    #=&gt; 0
"abcdef".casecmp("abcdefg")   #=&gt; -1
"abcdef".casecmp("ABCDEF")    #=&gt; 0
</code></pre>

  <h4 id="Types_Strings_Methods_Array">Паэлемэнтны доступ</h4>

  <pre><code class="language-ruby">
a = "hello there"
a[1]                  #=&gt; "e" (доступ да сымбалю з індэксам 1)
a[1,3]                #=&gt; "ell" (доступ да трох сымбаляў пачынаючы з індэксу 1)
a[1..3]               #=&gt; "ell" (доступ да сымбаляў з індэксамі 1..3)
a[-3,2]               #=&gt; "er" (у выпадку адмоўных значэньняў індэкс лічыцца з канца)
a[-4..-2]             #=&gt; "her"
a[12..-1]             #=&gt; nil
a[-2..-4]             #=&gt; ""
a[/[aeiou](.)\1/]     #=&gt; "ell" (у выпадку рэгулярных выразаў, вяртаецца знойдзеная чарада)
a[/[aeiou](.)\1/, 0]  #=&gt; "ell" (калі другім парамэтрам ідзе лік, вяртаецца адпаведны
a[/[aeiou](.)\1/, 1]  #=&gt; "l"   кампанэнт у MatchData)
a[/[aeiou](.)\1/, 2]  #=&gt; nil
a["lo"]               #=&gt; "lo"  (вяртаецца перададзеная ў якасьці аргумэнту чарада,
a["bye"]              #=&gt; nil   калі яна знойдзена ў якасьці падчарады ў зыходнай)
</code></pre>

  <p>Акрамя формы а-ля масіў, прыведзенай у прыкладзе вышэй, можна яшчэ ўжываць мэтад <code>slice</code>&nbsp;&ndash; бязь зьмены зыходнай чарады, ці <code>slice!</code>&nbsp;&ndash; са зьменай зыходнай чарады.</p>

  <h4 id="Types_Strings_Methods_ContentTransforms">Мадыфікацыя зьместу</h4>

  <pre><code class="language-ruby">
# "абнуленьне" чарады:
s = "Hello!"            #=&gt; "Hello!"
s.clear                 #=&gt; ""

# дубляваньне чарады пэўную колькасьць разоў:
"Ho! " * 3              #=&gt; "Ho! Ho! Ho! "

# злучэньне чародаў:
"Hello " + "world!"     #=&gt; "Hello world!"
a = "Hello "
a &lt;&lt; "world"            #=&gt; "Hello world"
a.concat(33)            #=&gt; "Hello world!" (калі ў выпадку << ці concat аргумэнтам
                        #   зьяўляецца цэлы лік, ён трактуецца як код знаку)

# пераварочваньне чарады (існуе форма reverse!):
"stressed".reverse      #=&gt; "desserts"

# устаўка і замена падчародаў:
"abcd".insert(0, 'X')   #=&gt; "Xabcd"
"abcd".insert(4, 'X')   #=&gt; "abcdX"
"abcd".insert(-3, 'X')  #=&gt; "abXcd"
"abcd".insert(-1, 'X')  #=&gt; "abcdX"
s = "hello"             #=&gt; "hello"
s.replace "world"       #=&gt; "world"

# адкідваньне з канца чарады знаку "перавод радка" (\n, \r ці \r\n), калі выкліканы без
# аргумэнтаў, ці падчарады, пазначанай ў якасьці аргумэнту (існуе форма chomp!):
"hello".chomp           #=&gt; "hello"
"hello\n".chomp         #=&gt; "hello"
"hello\r\n".chomp       #=&gt; "hello"
"hello\n\r".chomp       #=&gt; "hello\n"
"hello\r".chomp         #=&gt; "hello"
"hello \n there".chomp  #=&gt; "hello \n there"
"hello".chomp("llo")    #=&gt; "he"

# адкіданьне галаўных і канцавых прагалаў (для ўсіх 3х функцыяў існуюць варыянты з !):
"    hello    ".strip   #=&gt; "hello"
"\tgoodbye\r\n".strip   #=&gt; "goodbye"
"  hello  ".rstrip      #=&gt; "  hello"
"  hello  ".lstrip      #=&gt; "hello  "

# замена ў чарадзе яе пэўнай падчарады на іншую. sub - замяняе першую знойдзеную
# падчараду, gsub - усе знойдзеныя падчароды. Існуюць формы мэтадаў з !
"hello".gsub(/[aeiou]/, '*')                  #=&gt; "h*ll*"
"hello".gsub(/([aeiou])/, '&lt;\1&gt;')             #=&gt; "h&lt;e&gt;ll&lt;o&gt;"
"hello".gsub(/./) {|s| s[0].ord.to_s + ' '}   #=&gt; "104 101 108 108 111 "
"hello".gsub(/(?&lt;foo&gt;[aeiou])/, '{\k&lt;foo&gt;}')  #=&gt; "h{e}ll{o}"
</code></pre>

  <h4 id="Types_Strings_Methods_CaseTransforms">Мадыфікацыя рэгістру літар</h4>

  <pre><code class="language-ruby">
# першая літара чарады - з вялікай літары, астатнія - малыя (існуе форма з !):
"hello world".capitalize    #=&gt; "Hello world"
"HELLO".capitalize          #=&gt; "Hello"
"123ABC".capitalize         #=&gt; "123abc"

# усе літары чарады робіць вялікімі (існуе форма з !):
"hEllO".upcase              #=&gt; "HELLO"

# усе літары чарады робіць малымі (існуе форма з !):
"hEllO".downcase            #=&gt; "hello"

# робіць рэгістар літар зваротным (існуе форма з !):
"Hello".swapcase            #=&gt; "hELLO"
"cYbEr_PuNk11".swapcase     #=&gt; "CyBeR_pUnK11"
</code></pre>

  <h4 id="Types_Strings_Methods_Rundown">Паэлемэнтны перабор</h4>
  <p>Існуюць 4 мэтады: <code>bytes</code>, <code>chars</code>, <code>codepoints</code> і <code>lines</code>, а таксама іх аналягі з прэфіксам <code>each_</code>. Першыя чатыры, калі ім перадаецца блёк, аналягічныя апошнім чатыром. Калі ж яны выклікаюцца бяз блёку, то проста вяртаюць пералічэньне з байтаў, сымбаляў, кодаў ці радкоў адпаведна.</p>

  <pre><code class="language-ruby">
"hello".bytes.to_a                      #=&gt; [104, 101, 108, 108, 111]
"hello".each_byte {|c| print c, ' ' }   #=&gt; 104, 101, 108, 108, 111

"foo".chars.to_a                        #=&gt; ["f","o","o"]

"foo\nb ar".lines.sort                  #=&gt; ["b ar", "foo\n"]

"hello\u0639".each_codepoint {|c| print c, ' ' }    #=&gt; 104 101 108 108 111 1593
</code></pre>

  <h4 id="Types_Strings_Methods_Analysis">Разбор чарады</h4>

  <pre><code class="language-ruby">
# ці пачынаецца чарада з пазначанай падчарады:
"Hello".start_with?("He")       #=&gt; true

# ці ўключае чарада пазначаны падчараду:
"Hello".include?("Hi")          #=&gt; false

# вяртае індэкс, з каторага пазначаная падчарада уключаецца ў зыходную чараду:
"hello".index('e')              #=&gt; 1
"hello".index('lo')             #=&gt; 3
"hello".index('a')              #=&gt; nil
"hello".index(/[aeiou]/, -3)    #=&gt; 4 (калі другім аргумэнтам пазначаны цэлы лік, ён кажа зь
                                #      якога індэксу зыходнай чарады трэба пачынаць пошук)

# дзяленьне чарады па пэўным падзяляльнікам:
" now's  the time".split        #=&gt; ["now's", "the", "time"]
" now's  the time".split(' ')   #=&gt; ["now's", "the", "time"]
" now's  the time".split(/ /)   #=&gt; ["", "now's", "", "the", "time"]
"1, 2.34,56, 7".split(%r{,\s*}) #=&gt; ["1", "2.34", "56", "7"]
"hello".split(//)               #=&gt; ["h", "e", "l", "l", "o"]
"mellow yellow".split("ello")   #=&gt; ["m", "w y", "w"]

a = "cruel world"
a.scan(/\w+/)                   #=&gt; ["cruel", "world"]
a.scan(/.../)                   #=&gt; ["cru", "el ", "wor"]
a.scan(/\w+/) {|w| print "&lt;&lt;#{w}&gt;&gt; " }      #=&gt; &lt;&lt;cruel&gt;&gt; &lt;&lt;world&gt;&gt;

# таксама падзяляе чараду, але толькі на: 1. тое што да падзяляльніка; 2. падзяляльнік;
# 3. тое, што пасьля падзяляльніка. Існуе таксама форма rpartition, каторая шукае з канца.
"hello".partition("l")          #=&gt; ["he", "l", "lo"]
"hello".partition("x")          #=&gt; ["hello", "", ""]
"hello".partition(/.l/)         #=&gt; ["h", "el", "lo"]

# шукае ўваходжаньне <i>regexp</i>-патэрнаў у чарадзе і вяртае экзэмпляр MatchData
'hello'.match('(.)\1')          #=&gt; #&lt;MatchData "ll" 1:"l"&gt;
</code></pre>

  <h4 id="Types_Strings_Methods_Encoding">Кадоўка знакаў</h4>

  <pre><code class="language-ruby">
# атрыманьне цяперашняй кадоўкі знакаў чарады:
"Hello".encoding                #=&gt; #&lt;Encoding:IBM866&gt; (аб'ект клясы Encoding)

# ужыць кадоўку: мэтады encode, encode!, force_encoding
# больш падрабязна гл. афіцыйны даведнік

# праверыць ці кадоўка валідная:
"\xc2\xa1".force_encoding("UTF-8").valid_encoding?    #=&gt; true
"\xc2".force_encoding("UTF-8").valid_encoding?        #=&gt; false
"\x80".force_encoding("UTF-8").valid_encoding?        #=&gt; false
</code></pre>

  <h4 id="Types_Strings_Methods_TypeTransforms">Трансфармацыя ў іншыя тыпы</h4>

  <pre><code class="language-ruby">
# у рэчаісны лік:
"123.45e1".to_f         #=&gt; 1234.5
"45.67 degrees".to_d    #=&gt; 45.67
"thx1138".to_f          #=&gt; 0.0

# у цэлы лік:
"12345".to_i            #=&gt; 12345
"99 red balloons".to_i  #=&gt; 99
"0a".to_i               #=&gt; 0
"0a".to_i(16)           #=&gt; 10
"hello".to_i            #=&gt; 0
"1100101".to_i(16)      #=&gt; 17826049
</code></pre>

  <h2 id="Types_Arrays">Масівы</h2>
  <p>Масівы&nbsp;&ndash; гэта пасьлядоўнасьць значэньняў (неабавязкова аднолькавага тыпу), доступ да каторых можна атрымаць па іх парадкаваму нумару (індэксу). Нумарацыя элемэнтаў ў масіве пачынаецца з нуля. Нумараваць элемэнты можна ў тым ліку з канца, у гэтым выпадку індэкс будзе мець негатыўнае значэньне (<code>-1</code> адпавядае апошняму элемэнту, <code>-2</code>&nbsp;&ndash; перадапошняму і г.д.). Масівы ўключаюць у сябе дамешак <a href="#Types_Enumerable"><code>Enumerable</code></a></p>

  <pre><code class="language-ruby">
[1, 2, 3]                         # масіў лічбаў 1, 2, 3
['coat', 'mittens', 'snowboard']  # масіў сымбальных чародаў
[1, 'coat', 5, 7, 'snowboard']    # разнародны масіў
</code></pre>

  <h3 id="Types_Arrays_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Array.html">Array</a></li>
    </ul>
  </div>
  <p>Коратка пра мэтады, уласьцівыя масівам (поўны сьпіс і тлумачэньне даступныя па спасылцы зьлева).</p>

  <h4 id="Types_Arrays_Methods_Common">Агульнага прызначэньня</h4>

  <pre><code class="language-ruby">
a = [0, 1, 4, 9, 16]                  #=&gt; [0, 1, 4, 9, 16]
a[0] = "zero"                         #=&gt; ["zero", 1, 4, 9, 16]
a[-1] = 1..16                         #=&gt; ["zero", 1, 4, 9, 1..16]
a[8] = 64                             #=&gt; ["zero", 1, 4, 9, 1..16, nil, nil, nil, 64]
a[-9] = 81                            # Памылка: немагчыма дадаць элемэнт да пачатку масіва

a = ('a'..'e').to_a                   #=&gt; Дыяпазон пераўтвораны ў масіў ['a', 'b', 'c', 'd', 'e']
a[0,2] = ['A', 'B']                   #=&gt; ['A', 'B', 'c', 'd', 'e']
a[2...5]=['C', 'D', 'E']              #=&gt; ['A', 'B', 'C', 'D', 'E']
a[0,0] = [1,2,3]                      #=&gt; [1, 2, 3, 'A', 'B', 'C', 'D', 'E']
a[0..2] = []                          #=&gt; ['A', 'B', 'C', 'D', 'E']
a[-1,1] = ['Z']                       #=&gt; ['A', 'B', 'C', 'D', 'Z']
a[-1,1] = 'Z'                         #=&gt; тое ж самае, што і вышэй (калі адзіны элемэнт)
a[-2,2] = nil                         #=&gt; ['A', 'B', 'C'] у Ruby 1.8
                                      #=&gt; але ['A', 'B', 'C', nil, nil] у Ruby 1.9

a = [1, 2, 3] + [4, 5]                #=&gt; [1, 2, 3, 4, 5]
a = a + [[6, 7, 8]]                   #=&gt; [1, 2, 3, 4, 5, [6, 7, 8]]

['a', 'b', 'c', 'b', 'a'] - ['b', 'c', 'd']   #=&gt; ['a', 'a']

a = []                                #=&gt; []
a &lt;&lt; 1                                #=&gt; [1]
a &lt;&lt; 2 &lt;&lt; 3                           #=&gt; [1, 2, 3]
a &lt;&lt; [4,5,6]                          #=&gt; [1, 2, 3, [4, 5, 6]]

a = [0] * 8                           #=&gt; [0, 0, 0, 0, 0, 0, 0, 0]

a = [1, 1, 2, 2, 3, 3, 4]
b = [5, 5, 4, 4, 3, 3, 2]
a | b                                 #=&gt; [1, 2, 3, 4, 5]: выдаляюцца дублікаты
b | a                                 #=&gt; [5, 4, 3, 2, 1]: тое ж самае, што і вышэй,
                                      #=&gt; толькі парадак іншы
a & b                                 #=&gt; [2, 3, 4]: застаюцца толькі элемэнты, каторыя
                                      #=&gt; сустракаюцца ў абодвух масівах
b & a                                 #=&gt; [4, 3, 2]

# вяртае чараду, якая складаецца з усіх элемэнтаў масіву, пераведзеных у сымбальнае
# прадстаўленьне і падзеленых неабавязковым аргумэнтам (ня блытаць з concat):
["a", "b", "c"].join                  #=&gt; "abc"
["a", "b", "c"].join("-")             #=&gt; "a-b-c"

# аб'ядноўвае два масіва ў адзін (ня блытаць з join):
["a", "b"].concat(["c", "d"])         #=&gt; ["a", "b", "c", "d"]

# пераварочвае масіў:
["a", "b", "c"].reverse               #=&gt; ["c", "b", "a"]

# вяртае масіў, зь якога выдаленыя дублікаты зыходнага масіва:
a = ["a", "a", "b", "b", "c"]
a.uniq                                #=&gt; ["a", "b", "c"]

# выдаляе пэўныя элемэнты з масіву; вяртае значэньне выдаленага(-ых) элемэнту(-аў),
# калі такі меўся, ці nil у адваротным выпадку:
a = [ "a", "b", "b", "b", "c" ]
a.delete("b")                         #=&gt; "b"
a                                     #=&gt; ["a", "c"]
a.delete("b")                         #=&gt; nil

# устаўляе пазначаныя элемэнты перад тым, чый індэкс пазначаны ў якасьці аргумэнту:
a = %w{ a b c d }
a.insert(2, 99)                       #=&gt; ["a", "b", 99, "c", "d"]
a.insert(-2, 1, 2, 3)                 #=&gt; ["a", "b", 99, "c", 1, 2, 3, "d"]
</code></pre>

  <h4 id="Types_Arrays_Methods_StackQueue">Stack / Queue</h4>
  <p>Асобна прывядзем мэтады масіваў, каторыя мадэлююць зь іх чэргі, стэкі і сьпісы. А спачатку дыяграма гэтых мэтадаў для нагляднага азнаямленьня:</p>
  <figure>
    <img alt="Дыяграма стэкавых мэтадаў" title="Дыяграма стэкавых мэтадаў" src="{{ base_path }}/assets/images/ruby_stack_methods.png"/>
  </figure>

  <pre><code class="language-ruby">
# вяртае адзін (калі аргумэнт не зададзены ці роўны 1) ці некалькі
# (калі аргумэнт прысутнічае і большы за 1) апошніх элемэнтаў масіву і робіць масіў
# меншым на гэтую колькасьць элемэнтаў (зрухвае яго направа):
a = ["a", "b", "c", "d"]
a.pop                                 #=&gt; "d"
a                                     #=&gt; ["a", "b", "c"]
a.pop(2)                              #=&gt; ["b", "c"]
a                                     #=&gt; ["a"]

# дадае пазначаны(я) элемэнт(ы) да канца масіву; у якасьці выніку вяртае новы масіў,
# таму выклікі мэтаду могуць ісьці адзін за адным:
a = ["a", "b", "c"]
a.push("d", "e", "f")                 #=&gt; ["a", "b", "c", "d", "e", "f"]

# вяртае першы элемэнт масіву, адначасова выдаляючы яго з масіву і робячы масіў меншым
# (зрухвае яго налева). Калі масіў пусты, вяртае nil. Калі выклікаецца з аргумэнтам (n),
# вяртае масіў першых n элемэнтаў і выдаляе/памяншае зыходны масіў на гэную колькасьць элемэнтаў:
args = [ "-m", "-q", "filename" ]
args.shift                            #=&gt; "-m"
args                                  #=&gt; ["-q", "filename"]

args = [ "-m", "-q", "filename" ]
args.shift(2)                         #=&gt; ["-m", "-q"]
args                                  #=&gt; ["filename"]

# дадае пазначаны(я) элемэнт(ы) да пачатку масіву, зрухваючы зыходныя элемэнты масіву направа:
a = [ "b", "c", "d" ]
a.unshift("a")                        #=&gt; ["a", "b", "c", "d"]
a.unshift(1, 2)                       #=&gt; [ 1, 2, "a", "b", "c", "d"]
</code></pre>

  <h2 id="Types_Hashes">Хэшы</h2>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Hash.html">Hash</a></li>
    </ul>
  </div>
  <p>Хэшы&nbsp;&ndash; гэта структуры даных, у каторых пэўным ключам пастаўлены ў адпаведнасьць іх значэньні (пару ключ/значэньне будзем называць вызначэньнем). Шэраг вызначэньняў заключаны паміж фігурнымі дужкамі, а вызначэньні ў гэтым шэрагу падзелены паміж сабой коскамі. Паміж ключом і яго значэньнем стаяць знакі <code>=&gt;</code>:</p>

  <pre><code class="language-ruby">
{'a' =&gt; 'aardvark', 'b' =&gt; 'badger'}
</code></pre>

  <p>Хэшы ўключаюць у сябе дамешак <a href="#Types_Enumerable"><code>Enumerable</code></a>.</p>
  <p>У адрозьненьне ад масіваў значэньні хэшаў утрымліваюцца <strong>не</strong>пасьлядоўна і доступ да іх адбываецца не па парадкаваму нумару, а па яго ключу.</p>

  <h2 id="Types_Ranges">Дыяпазоны</h2>
  <p>Дыяпазоны паўсюдна сустракаюцца ў штодзённым жыцьці: са студзеня па люты, ад 0 да 9, радкі з 57 па 60 і г.д. Ruby падтрымлівае гэтыя існасьці праз тып <code>Range</code>. Прычым у Ruby гэты тып выкарыстоўваецца для прадстаўленьня <i>пасьлядоўнасьцей</i>, <i>умоваў</i> і <i>інтэрвалаў</i>. Дыяпазоны ўключаюць у сябе дамешак <a href="#Types_Enumerable"><code>Enumerable</code></a>.</p>

  <h3 id="Types_Ranges_AsSequences">Як пасьлядоўнасьці</h3>
  <p>Найбольш натуральнае выкарыстаньне дыяпазонаў&nbsp;&ndash; для прадстаўленьня пасьлядоўнасьцяў. Запісваюцца яны праз пазначэньне пачатковага значэньня, потым ідзе <a href="#ExpressionsAndOperators_Operators_Ranges">апэрацыя дыяпазону</a>, пасьля каторай пазначаецца канцавое значэньне пасьлядоўнасьці. Апэрацыя дыяпазону можа быць альбо <code>..</code> (з уключэньнем апошняга пазначанага значэньня пасьлядоўнасьці), альбо <code>...</code> (без уключэньня апошняга значэньня):</p>

  <pre><code class="language-ruby">
'a'..'z'                # пасьлядоўнасьць усіх радковых літар лацінскага альфабэту
1...9                   # пасьлядоўнасьць лічбаў ад 1 па 8 уключна, без уліку апошняга значэньня 9
</code></pre>

  <p>Унутрана дыяпазоны захоўваюцца ня ў выглядзе сьпісу з усіх значэньняў, а ў выглядзе пачатковага і канцавога значэньняў. Таму, каб атрымаць сьпіс значэньняў, трэба выклікаць мэтад <code>to_a</code>, каторы пераўтворыць дыяпазон у масіў усіх яго значэньняў:</p>

  <pre><code class="language-ruby">
1..10                   #=&gt; 1..10 (выводзіць не пералік усіх значэньняў, а пачатковае і канцавое)
(1..10).to_a            #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (пералік усіх значэньняў)
</code></pre>

  <p>Дыяпазоны можна ўтвараць ня толькі з лікаў ці сымбаляў, але і з любых іншых аб'ектаў. Але існуюць пэўныя патрабаваньні да клясаў, чые экзэмпляры могуць утвараць дыяпазоны: 1. утрымліваць <mark>дамешак</mark> <code>Comparable</code> і, адпаведна, <em>правільна</em> рэалізоўваць мэтад <code>&lt;=&gt;</code>; 2. рэалізоўваць мэтад <code>succ</code>, які вяртае наступны элемэнт у дыяпазоне:</p>

  <pre><code class="language-ruby">
class VU
  include Comparable

  attr :volume

  def initialize(volume)  # 0..9
    @volume = volume
  end

  def inspect
    '#' * @volume
  end

  # Рэалізоўваем падтрымку дыяпазонаў:

  def &lt;=&gt;(other)
    self.volume &lt;=&gt; other.volume
  end

  def succ
    raise(IndexError, "Значэньне завялікае") if @volume &gt;= 9
    VU.new(@volume.succ)
  end
end
</code></pre>

  <p>Пасьля гэтага магчымае наступнае ўжываньне:</p>

  <pre><code class="language-ruby">
m = VU.new(4)..VU.new(7)
m.to_a                       #=&gt; [####, #####, ######, #######]
m.include?(VU.new(3))        #=&gt; false
</code></pre>

  <h3 id="Types_Ranges_AsConditions">Як умовы</h3>
  <p>Акрамя пасьлядоўнасьцяў дыяпазоны ўжываюцца ў якасьці ўмоўных выразаў:</p>

  <pre><code class="language-ruby">
while input = gets
  puts input if input =~ /start/ .. input =~ /end/
end
</code></pre>

  <h3 id="Types_Ranges_AsIntervals">Як інтэрвалы</h3>
  <p>А яшчэ дыяпазоны ўжываюцца для праверкі ці ўваходзіць значэньне ў пэўны інтэрвал пры дапамозе апэрацыі <code>===</code>:</p>

  <pre><code class="language-ruby">
(1..10) === 5              #=&gt; true    (5 уваходзіць у інтэрвал значэньняў ад 1 да 10
(1..10) === 15             #=&gt; false    а 15 не ўваходзіць)
</code></pre>

  <p>Апэрацыя <code>===</code> яшчэ называецца <code>case</code>-параўнальнай, таму што выкарыстоўваецца ў <mark>аператары <code>case</code></mark>, калі ў ім ужываюцца дыяпазоны:</p>

  <pre><code class="language-ruby">
score = 70

result = case score
  when 0..40 then "Fail"
  when 41..60 then "Pass"
  when 61..70 then "Pass with Merit"
  when 71..100 then "Pass with Distinction"
  else "Invalid Score"
end                         #=gt; "Pass with Merit"
</code></pre>

  <h3 id="Types_Ranges_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Range.html">Range</a></li>
    </ul>
  </div>
  <p>Коратка пра мэтады, каторыя прадстаўляюцца дыяпазонамі (поўны сьпіс і тлумачэньне даступныя па спасылцы зьлева):</p>

  <pre><code class="language-ruby">
# атрымаць першы(-я) элемэнт(-ы) дыяпазону:
(1..5).begin                #=&gt; 1
(1..5).first                #=&gt; 1
(1..5).first(2)             #=&gt; [1, 2]

# атрымаць апошні(-я) элемэнт(-ы) дыяпазону:
(1..5).end                  #=&gt; 5
(1..5).last                 #=&gt; 5
(1..5).last(2)              #=&gt; [4, 5]

# ці ўваходзіць значэньне ў дыяпазон:
(1..5) === 3                #=&gt; true
('A'..'Z').include?('a')    #=&gt; false  (акрамя мэтаду include? можа ўжывацца яшчэ і member?)

# перабор кожнага элемэнту:
sum = 0
(1..5).each do |i|
  sum += i
end
puts sum                    #=&gt; 15

# перабор кожнага n-га элемэнту:
(1..5).step(2) do |i|
  print i.to_s + ' '
end                         #=&gt; 1 3 5

# пераўтварэньне ў масіў з выдаленьнем значэньняў па ўмове:
(1..9).reject { |i| i &lt; 5 } #=&gt; [5, 6, 7, 8, 9]
</code></pre>

  <h2 id="Types_Symbols">Сымбалі</h2>
  <p>Інтэпрэтатар Ruby рэалізуе табліцу так званых сымбаляў (<i>Symbols</i>), у каторай ён захоўвае імёны ўсіх клясаў, мэтадаў і зьменных. Гэта дазваляе пазьбегнуць некаторых цяжкіх апэрацыяў параўнаньня сымбальных чародаў (<i>Strings</i>): інтэрпрэтатар атрымлівае доступ да, напрыклад, мэтаду па яго парадкаваму нумару ў табліцы, а не па яго імені.</p>
  <p>У Ruby ідэя сымбаляў рэалізавана нават яшчэ на крок далей&nbsp;&ndash; да сымбаляў можна зьвяртацца ў самой праграме. Яны выглядаюць амаль як лякальныя зьменныя, але перад імі ставіцца двукроп'е і азначаюць яны палегчаныя радкі&nbsp;&ndash; стварыўшыся аднойчы, яны застаюцца ў памяці да канца працы праграмы і пры наступным выкарыстаньні проста бяруцца з памяці, а не ствараюцца па-новай. Вобласьць іх ужываньня&nbsp;&ndash; унутры праграмы, то бок гэта ня тыя радкі, каторыя прызначаныя для паказу карыстальніку. Прыклады:</p>

  <pre><code class="language-ruby">
:a, :b, ці :ponce_de_leon
</code></pre>

  <p>Наступны прыклад правярае ці мае аб'ект <code>o</code> вызначэньне мэтаду <code>size</code>, і калі так, выклікае гэты мэтад:</p>

  <pre><code class="language-ruby">
name = :size
if o.respond_to? name
  o.send(name)
end
</code></pre>

  <p>Сымбалі можна пераўтвараць у чароды і наадварот:</p>

  <pre><code class="language-ruby">
str = "string"              #=&gt; str - сымбальная чарада "string"
sym = str.to_sym            #=&gt; sym - сымбаль :string
str = sym.to_s              #=&gt; адваротнае пераўтварэньне
</code></pre>

  <p>Важнай асаблівасьцю зьяўляецца тое, што дзьве сымбальныя чароды могуць утрымліваць аднолькавы зьмест, але зьяўляцца двумя рознымі аб'ектамі, а для сымбаляў гэта ня так. Два радкі з аднолькавым зьместам пры канвертацыі ў сымбаль дадуць адзін і той жа аб'ект.</p>

  <h2 id="Types_BooleanNil"><code>true</code>, <code>false</code>, <code>nil</code></h2>
  <p>Ключавыя словы <code>true</code> і <code>false</code> прадстаўляюць булеўскія значэньні. Прычым асобнай клясы <code>Boolean</code> у Ruby не існуе. Выкарыстаньне <code>true</code> эквівалентна выкарыстаньню <i>singleton</i>-экзэпляра клясы <code>TrueClass</code>, а выкарыстаньне <code>false</code> эквівалентна выкарыстаньню <i>singleton</i>-экзэпляра клясы <code>FalseClass</code>. <code>nil</code>&nbsp;&ndash; гэта адмысловы <i>singleton</i>-экзэпляр клясы <code>NilClass</code>, каторы прадстаўляе пусты ці &laquo;неіснуючы&raquo; аб'ект.</p>
  <p>Трэба памятаць, што <code>true</code>, <code>false</code> і <code>nil</code>&nbsp;&ndash; аб'екты, не лічбы. Гэта азначае, што <code>false</code> і <code>nil</code> ня тое ж самае, што <code>0</code>, а <code>true</code> ня тое ж самае, што <code>1</code>. У месцах, дзе патрабуецца булеўскае значэньне, <code>nil</code> трактуецца як <code>false</code>, а значэньні адрозныя ад <code>nil</code> і <code>false</code> трактуюцца як <code>true</code>.</p>

  <h2 id="Types_Regexp">Рэгулярныя выразы</h2>
  <p>Рэгулярныя выразы (<i>regexp</i>)&nbsp;&ndash; пасьлядоўнасьць сымбаляў, заключаных паміж слэшаў:</p>

  <pre><code class="language-ruby">
  /ruby/, /[0-9]+/ ці /^\d{3}-\d{3}-\d{4}/
  </code></pre>

  <p>Яны прызначаны для хуткага пошуку словаў ці патэрнаў у тэксьце.</p>
</section>

<section>
  <h1 id="RSpec">RSpec</h1>
  <p><i>RSpec</i>&nbsp;&ndash; гэта фрэймворк <i>Unit</i>-тэставаньня і функцыянальнага тэставаньня для <i>Ruby</i>. </p>

  блёк describe апісвае паводзіны клясы
  <br />
  тэсты запісваюцца пры дапамозе блёку it
  <br />
  блёкі before і after - выконваюцца да і пасьля тэстаў. :all - аднойчы перад усімі тэстамі, :each - перад кожным тэстам


  <pre><code class="language-ruby">
describe MyClass do
  describe ".class_method_1" do
  end

  describe "#instance_method_1" do
  end
end
</code></pre>



  <p><a href="http://marakana.com/s/post/1145/efficient_rail_test-driven_development_course">http://marakana.com/s/post/1145/efficient_rail_test-driven_development_course</a></p>
  <p><a href="http://betterspecs.org/">http://betterspecs.org/</a></p>
  <p><a href="http://benscheirman.com/2011/05/dry-up-your-rspec-files-with-subject-let-blocks">http://benscheirman.com/2011/05/dry-up-your-rspec-files-with-subject-let-blocks</a></p>
  <p><a href="http://eggsonbread.com/2010/03/28/my-rspec-best-practices-and-tips/">http://eggsonbread.com/2010/03/28/my-rspec-best-practices-and-tips/</a></p>
  <p><a href="http://blog.emson.co.uk/2008/06/understanding-rspec-stories-a-tutorial/">http://blog.emson.co.uk/2008/06/understanding-rspec-stories-a-tutorial/</a></p>
  <p><a href="http://blog.davidchelimsky.net/category/rspec/">http://blog.davidchelimsky.net/category/rspec/</a></p>
  <p><a href="http://rubydoc.info/gems/rspec-core">http://rubydoc.info/gems/rspec-core</a></p>
  <p><a href="http://rubydoc.info/find/github?q=RSpec">http://rubydoc.info/find/github?q=RSpec</a></p>
</section>

<section>
  <h1 id="Gems">Gems</h1>
  <div class="refs">
    <ul>
      <li><a href="http://rubygems.org/">Home</a></li>
      <li><a href="http://docs.rubygems.org/">Docs</a></li>
    </ul>
  </div>
  <p><a href="http://rubygems.org/gems/airbrake">airbrake - Send your application errors to our hosted service and reclaim your inbox.</a></p>
  <p>Pry: адладка тэстаў. </p>

  <pre data-line="2,4"><code class="language-ruby">
describe 'System Status (Resource Monitor)' do
  require 'pry'
  before(:all) do
    binding.pry
    @data = $dut.execute_ok('support_info', 'status', {})
    @info = @data[:info]
  end
&hellip;
</code></pre>

  <p>Выкананьне тэсту спыніцца на 4 радку з прапановай irb.</p>

  <h2 id="Gems_DevKit">DevKit</h2>
  <div class="refs">
    <ul>
      <li><a href="http://rubyinstaller.org/add-ons/devkit/">Home</a></li>
      <li><a href="https://github.com/oneclick/rubyinstaller/wiki/development-kit/">Wiki</a></li>
    </ul>
  </div>
  <p>Большасьць гемаў даступны ў бінарным выглядзе і для іх усталёўкі дастаткова набраць <code>gem install &lt;GEM_NAME&gt;</code>. Але гэта тычыцца ня ўсіх гемаў. Некаторыя зь іх, так называемыя натыўныя, даступны толькі ў выглядзе зыходнікаў (напр. на C/C++) і для іх "зборкі" патрэбна пашырэньне да <i>Ruby</i> пад назвай <i>Development Kit</i> (скарочана <i>DevKit</i>).</p>

  <h3 id="Gems_DevKit_install">Усталёўка</h3>
  <p>Па-першае спампоўваем архіў усталёўшчыка <code>DevKit-tdm-32-4.5.1-20101214-1400-sfx.exe</code> (ці больш актуальную вэрсію) на старонцы <a href="https://github.com/oneclick/rubyinstaller/downloads/">https://github.com/oneclick/rubyinstaller/downloads</a>.</p>
  <p>Запускаем спампаваны файл і пазначаем тэчку для распакоўкі, напр. <code>&lt;RUBY_HOME&gt;\devkit</code>.</p>
  <p>Адкрываем акно каманднага радку <code>cmd</code> і пераходзім у ім у пазначаную вышэй для распакоўкі тэчку.</p>
  <p>У акне каманднага радку пасьлядоўна запускаем наступныя каманды:</p>

  <pre><code class="language-bash">
$ ruby dk.rb init
</code></pre>

  <p>Вынік якой будзе прыкладна такім:</p>
  <p><img alt="ruby dk.rb init" title="ruby dk.rb init" src="{{ base_path }}/assets/images/devkit1.png"/></p>
  <p>Далей:</p>

  <pre><code class="language-bash">
$ ruby dk.rb review
</code></pre>

  <p>Вынік каторай будзе прыкладна такім:</p>
  <p><img alt="ruby dk.rb review" title="ruby dk.rb review" src="{{ base_path }}/assets/images/devkit2.png"/></p>
  <p>На гэтым этапе трэба пераканацца, што ўсталёўшчык правільна падхапіў шлях да вашай <i>Ruby</i>-усталёўкі. Калі шлях ня правільны, тады трэба адпаведна падправіць файл <code>&lt;RUBY_HOME&gt;\devkit\config.yml</code>.</p>
  <p>Ну і напрыканцы непасрэдна ўсталёўка:</p>

  <pre><code class="language-bash">
$ ruby dk.rb install
</code></pre>

  <p>Вынік якой будзе прыкладна такім:</p>
  <p><img alt="ruby dk.rb install" title="ruby dk.rb install" width="920px" src="{{ base_path }}/assets/images/devkit3.png"/></p>

  <h3 id="Gems_DevKit_Check">Праверка</h3>
  <p>Запусьціць усталёўку натыўнага гема і тым самым спраўдзіць ці правільна ўсталяваўся <code>DevKit</code> можна наступным чынам:</p>

  <pre><code class="language-bash">
$ gem install ruby-debug19 --platform=ruby
</code></pre>

</section>
