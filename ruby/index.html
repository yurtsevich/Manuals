---
title: Даведнік па Ruby
description: Даведнік па Ruby па-беларуску
disqus_shortname: davednik-pa-ruby
---

<section>
  <h1 id="TODO">TODO</h1>
  <p><a href="https://github.com/markets/awesome-ruby">Awesome Ruby</a>&nbsp;&ndash; a collection of awesome Ruby libraries, tools, frameworks and software.</p>
  <p><a href="https://blog.engineyard.com/2015/five-ruby-methods-you-should-be-using">Five Ruby Methods You Should Be Using</a></p>
</section>

<section>
  <h1 id="Links">Карысныя спасылкі</h1>
  <h2 id="Links_Home">Хатняя старонка</h2>
  <p><a href="http://www.ruby-lang.org/">http://www.ruby-lang.org</a></p>

  <h2 id="Links_Docs">Дакумэнтацыя</h2>
  <p><a href="http://ruby-doc.org/">http://ruby-doc.org</a>&nbsp;&ndash; афіцыйная старонка, на якой сабраныя спасылкі да рознага кшталту дакумэнтацыі і літаратуры.</p>

  <h2 id="Links_API">API</h2>
  <p>Ядро мовы (вэр. 2.1.1): <a href="http://ruby-doc.org/core">http://ruby-doc.org/core</a></p>
  <p>Стандартная бібліятэка (<i>StdLib</i>): <a href="http://www.ruby-doc.org/stdlib/">http://www.ruby-doc.org/stdlib</a></p>
  <p>Інтэрактыўная шпаргалка на <b>OverAPI</b>: <a href="http://overapi.com/ruby/">http://overapi.com/ruby/</a></p>

  <h2 id="Links_CodingStyle">Стыль коду</h2>
  <p>Стыль аздабленьня коду ад <b>GitHub</b>: <a href="https://github.com/styleguide/ruby">https://github.com/styleguide/ruby</a></p>

  <h2 id="Links_Refs">Даведнікі і кнігі</h2>
  <h3 id="Links_Refs_Beginners">Пачаткоўцам</h3>
  <p><a href="http://www.rubyist.net/~slagell/ruby/">Ruby user's guide</a></p>
  <p><a href="http://rubylearning.com/satishtalim/tutorial.html">Core Ruby Programming</a></p>
  <p><a href="http://mislav.uniqpath.com/poignant-guide/">Poignant-guide</a>&nbsp;&ndash; сьцёбны, арыгінальны, але прыдатны толькі для першапачатковага паглыбленьня ў мову вучэбнік.</p>
  <p><a href="http://ruby.learncodethehardway.org/book/">Learn Ruby The Hard Way</a></p>

  <h3 id="Links_Refs_Intermediate">Адмыслоўцам</h3>
  <p><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/">Programming Ruby</a>&nbsp;&ndash; электронны варыянт першага выданьня адпаведнай кнігі ад <a href="http://pragprog.com/">The Pragmatic Programmers</a>.</p>
  <p><a href="http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177">The Ruby Programming Language</a> (першае выданьне папяровай кнігі, напісанай <a href="http://www.amazon.com/David-Flanagan/e/B000APEZR4" title="Старонка, прысьвечаная Дэвіду Флэнэгэну на Amazon.com">Дэвідам Флэнэгэнам</a> і <a href="http://www.amazon.com/Yukihiro-Matsumoto/e/B001IGNN6I" title="Старонка, прысьвечаная Юкіхіро Мацумото на Amazon.com">Юкіхіро Мацумото</a> ад выдавецтва <a href="http://oreilly.com/" title="Хатняя старонка выдавецтва O'Reilly">O'Reilly</a>&nbsp;&ndash; на мой погляд лепшая крыніца, з тых што мне трапляліся, паглыбленага вывучэньня <i>Ruby</i>, але на жаль электроннага варыянту няма ў вольным доступе).</p>

  <h2 id="Links_Courses">Курсы</h2>
  <p>Курс на <a href="http://www.codecademy.com/">codecademy.com</a>: <a href="http://www.codecademy.com/tracks/ruby">http://www.codecademy.com/tracks/ruby</a></p>
  <p><i>Інтэрактыўныя ўрокі</i> для пачаткоўцаў на <b>LearnStreet.com</b>: <a href="http://www.learnstreet.com/lessons/study/ruby">http://www.learnstreet.com/lessons/study/ruby</a></p>
  <p>Сэрыя курсаў на <a href="http://rubymonk.com/">rubymonk.com</a></p>

  <h2 id="Links_Blogs">Блогі</h2>
  <p>Апошнія <i>Ruby &amp; Rails</i> навіны на <b>envylabs.com</b>: <a href="http://ruby5.envylabs.com/">http://ruby5.envylabs.com/</a></p>
  <p>Functional Ruby, Code Beauty, and Ruby Internals&nbsp;&ndash; <a href="http://rubylove.io/">RubyLove</a></p>

  <h2 id="Links_Gems">Gems</h2>
  <p>Хатняя старонка: <a href="http://rubygems.org/">http://rubygems.org</a></p>
  <p>Як шукаць і ўсталёўваць бібліятэкі: <a href="http://www.ruby-lang.org/en/libraries/">http://www.ruby-lang.org/en/libraries</a></p>
  <p>Bundler: <a href="http://gembundler.com/">http://gembundler.com</a></p>
</section>

<section>
  <h1 id="Versions">Вэрсіі Ruby</h1>
  <p>Перад тым, як перайсьці да разгляду самой мовы, спынімся на гісторыі зьменаў яе вэрсіяў.</p>

  <h2 id="Versions_History">Гісторыя</h2>
  <div class="refs">
    <ul>
      <li><a href="https://www.ruby-lang.org/en/news">Home</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)#History">Wiki</a></li>

    </ul>
  </div>
  <table>
    <thead>
    <tr>
      <th colspan="2">Вэрсія</th>
      <th rowspan="2">Выхад</th>
      <th rowspan="2">Закрыцьцё</th>
      <th rowspan="2">Асаблівасьць</th>
    </tr>
    <tr>
      <th>Major</th>
      <th>Minor</th>
    </tr>
    </thead>
    <tbody>
    <tr class="lightgreyed">
      <td colspan="2">1.8</td>
      <td>08.2003</td>
      <td>06.2013</td>
      <td>Гэта была ня першая вэрсія, але тая, якая прыйшлася на пачатак росту папулярнасьці <i>Ruby</i>. На дадзены момант яна аб'яўлена не пажаданай да выкарыстаньня і больш не падтрымліваецца.</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.1</td>
      <td>12.2003</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.2</td>
      <td>12.2004</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.3</td>
      <td>09.2005</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.4</td>
      <td>12.2005</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.5</td>
      <td>08.2006</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.6</td>
      <td>03.2007</td>
      <td></td>
      <td>Пераважна фікс багаў</td>
    </tr>
    <tr class="lightgreyed">
      <td></td>
      <td>1.8.7</td>
      <td>05.2008</td>
      <td></td>
      <td>Фікс багаў, перанос некаторых паляпшэньняў, якія плянаваліся для 1.9, паляпшэньне прадукцыйнасьці.</td>
    </tr>
    <tr>
      <td colspan="2">1.9</td>
      <td>12.2007</td>
      <td></td>
      <td>Прынцыпова новая, палепшаная вэрсія, якая не мела зваротнай сумяшчальнасьці з вэрсіяй 1.8. Зьмены ў сэмантыцы, у ядры мовы, у базавых клясах. Вэрсія 1.9.0 не зьяўлялася стабільным рэлізам, але толькі рэліз-кандыдатам.</td>
    </tr>
    <tr>
      <td></td>
      <td>1.9.1</td>
      <td>01.2009</td>
      <td></td>
      <td>Пераважна фікс багаў у параўнаньні з 1.9.0. Першы стабільны рэліз вэрсіі 1.9.</td>
    </tr>
    <tr>
      <td></td>
      <td>1.9.2</td>
      <td>08.2010</td>
      <td></td>
      <td>Шмат новых мэтадаў, новы <i>Socket API</i>, новыя кадоўкі, новая кляса <i>Random</i>, кляса <i>Time</i> перапрацавана, і іншае</td>
    </tr>
    <tr>
      <td></td>
      <td>1.9.3</td>
      <td>10.2011</td>
      <td></td>
      <td>Шмат новых і палепшаных мэтадаў</td>
    </tr>
    <tr>
      <td>2.0</td>
      <td>2.0.0</td>
      <td>02.2013</td>
      <td></td>
      <td>Шмат новых асаблівасьцяў і паляпшэньняў.</td>
    </tr>
    <tr>
      <td>2.1</td>
      <td>2.1.0</td>
      <td>12.2013</td>
      <td></td>
      <td>Пераважна паляпшэньне прадукцыйнасьці</td>
    </tr>
    <tr>
      <td></td>
      <td>2.1.1</td>
      <td>02.2014</td>
      <td></td>
      <td>Пераважна фікс багаў і паляпшэньне прадукцыйнасьці</td>
    </tr>
    </tbody>
  </table>

  <h2 id="Versions_RVM">Кіраваньне вэрсіямі (RVM)</h2>
  <div class="refs">
    <ul>
      <li><a href="http://rvm.io/">rvm.io</a></li>
      <li><a href="http://sirupsen.com/get-started-right-with-rvm/">Get started</a></li>
      <li><a href="http://cheat.errtheblog.com/s/rvm">Cheat sheet</a></li>
    </ul>
  </div>
  <aside>Рэалізацыя <i>RVM</i> існуе толькі для <i>Linux</i>-сыстэм. Карыстальнікам <i>Windows</i> варта зьвярнуць увагу на прыладу <a href="https://github.com/vertiginous/pik/">pik</a>.</aside>
  <p>З улікам таго, што новыя вэрсіі зьяўляюцца прыкладна раз на год, складана сабе ўявіць, што пры распрацоўцы нейкага праекту можна абысьціся адной вэрсіяй <i>Ruby</i>. Гэта магчыма хіба толькі для вельмі маленькіх праектаў, якія магчыма ад пачатку да канчатковага рэлізу распрацаваць за тэрмін да году. У астатніх выпадках, верагодней за ўсё, трэба будзе пачынаць з адной вэрсіі, а потым адаптаваць праграму пад іншую(-ыя). Яшчэ ў больш складанай сытуацыі будзе знаходзіцца распрацоўшчык, якому адначасова трэба працаваць на розныя праекты, якія высоўваюць адрозныя патрабаваньні што да вэрсіі <i>Ruby</i>. Ствараць асобныя віртуальныя машыны пад кожны з праектаў з сваім спэцыфічным асяродзьдзем, мякка кажучы ня вельмі зручна. І тут прыходзіць на дапамогу незаменнае прыстасаваньне пад назвай <a href="http://rvm.io/"><i>Ruby Version Manager</i></a> (альбо скарочана <i>RVM</i>).</p>

  <h3 id="Versions_RVM_Installing">Усталяваньне <i>RVM</i></h3>
  <p>Каб усталяваць <i>RVM</i> трэба запусьціць каманду:</p>
  <script type="syntaxhighlighter" class="brush: text"><![CDATA[
          $ \curl -sSL https://get.rvm.io | bash -s stable
        ]]></script>
  <p>Больш падрабязна пра розныя опцыі ўсталяваньня можна паглядзець <a href="http://rvm.io/rvm/install">тут</a>.</p>
  <table>
    <caption>Дзе <i>RVM</i> захоўвае якія даныя</caption>
    <thead>
    <tr>
      <th>Тэчка</th>
      <th>Прызначэньне</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>~/.rvm</code></td>
      <td>Хатняя тэчка <i>RVM</i></td>
    </tr>
    <tr>
      <td><code>~/.rvm/rubies</code></td>
      <td>Тэчка з усталяванымі вэрсіямі <i>Ruby</i></td>
    </tr>
    <tr>
      <td><code>~/.rvm/gems</code></td>
      <td>Тэчка з усталяванымі наборамі гемаў для кожнай з вэрсіі <i>Ruby</i></td>
    </tr>
    <tr>
      <td><code>~/.rvm/gemsets</code></td>
      <td>Тэчка наладак кожнага з набору гемаў</td>
    </tr>
    </tbody>
  </table>

  <h3 id="Versions_RVM_Upgrading">Абнаўленьне <i>RVM</i></h3>
  <div class="refs">
    <ul>
      <li><a href="http://rvm.io/rvm/upgrading">rvm.io</a></li>
    </ul>
  </div>
  <p>Калі пройдзе пэўны час, як вы ўжо працуеце з <i>RVM</i>, можа выйсьці новая альбо нават некалькі новых вэрсіяў прылады. Абнавіцца да новай вэрсіі можна пры дапамозе каманд:</p>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
          $ rvm get stable    # абнаўленьне да апошняй стабільнай вэрсіі
          $ rvm get head      # абнаўленьне да апошняй працоўнай вэрсіі
        ]]></script>

  <h3 id="Versions_RVM_ListingAvailableVersions">Сьпіс даступных вэрсіяў</h3>
  <p>Каб даведацца якія вэрсіі <i>Ruby</i> можа ўсталяваць <i>RVM</i>, трэба скарыстацца камандай:</p>
  <script type="syntaxhighlighter" class="brush: text"><![CDATA[
          $ rvm list known
        ]]></script>

  <h3 id="Versions_RVM_InstallingNewRubies">Усталяваньне новых вэрсіяў</h3>
  <div class="refs">
    <ul>
      <li><a href="http://rvm.io/rubies/installing">rvm.io</a></li>
    </ul>
  </div>
  <p>Каб усталяваць у сыстэму новую вэрсію <i>Ruby</i>, трэба скарыстацца камандай:</p>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
          $ rvm install 2.1.1   # Дзе 2.1.1 – адна з вэрсіяў Ruby, якая была выведзена
                                # на запыт да сьпісу даступных вэрсіяў
                                # (гл. папярэдні разьдзел)
        ]]></script>

  <h3 id="Versions_RVM_RemovingInstalledRubies">Выдаленьне ўсталяваных вэрсіяў</h3>
  <div class="refs">
    <ul>
      <li><a href="http://rvm.io/rubies/removing">rvm.io</a></li>
    </ul>
  </div>
  <p>Каб выдаліць раней усталяваную вэрсію <i>Ruby</i>, трэба скарыстацца камандай:</p>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
          $ rvm remove 2.1.1    # Дзе 2.1.1 – раней усталяваная вэрсія Ruby
        ]]></script>

  <h3 id="Versions_RVM_ListingInstalledVersions">Сьпіс усталяваных вэрсіяў</h3>
  <p>Каб даведацца якія вэрсіі <i>Ruby</i> ужо ўсталяваныя <i>RVM</i>, трэба скарыстацца камандамі:</p>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
          $ rvm list            # Сьпіс усіх вэрсіяў рубі
          $ rvm list gemsets    # Сьпіс усіх вэрсіяў рубі разам з наборамі гемаў
          $ rvm gemset list     # Сьпіс гемаў для рубі, які абраны ў дадзены момант
        ]]></script>

  <h3 id="Versions_RVM_SelectingRubyForWork">Выбар вэрсіі для працы</h3>
  <p>Цяпер, калі мы ўсталявалі некалькі вэрсіяў <i>Ruby</i>, нам трэба выбраць патрэбную ў дадзены момант для працы:</p>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
          $ rvm use system            # Кажам RVM, каб ён не кіраваў вэрсіямі,
                                      # будзе ўжывацца сыстэмны Ruby.
          $ rvm use --default 2.1.1   # У цяперашнім тэрмінальным акне і ўва ўсіх наступных
                                      # будзе ўжывацца вэрсія Ruby 2.1.1.
          $ rvm use 2.1.0             # Толькі ў цяперашнім тэрмінальным акне
                                      # будзе ўжывацца вэрсія Ruby 2.1.0.
          $ rvm 2.1.0                 # Тое ж самае, што і папярэдняя каманда.
                                      # "use" зьяўляецца змоўчнай дзеяй для RVM
          $ rvm default               # Кажа RVM пераключыцца да змоўчнай вэрсіі Ruby
                                      # у цяперашнім тэрмінальным акне
        ]]></script>

  <h3 id="Versions_RVM_Gemsets">Множныя працоўныя асяродкі</h3>
  <p>Акрамя множных вэрсіяў самога <i>Ruby</i>, <i>RVM</i> таксама дазваляе ўсталёўваць множныя працоўныя асяродкі для адной і той жа вэрсіі. Па-ангельску ў тэрміланёгіі <i>RVM</i> яны завуцца ляканічна <i>gemsets</i>. Калі <i>RVM</i> усталёўвае новую вэрсію <i>Ruby</i>, ён стварае два змоўчных асяродка&nbsp;&ndash; <i>global</i> і <i>default</i>.</p>
  <ul>
    <li><i>global</i>&nbsp;&ndash; гэта супэр-асяродак, які спадкуюць усе астатнія асяродкі дадзенай вэрсіі <i>Ruby</i>.</li>
    <li><i>default</i>&nbsp;&ndash; гэта змоўчны асяродак, які выкарыстоўваецца ў выпадку, калі карыстальнік не абраў асяродку яўным чынам.</li>
  </ul>
  <p>Зьмест гэтых асяродкаў, то бок набор якіх гемаў павіенен для іх ужывацца, утрымліваецца ў тэкставых файлах, якія карыстальнік можа ўручную рэдагаваць:</p>
  <ul>
    <li><code>~/.rvm/gemsets/ruby/1.9.3/global.gems</code></li>
    <li><code>~/.rvm/gemsets/ruby/1.9.3/default.gems</code></li>
  </ul>
  <p>Напрыклад, калі дадаць наступны зьмест у файл <code>~/.rvm/gemsets/ruby/1.9.3/global.gems</code>:</p>
  <script type="syntaxhighlighter" class="brush: text"><![CDATA[
          bundler
          awesome_print
        ]]></script>
  <p>Тады, кожны раз, калі ствараецца новы асяродак для <i>Ruby</i> вэрсіі 1.9.3, гэтыя 2 гемы будуць аўтаматычна ўсталяваны ў гэты новы асяродак.</p>
  <p>Прывядзем шэраг камандаў для працы з асяродкамі (<i>gemsets</i>):</p>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
          $ rvm use 2.1.0                       # Спачатку выбіраем Ruby
          $ rvm gemset create project_name      # Ствараем асяродак для пэўнага праекту
          $ rvm gemset use project_name         # Ужываць у далейшым створаны асяродак для Ruby 2.1.0
          $ rvm gemset delete project_name      # Выдаліць раней створаны асяродак
          $ rvm 2.1.1@other_project_name        # Ужываць іншую вэрсію Ruby і іншы асяродак
          $ rvm 1.9.3@_project --create --rvmrc # Скарочаная форма адначасовага стварэньня і ўжыцьця
                                                # асяродку. Пры гэтым таксама будзе створаны файл
                                                # .rvmrc у тэчцы праекту

          $ rvm use 1.9.3@_project --default    # Пазначае які асяродак ужываць па змоўчаньні для
                                                # дадзенай вэрсіі Ruby
        ]]></script>
</section>

<section>
  <h1 id="Intro">Што такое Ruby?</h1>

  <h2 id="Intro_OOP">Аб'ектна-арыентаваная мова</h2>
  <p><i>Ruby</i> зьяўляецца цалкам аб'ектна-арыентаванай мовай праграмаваньня ў клясычным выглядзе. Усё, чым апэрыруе праграма на <i>Ruby</i>, зьяўляецца аб'ектам, і вынікі гэтых апэрацый таксама зьяўляюцца аб'ектамі. Аб'ектна-арыентаванае праграмаваньне характаразуецца тым, што распрацоўшчык спрабуе смадэляваць аб'ект рэальнага сьвету (возьмем у прыклад песьню) ў кодзе. У <i>Ruby</i> гэтыя аб'екты прадстаўляюцца клясамі. Клясы ўяўляюць зь сябе камбінацыю з стану (напр., назва песьні) і мэтадаў, якія апэрыруюць гэтым станам (напр., мэтад, каторы прайграе песьню).</p>
  <p>Калі аб'ект смадэляваны і адпаведная кляса напісаная, можна ствараць экзэмпляры гэтай клясы. Гэта адбываецца праз выклік канструктара&nbsp;&ndash; адмысловага мэтаду клясы, які звычайна называецца <code>new</code>.</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          song1 = Song.new("Ruby Tuesday")
          song2 = Song.new("Enveloped in Python")
        ]]></script>
  <p>Абедзьве зьменныя <code>song1</code> і <code>song2</code> зьяўляюцца экзэплярамі адной і той жа клясы <code>Song</code>, але маюць унікальныя характарыстыкі. Па-першае, кожны аб'ект (экзэмпляр нейкай клясы) у <i>Ruby</i> мае ўнікальны ідэнтыфікатар (<i>object id</i>). Па-другое, кляса можа ўтрымліваць зьменныя экзэмпляру, якія будуць утрымліваць унікальныя для кожнага экзэмпляру значэньні. Гэтыя зьменныя і выражаюць пазначаны вышэй <i>стан</i> аб'екта. Напрыклад, кляса <code>Song</code> можа ўтрымліваць зьменную, якая захоўвае назву песьні.</p>
  <p>Акрамя гэтага кожная кляса можа вызначаць мэтады экзэмпляраў&nbsp;&ndash; пэўны функцыянал, каторы можа выклікацца як знутры клясы, так і, пры пэўных акалічнасьцях,&nbsp;&ndash; звонку. Гэтыя мэтады маюць доступ да зьменных экзэмпляраў і могуць маніпуляваць імі. Мэтады могуць таксама называцца паведамленьнямі ці запытамі да аб'екта.</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "gin joint".length      #=> 9
        "Rick".index("c")       #=> 2
        -1942.abs               #=> 1942
        sam.play(aSong)         #=> "duh dum, da dum de dum ..."
        ]]></script>
  <p>Тое, што стаіць да кропкі, называецца <i>атрымальнікам</i> паведамленьня/запыту. Пасьля кропкі ідзе мэтад, які павінен быць выкліканы. Першы з прыкладаў вышэй пытаецца пра даўжыню (мэтад <code>length</code>) радка («<i>gin joint</i>»). У другім прыкладзе ў іншага радка пытаецца пра індэкс літары «<i>c</i>» у ім. У трэцім прыкладзе мы пытаемся ў лічбы пра яе абсалютнае значэньне, а ў чацьвёртым просім <code>sam</code>&#8217;а, каб ён прапеў (мэтад <code>play</code>) нам песьню (перададзены ў якасьці парамэтру аб'ект <code>aSong</code>).</p>

  <h2 id="Intro_IntuitiveNotation">Інтуітыўная натацыя</h2>
  <p>Ruby створаны такім чынам, каб код, напісаны на ім, быў інтуітыўна зразумелы. Напрыклад, наступны выраз:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        5.times { print "Odelay!" }
        ]]></script>
  <p>азначае «пяць (<code>5</code>) разоў (анг. <code>times</code>) надрукуй (анг. <code>print</code>) <code>"Odelay!"</code>». А выраз:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        exit unless "restaurant".include? "aura"
        ]]></script>
  <p>азначае, што «праграмма павінна скончыць сваё дзеяньне (анг. <code>exit</code>), калі радок <code>"restaurant"</code> не (анг. <code>unless</code>) утрымлівае (анг. <code>include</code>) радок <code>"aura"</code>». А выраз:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        ['toast', 'cheese', 'wine'].each { |food| print food.capitalize }
        ]]></script>
  <p>азначае «з кожным (анг. <code>each</code>) словам <code>'toast'</code>, <code>'cheese'</code>, <code>'wine'</code> зрабіць наступнае: пачатковую літару зрабіць вялікай (анг. <code>capitalize</code>) і надрукаваць вынік (анг. <code>print</code>)».</p>
</section>

<section>
  <h1 id="StructureExecution" data-content-item-open>Структура і выкананьне</h1>

  <h2 id="StructureExecution_Lexic">Лексычная структура</h2>
  <p>Інтэрпрэтатар <i>Ruby</i> разьбірае ўвесь тэкст <i>Ruby</i>-праграмы на <i>лексэмы</i> (ці <i>tokens</i>). Лексэмы ўключаюць камэнтары, літаралы, пунктуацыю, ідэнтыфікатары і ключавыя словы. Разгледзім больш падрабязна кожную з гэтых групаў, а таксама зь якіх сымбаляў яны складаюцца.</p>

  <h3 id="StructureExecution_Lexic_Comments">Камэнтары</h3>
  <p>Камэнтары ў <i>Ruby</i> пачынаюцца са знака <code>#</code> і працягваюцца да канца радку. Сам знак <code>#</code> і ўсё, што ідзе за ім, ігнаруецца інтэрпрэтатарам. Калі знак <code>#</code> сустракаецца ў сымбальнай чарадзе альбо ў рэгулярным выразе, тады ён зьяўляецца часткай чарады ці рэгулярнага выразу і не пачынае камэнтар.</p>
  <p>Камэнтары на шмат радкоў робяцца праз зьмяшчэньне знаку <code>#</code> у пачатку кожнага радку:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        #
        # This class represents a Complex number
        # Despite its name, it is not complex at all.
        #
        ]]></script>
  <p>У <i>Ruby</i> няма эквіваленту ўнутрырадковага <i>C</i>-падобнага камэнтару: <code>/*...*/</code>.</p>

  <h4 id="StructureExecution_Lexic_Comments_EmbeddedDocuments">Убудаваныя дакумэнты</h4>
  <p><i>Ruby</i> падтрымлівае яшчэ адзін спосаб рабіць шматрадковыя камэнтары, які завецца <i>убудаваныя дакумэнты</i> (<i>embedded documents</i>). Такі камэнтар пачынаецца радком, які ў самым сваім пачатку зьмяшчае <code>=begin</code>, а сканчаецца радком, які ў самым сваім пачатку зьмяшчае <code>=end</code>:</p>
  <p>Камэнтары для дакумэнтацыі павінны зьмяшчацца непасрэдна перад модулем, клясай альбо мэтадам, які яны апісваюць, і маюць адмысловыя правілы фарматаваньня, некаторыя зь якіх глядзі ў прыкладзе:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        =begin Someone needs to fix the broken code below!
        Any code here is commented out
        =end
        ]]></script>
  <p>Прычым знак роўнасьці абавязкова павінен быць першым знакам адпаведных радкоў. Як вынікае з назвы гэтыя камэнтары прызначаны ў тым ліку для ўстаўкі вялікіх фрагмэнтаў дакумэнтацыі альбо для ўбудаваньня фрагмэнтаў зь іншых моваў праграмаваньня (як <code><i><a href="../htmlRef/index.html">HTML</a></i></code> альбо <i>SQL</i>). Гэтыя ўбудаваныя дакумэнты звычайна прызначаныя для апрацоўкі староньнімі прыладамі ці дадаткамі, якія апрацоўваюць зыходны код <i>Ruby</i>, а пасьля лексэмы <code>=begin</code> звычайна пазначаецца ідэнтыфікатар, які кажа для якой прылады ці дадатку прызначаецца дакумэнт.</p>

  <h4 id="StructureExecution_Lexic_Comments_ForDocumentation">Камэнтары для дакумэнтацыі</h4>
  <p>У <i>Ruby</i> маецца магчымасьць вымаць камэнтары з тэксту праграмы, каб ствараць дакумэнтацыю па праграме. <mark>Спасылка на <i>rdoc</i></mark></p>
  <p>Камэнтары для дакумэнтацыі павінны зьмяшчацца непасрэдна перад модулем, клясай альбо мэтадам, які яны апісваюць, і маюць адмысловыя правілы фарматаваньня, некаторыя зь якіх глядзі ў прыкладзе:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          #
          # Rdoc comments use a simple markup grammar like those used in wikis.
          #
          # Separate paragraphs with a blank line.
          #
          # = Headings
          #
          # Headings begin with an equals sign
          #
          # == Sub-Headings
          # The line above produces a subheading.
          # === Sub-Sub-Heading
          # And so on.
          #
          # = Examples
          #
          # Indented lines are displayed verbatim in code font.
          # Be careful not to indent your headings and lists, though.
          #
          # = Lists and Fonts
          #
          # List items begin with * or -. Indicate fonts with punctuation or HTML:
          # * _italic_ or <i>multi-word italic</i>
          # * *bold* or <b>multi-word bold</b>
          # * +code+ or <tt>multi-word code</tt>
          #
          # 1. Numbered lists begin with numbers.
          # 99. Any number will do; they do not have to be sequential.
          # 1. There is no way to do nested lists.
          #
          # The terms of a description list are bracketed:
          # [item 1] This is a description of item 1
          # [item 2] This is a description of item 2
          #
        ]]></script>

  <h3 id="StructureExecution_Lexic_Literals">Літаралы</h3>
  <p>Літаралы&nbsp;&ndash; гэта значэньні, якія сустракаюцца непасрэдна ў тэксьце праграмы. Гэта ўключае лікі, сымбальныя чароды і рэгулярныя выразы. (Іншыя літаралы, як масівы альбо хэшы, не зьяўляюцца асобнымі лексэмамі, але зьяўляюцца больш складанымі выразамі.) Сынтакс лічбавых і сымбальных літаралаў у <i>Ruby</i> насамрэч даволі складаны (<mark>глядзі разьдзел ....</mark>), але на дадзеным этапе дастаткова атрымаць спрошчанае іх разуменьне:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1       # Цэлалікавы літарал
        1.0     # Рэчаісны літарал
        'one'   # Сымбальны літарал
        "two"   # Яшчэ адзін сымбальны літарал
        /three/ # Літарал рэгулярнага выразу
        ]]></script>

  <h3 id="StructureExecution_Lexic_Punctuation">Пунктуацыя</h3>
  <p>У гэтую групу ўваходзяць ня толькі самі знакі пунктуацыі, як коска, кропка, двукроп'е і іншыя, якія служаць для групаваньня альбо аддзяленьня выразаў, аргумэнтаў мэтадаў, індэксаў масіваў, а таксама для абмежаваньня сымбальных чародаў, рэгулярных выразаў і іншага. Уваходзяць сюды і розныя знакі <mark>апэрацыяў</mark>.</p>

  <h3 id="StructureExecution_Lexic_Identifiers">Ідэнтыфікатары</h3>
  <p>Ідэнтыфікатар&nbsp;&ndash; гэта інакш імя. <i>Ruby</i> выкарыстоўвае ідэнтыфікатары, каб даваць імёны зьменным, мэтадам, клясам і іншаму. Яны могуць складацца з літараў, лічбаў і знаку падкрэсьліваньня, пры гэтым у якасьці яго першага сымбалю ня можа быць лічба. Калі ідэнтыфікатар пачынаецца з вялікай літары, інтэрпрэтатар <i>Ruby</i> аўтаматычна ўспрыме яго за імя канстанты. Ніжэй прыводзяцца прыклады розных ідэнтыфікатараў:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        i
        x2
        old_value
        _internal   # Могуць пачынацца са знаку падкрэсьліваньня
        PI          # Канстанта
        ]]></script>
  <p>Па дамоўленасьці, калі ідэнтыфікатар (не канстанта) складаецца зь некалькіх словаў, тады паміж словамі зьмяшчаецца знак падкрэсьліваньня: <code>like_this</code>, а канстанты запісваюцца так: <code>LikeThis</code>, альбо так: <code>LIKE_THIS</code>.</p>
  <p>Як можна было зразумець з вышэйсказанага, у <i>Ruby</i> малыя і вялікія літары маюць адрозьненьне. Напрыклад, ключавое слова <code>end</code> гэта ня тое ж самае, што ключавое слова <code>END</code>.</p>

  <h4 id="StructureExecution_Lexic_Identifiers_Punctuation">Пунктуацыя ў ідэнтыфікатарах</h4>
  <p>У пачатку ці ў канцы ідэнтыфікатараў могуць стаяць знакі пунктуацыі (альбо адмысловыя сымбалі), якія маюць наступнае значэньне:</p>
  <table>
    <tr>
      <td style="width: 30px;"><code>$</code></td>
      <td>Глябальныя зьменныя маюць прэфікс у выглядзе знаку даляру. <i>Ruby</i> вызначае шэраг глябальных зьменных, у якіх дадаткова прысутнічаюць яшчэ іншыя знакі, як <code>$_</code> альбо <code>$-</code>. Па поўны сьпіс прадвызначаных адмысловых глябальных зьменных глядзі <mark>разьдзел 10.2.3</mark>.</td>
    </tr>
    <tr>
      <td style="width: 30px;"><code>@</code></td>
      <td>Зьменныя экзэмпляру клясы маюць прэфікс у выглядзе адзіночнага <i>at</i>-знаку, а зьменныя клясы&nbsp;&ndash; у выглядзе падвойнага <i>at</i>-знаку. Па больш дэталёвую інфармацыю глядзі <mark>разьдзел 7.3.5, 7.3.6</mark>.</td>
    </tr>
    <tr>
      <td style="width: 30px;"><code>?</code></td>
      <td>Па дамоўленасьці імёны мэтадаў, якія вяртаюць значэньні <mark><i>Boolean</i></mark>, сканчаюцца пытальнікам.</td>
    </tr>
    <tr>
      <td style="width: 30px;"><code>!</code></td>
      <td>Па дамоўленасьці імёны мэтадаў, якія павінны ўжывацца з асьцярогаю, сканчаюцца клічнікам. Такім чынам адзначаюцца мэтады, якія зьмяняюць стан аб'екту, у якога яны былі выкліканыя. У адрозьненьне ад тых мэтадаў, якія вяртаюць зьмененую копію зыходнага аб'екту.</td>
    </tr>
    <tr>
      <td style="width: 30px;"><code>=</code></td>
      <td>Па дамоўленасьці імёны мэтадаў, якія прызначаны для прысваеньня значэньняў, сканчаюцца знакам роўнасьці.</td>
    </tr>
  </table>
  <p>Вось прыклады ідэнтыфікатараў, якія ўтрымліваюць гэтыя адмысловыя знакі:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        $files      # Глябальная зьменная
        @data       # Зьменная экзэмпляру
        @@counter   # Зьменная клясы
        empty?      # Мэтад, які вяртае булеўскае значэньне
        sort!       # Мэтад сартуе зьмест зыходнага аб&#8217;екту,
                    # а не вяртае адсартаваную копію яго
        timeout=    # Мэтад для прысваеньня значэньня
        ]]></script>
  <p>Заўважце таксама, што некаторыя <mark>апэрацыі</mark> <i>Ruby</i> рэалізаваныя як мэтады, каб клясы маглі перавызначаць іх пад свае ўласныя патрэбы.</p>

  <h3 id="StructureExecution_Lexic_Keywords">Ключавыя словы</h3>
  <p>Наступныя ключавыя словы маюць адмысловае значэньне ў <i>Ruby</i> і будуць асаблівым чынам апрацаваныя яго парсэрам:</p>
  <table class="list" id="keywords">
    <tbody>
    <tr>
      <td><code>__LINE__</code></td>
      <td><code>begin</code></td>
      <td><code>else</code></td>
      <td><code>in</code></td>
      <td><code>rescue</code></td>
      <td><code>undef</code></td>
    </tr>
    <tr>
      <td><code>__ENCODING__</code></td>
      <td><code>break</code></td>
      <td><code>elsif</code></td>
      <td><code>module</code></td>
      <td><code>retry</code></td>
      <td><code>unless</code></td>
    </tr>
    <tr>
      <td><code>__FILE__</code></td>
      <td><code>case</code></td>
      <td><code>end</code></td>
      <td><code>next</code></td>
      <td><code>return</code></td>
      <td><code>until</code></td>
    </tr>
    <tr>
      <td><code>BEGIN</code></td>
      <td><code>class</code></td>
      <td><code>ensure</code></td>
      <td><code>nil</code></td>
      <td><code>self</code></td>
      <td><code>when</code></td>
    </tr>
    <tr>
      <td><code>END</code></td>
      <td><code>def</code></td>
      <td><code>false</code></td>
      <td><code>not</code></td>
      <td><code>super</code></td>
      <td><code>while</code></td>
    </tr>
    <tr>
      <td><code>alias</code></td>
      <td><code>defined?</code></td>
      <td><code>for</code></td>
      <td><code>or</code></td>
      <td><code>then</code></td>
      <td><code>yield</code></td>
    </tr>
    <tr>
      <td><code>and</code></td>
      <td><code>do</code></td>
      <td><code>if</code></td>
      <td><code>redo</code></td>
      <td><code>true</code></td>
      <td></td>
    </tr>
    </tbody>
  </table>
  <p>У дапаўненьне маюцца яшчэ 3 лексэмы, падобныя да ключавых словаў:</p>
  <table class="list" id="keywords">
    <tbody>
    <tr>
      <td><code>=begin</code></td>
      <td><code>=end</code></td>
      <td><code>__END__</code></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    </tbody>
  </table>
  <p>2 зь якіх <code>=begin</code> і <code>=end</code> ужо згадваліся вышэй&nbsp;&ndash; яны адкрываюць і закрываюць так званыя <a href="#StructureExecution_Lexic_Comments_EmbeddedDocuments">убудаваныя дакумэнты</a> (альбо шматрадковыя камэнтары). А лексэма <code>__END__</code> пазначае канец праграмы (і пачатак сэкцыі з данымі), калі яна зьмяшчаецца ў самым пачатку радку, прычым пасьля яе на гэтым радку таксама нічога не павінна зьмяшчацца, нават прагалы.</p>
  <p>Акрамя вышэйазначанага шмат важных асаблівасьцяў і магчымасьцяў <i>Ruby</i> рэалізаваныя як мэтады клясаў <mark><code>Kernel</code>, <code>Module</code>, <code>Class</code> і <code>Object</code></mark>. Такім чынам, добрай практыкай будзе падыход, пры якім яны лічацца таксама зарэзэрваванымі словамі з асаблівым сэнсам і не выкарыстоўваюцца для ўласнага найменьня:</p>
  <table class="list" id="keywords">
    <caption>Гэта мэтады, якія выглядаюць як выразы ці ключавыя словы</caption>
    <tbody>
    <tr>
      <td><code>at_exit</code></td>
      <td><code>attr_reader</code></td>
      <td><code>include</code></td>
      <td><code>loop</code></td>
      <td><code>protected</code></td>
      <td><code>require</code></td>
    </tr>
    <tr>
      <td><code>attr</code></td>
      <td><code>attr_writer</code></td>
      <td><code>lambda</code></td>
      <td><code>private</code></td>
      <td><code>public</code></td>
      <td><code>throw</code></td>
    </tr>
    <tr>
      <td><code>attr_accessor</code></td>
      <td><code>catch</code></td>
      <td><code>load</code></td>
      <td><code>proc</code></td>
      <td><code>raise</code></td>
      <td></td>
    </tr>
    </tbody>
  </table>
  <table class="list" id="keywords">
    <caption>Гэта найбольш ужываныя глябальныя мэтады</caption>
    <tbody>
    <tr>
      <td><code>Array</code></td>
      <td><code>block_given?</code></td>
      <td><code>exit</code></td>
      <td><code>iterator?</code></td>
      <td><code>readline</code></td>
      <td><code>sub!</code></td>
    </tr>
    <tr>
      <td><code>Float</code></td>
      <td><code>callcc</code></td>
      <td><code>exit!</code></td>
      <td><code>load</code></td>
      <td><code>readlines</code></td>
      <td><code>syscall</code></td>
    </tr>
    <tr>
      <td><code>Integer</code></td>
      <td><code>caller</code></td>
      <td><code>fail</code></td>
      <td><code>open</code></td>
      <td><code>scan</code></td>
      <td><code>system</code></td>
    </tr>
    <tr>
      <td><code>String</code></td>
      <td><code>chomp</code></td>
      <td><code>fork</code></td>
      <td><code>p</code></td>
      <td><code>select</code></td>
      <td><code>test</code></td>
    </tr>
    <tr>
      <td><code>URI</code></td>
      <td><code>chomp!</code></td>
      <td><code>format</code></td>
      <td><code>print</code></td>
      <td><code>sleep</code></td>
      <td><code>trap</code></td>
    </tr>
    <tr>
      <td><code>abort</code></td>
      <td><code>chop</code></td>
      <td><code>getc</code></td>
      <td><code>printf</code></td>
      <td><code>split</code></td>
      <td><code>warn</code></td>
    </tr>
    <tr>
      <td><code>autoload</code></td>
      <td><code>chop!</code></td>
      <td><code>gets</code></td>
      <td><code>putc</code></td>
      <td><code>sprintf</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>autoload?</code></td>
      <td><code>eval</code></td>
      <td><code>gsub</code></td>
      <td><code>puts</code></td>
      <td><code>srand</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>binding</code></td>
      <td><code>exec</code></td>
      <td><code>gsub!</code></td>
      <td><code>rand</code></td>
      <td><code>sub</code></td>
      <td></td>
    </tr>
    </tbody>
  </table>
  <table class="list" id="keywords">
    <caption>А гэта найбольш ужываныя мэтады аб'ектаў</caption>
    <tbody>
    <tr>
      <td><code>allocate</code></td>
      <td><code>equal?</code></td>
      <td><code>inherited</code></td>
      <td><code>methods</code></td>
      <td><code>superclass</code></td>
      <td><code>untaint</code></td>
    </tr>
    <tr>
      <td><code>clone</code></td>
      <td><code>extend</code></td>
      <td><code>inspect</code></td>
      <td><code>new</code></td>
      <td><code>taint</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>display</code></td>
      <td><code>freeze</code></td>
      <td><code>instance_of?</code></td>
      <td><code>nil?</code></td>
      <td><code>tainted?</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>dup</code></td>
      <td><code>frozen?</code></td>
      <td><code>is_a?</code></td>
      <td><code>object_id</code></td>
      <td><code>to_a</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>enum_for</code></td>
      <td><code>hash</code></td>
      <td><code>kind_of?</code></td>
      <td><code>respond_to?</code></td>
      <td><code>to_enum</code></td>
      <td></td>
    </tr>
    <tr>
      <td><code>eql?</code></td>
      <td><code>id</code></td>
      <td><code>method</code></td>
      <td><code>send</code></td>
      <td><code>to_s</code></td>
      <td></td>
    </tr>
    </tbody>
  </table>

  <h3 id="StructureExecution_Lexic_Whitespaces">Прагалы</h3>
  <p>Прагалы, знакі табуляцыі, пераносы радку&nbsp;&ndash; усе яны не зьяўляюцца лексэмамі, але падзяляюць лексэмы адну ад другой, якія б інакш зьліліся ў адну лексэму. Акрамя гэтай функцыі ў агульным выпадку прагалы ігнаруюцца інтэрпрэтатарам, але некаторыя зь іх выконваюць яшчэ дадатковыя, пры гэтым важныя функцыі. <i>Ruby</i> мае выразную, але і складаную граматыку, і існуюць выпадкі, калі ўстаўка ці выдаленьне некаторых відаў прагалаў можа зьмяніць сэнс праграмы. Хаця гэтых выпадкаў і ня шмат, іх трэба ведаць.</p>

  <h4 id="StructureExecution_Lexic_Whitespaces_Newlines">Пераносы радку</h4>
  <p>Найбольш важная залежнасьць ад прагалаў&nbsp;&ndash; гэта пераносы радку ў якасьці маркераў канца выразаў. У мовах праграмаваньня як <i>C</i> ці <i>Java</i> кожны выраз павінен сканчацца кропкай з коскай. Гэтак жа можна рабіць і ў <i>Ruby</i>, але гэта абавязкова толькі ў выпадку, калі патрэбна зьмясьціць некалькі выразаў у адным радку. Інакш, па дамоўленасьці, кропка з коскай не павінна ўжывацца. Але без кропкі з коскай інтэрпрэтатар павінен сам нейкім чынам зразумець дзе знаходзіцца канец выразу. Таму, калі фрагмэнт коду на адным радку можа быць сынтаксічна завершаным выразам, <i>Ruby</i> трактуе знак пераносу радку як азнаку канца выразу. Інакш ён працягвае аналізаваць код на наступным радку.</p>
  <p>Калі кожны выраз зьмяшчаецца на асобным радку, тады ня ўзьнікне праблемаў, але калі ёсьць выразы, якія займаюць больш аднаго радку, трэба зрабіць перанос выразу такім чынам, каб <i>Ruby</i> ня здолеў інтэрпрэтаваць фрагмэнт на першым з гэтых радкоў як асобны выраз. Напрыклад, наступны код складзе <code>x</code> з <code>y</code> і назначыць суму зьменнай <code>total</code>:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          total = x +   # Няпоўны выраз, таму пераходзім на наступны радок, каб скончыць яго
            y
        ]]></script>
  <p>А вось наступны код назначыць значэньне зьменнай <code>x</code> зьменнай <code>total</code>, а потым вылічыць значэньне зьменнай <code>y</code> і нічога з гэтым ня зробіць:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          total = x     # Поўны выраз. Перанос радку трактуецца як маркер канца выразу.
            + y         # Хаця і безсэнсоўны, але поўны выраз.
        ]]></script>

  <h2 id="StructureExecution_Syntax">Сынтаксычная структура</h2>
  <p>Вышэй мы разглядалі лексэмы&nbsp;&ndash; элемэнтарныя цаглінкі <i>Ruby</i>-праграмы. Зараз коратка разгледзім як гэтыя цагліны складаюцца разам у большыя, сынтаксычныя структуры <i>Ruby</i>-праграмы&nbsp;&ndash; ад прасьцейшых выразаў да буйных модуляў.</p>
  <ol>
    <li>
      <p>Базавым элемэнтам сынтаксу ў <i>Ruby</i> зьяўляецца <strong><a href="#ExpressionsAndOperators">выраз</a></strong>. Інтэрпрэтатар <i>Ruby</i> апрацоўвае выразы і атрымлівае ў выніку значэньні. Самымі простымі зьяўляюцца прымітыўныя выразы, якія прадстаўляюць значэньні наўпрост&nbsp;&ndash; лікі, сымбальныя чароды, зьменныя (якія дасылаюць наўпрост да пэўнага значэньня) і некаторыя ключавыя словы, якія прадстаўляюць адмысловыя значэньні (<mark><code>true</code>, <code>false</code>,<code>nil</code>, <code>self</code></mark>). Акрамя гэтага існуюць і больш складаныя, састаўныя выразы:</p>
      <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
              [1, 2, 3, 4, 5]           # літарал масіву
              {1 => "one", 2 => "two"}  # літарал хэшу
              1..5                      # літарал дыяпазону
            ]]></script>
      <p><strong><a href="#ExpressionsAndOperators_Operators">Апэрацыі</a></strong> прызначаныя для выкананьня вылічэньняў са значэньнямі. Састаўныя выразы складаюцца ў тым ліку пры дапамозе камбінаваньня апэрацыяў зь іншымі выразамі:</p>
      <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
              1         # Прымітыўны выраз
              x         # Яшчэ адзін прымітыўны выраз
              x = 1     # Састаўны выраз прысваеньня
              x = x + 1 # Больш складаны састаўны выраз, які складаецца з выразу дадаваньня (х + 1)
                        # і выразу прысваеньня х = (х + 1)
            ]]></script>
    </li>
    <aside><sup>1</sup>Ува ўсёй сукупнасьці дадзеных даведнікаў у якасьці адпаведніку тэрміну <i>statement</i> ангельскай кампутарнай тэрміналёгіі ўжываюцца як <i>апэратар</i> (як больш пазнавальны тэрмін з расейскай мовы), гэтак і <i>інструкцыя</i> (як больш адпавядаючы сэнсу кіруючай канструкцыі).</aside>
    <li>
      <p>Выразы ў камбінацыі з <a href="#StructureExecution_Lexic_Keywords">ключавымі словамі</a> могуць утвараць інструкцыі для выкананьня, альбо <strong><a href="#ExpressionsAndOperators_Operators">апэратары</a></strong><sup>1</sup>. Гэтак, <code>if</code>-апэратар выкарыстоўваецца для ўмоўнага выкананьня пэўнага коду, а <code>while</code>-апэратар&nbsp;&ndash; для цыклічнага выкананьня коду:</p>
      <br />
      <br />
      <br />
      <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
              if x > 5 then   # Калі ўмоўны выраз вяртае значэньне true,
                x = x - 1     # тады выканаць гэтую інструкцыю.
              end             # Пазначае канец умоўнага выкананьня.

              while x < 5 do  # Пакуль умоўны выраз вяртае значэньне true...
                print x       # выканаць гэтую інструкцыю,
                x = x + 1     # потым гэтую інструкцыю.
              end             # Пазначае канец цыклічнага выкананьня.
            ]]></script>
      <p>У <i>Ruby</i> інструкцыі (апэратары) тэхнічна таксама зьяўляюцца выразамі і вяртаюць значэньні, хаця ня ўсе зь іх зьяўляюцца асэнсаванымі&nbsp;&ndash; напрыклад, <code>while</code>-апэратар заўсёды вяртае значэньне <code>nil</code>.</p>
    </li>
    <li>
      <p>Амаль заўсёды маецца неабходнасьць згрупаваць выразы і інструкцыі ў адасобленыя адзінкі з уваходнымі парамэтрамі, каб іх можна было выклікаць шматкроць і са зьменлівымі ўваходнымі данымі. У <i>Ruby</i>, як аб'екта-арыентаванай мове, гэтыя адзінкі завуцца <strong><a href="MethodsAndProcs_Methods">мэтадамі</a></strong>. Акрамя гэтага маюцца мэтад-падобныя адзінкі <a href="MethodsAndProcs_ProcsAndLambdas"><strong>працэдуры</strong> і <strong>лямбды</strong></a>.</p>
    </li>
    <li>
      <p>І напрыканцы ўзаемазьвязаныя мэтады могуць аб'ядноўвацца ў <a href="ClassesAndModules_Classes"><strong>клясы</strong></a>, а клясы і асобныя мэтады могуць аб'ядноўвацца ў <a href="ClassesAndModules_Modules"><strong>модулі</strong></a>.</p>
    </li>
  </ol>

  <h3 id="StructureExecution_Syntax_Blocks">Групаваньне зьместу праз блёкі</h3>
  <p>Праграмы на <i>Ruby</i> маюць блёчную структуру, у тым сэнсе, што модулі, клясы, мэтады і большасьць інструкцыяў маюць блёкі злучанага зь імі коду. Існуе 2 тыпы блёкаў. Па-першае, гэта блёкі, які перадаюцца ітэрацыйным мэтадам. Яны могуць заключацца альбо ў фігурныя дужкі (калі укладзеныя выразы зьмяшчаюцца на адзіна радок), альбо паміж ключавымі словамі <code>do</code>…<code>end</code> (шматрадковы блёк):</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          5.times { print "Ruby!" }

          1.upto(10) do |x|
            print x
          end
        ]]></script>
  <p>Іншым тыпам блёкаў зьяўляюцца целы модуляў, клясаў, мэтадаў і апэратараў. Яны ніколі не заключаюцца ў фігурныя дужкі, але пры дапамозе ключавых словаў. Таксама блёкі могуць быць укладзеныя адны ў іншыя:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          module Stat                           # Пачатак аб&#39;яўленьня модулю
            class Data                          # Пачатак аб&#39;яўленьня клясы ў модулі
              def init(file_name)               # Пачатак аб&#39;яўленьня мэтаду ў клясе
                IO.foreach(file_name) do |line| # Блёк ітэратару ў мэтадзе
                  if line[0,1] == "%"           # Умоўны апэратар у блёку
                    next                        # Просты выраз ува ўмоўным апэратары
                  end                           # Канец блёку ўмоўнага апэратару
                end                             # Канец блёку ітэратару
              end                               # Канец цела мэтаду
            end                                 # Канец цела клясы
          end                                   # Канец цела модулю
        ]]></script>

  <h2 id="StructureExecution_Files">Структура файлаў</h2>

  <h2 id="StructureExecution_Encoding">Кадоўка файлаў</h2>

  <h2 id="StructureExecution_Execution">Выкананьне праграмы</h2>
</section>

<section>
  <h1 id="ExpressionsAndOperators" data-content-item-open>Выразы і апэрацыі</h1>

  <p>Сынтакс <i>Ruby</i> цэнтруецца вакол выразаў. Напрыклад, элемэнты кіраваньня плыньню праграмы, кшталту <code>if</code> у любой іншай мове праграмаваньня называюцца апэратарамі (умоўным апэратарам у дадзеным выпадку), а ў <i>Ruby</i> гэта таксама выразы і яны вяртаюць значэньні:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          minimum = if x < y then x else y end
        ]]></script>
  <p>Хаця ня ўсе зь іх вяртаюць зьмястоўныя значэньні. Напрыклад, апэратар цыкла <code>while</code> ці вызначэньне <a href="#LangParts_Methods">мэтаду</a> вяртаюць <code>nil</code>.</p>

  <h2 id="ExpressionsAndOperators_Literals">Літаралы</h2>

  <h2 id="ExpressionsAndOperators_Variables">Зьменныя</h2>
  <p>Зьменныя&nbsp;&mdash; гэта імёны аб&#8217;ектаў ці значэньняў. Яны могуць састаяць з літараў, лічбаў і знака падкрэсьліваньня. Прыклад:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          single_fee = 2.50                       #=> даем імя значэньню кошта ўваходнага білета
          attendees = 4                           #=> даем імя колькасьці наведнікаў
          overall_fee = single_fee * attendees    #=> разьлічваем агульны кошт уваходу групы
                                                  #=> наведнікаў, пры гэтым зьвяртаемся да
                                                  #=> значэньняў кошту ўваходнага білета і колькасьці
                                                  #=> наведнікаў у групе праз іх імёны
        ]]></script>
  <p><strong>УВАГА!</strong> Зьменныя больш нізкага ўзроўню ня проста перакрываюць зьменныя з тым жа імем больш высокага ўзроўню (як, напрыклад, у <a href="../java/index.html"><i>Java</i></a>):</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          verb = 'rescued'
          ['sedated', 'sprinkled', 'electrocuted'].each do |verb|
            puts "Dr. Cham " + verb + " his niece Hannah."
          end
          puts "Yes, Dr. Cham " + verb + " his niece Hannah."
        ]]></script>
  <p>але перавызначаць/заціраюць яе:</p>
  <script type="syntaxhighlighter" class="brush: text"><![CDATA[
          Dr. Cham sedated his niece Hannah.
          Dr. Cham sprinkled his niece Hannah.
          Dr. Cham electrocuted his niece Hannah.
          Yes, Dr. Cham electrocuted his niece Hannah.
        ]]></script>
  <p>Як бачым, у апошнім радку ў якасьці значэньня зьменнай <code class="local_var">verb</code> больш высокага ўзроўню падставіцца <i>"electrocuted"</i>&nbsp;&mdash; апошняе значэньне ітэратару, а не першапачатковае <i>"rescued"</i>, як магло б падацца.</p>
  <p>Спроба зьвярнуцца да яшчэ не аб'яўленай зьменнай выкліча памылку, але тут ёсьць адзін &laquo;хітрык&raquo;&nbsp;&mdash; дастаткова каб інтэпрэтатар Ruby &laquo;убачыў&raquo; аб'яўленьне зьменнай і не абавязкова, каб гэта аб'яўленьне выканалась праграмай:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          a = 0.0 if false        # Гэтае прысваеньне ніколі не будзе выканана
          print a                 # Выдадзе на экран nil: зьменная існуе, але не ініцыялізавана
          print b                 # NameError: не існуе такой зьменнай ці мэтаду
        ]]></script>

  <h3 id="ExpressionsAndOperators_Variables_InstanceVar">Зьменныя экзэмпляраў</h3>
  <p>Зьменныя, каторыя пачынаюцца са знака &#64;, зьяўляюцца зьменнымі <strong>экзэмпляраў</strong> <a href="#LangParts_Classes">клясаў</a>:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        @x, @y
        ]]></script>
  <p>Яны пазначаюць характарыстыку гэтага асабістага экзэмпляру. Напрыклад, каб пазначыць шырыню ўваходных дзьвярэй трэба ўвесьці зьменную <code class="var">&#64;width</code> у экзэмпляр <code class="local_var">front_door</code> клясы <code class="class">Door</code>.</p>

  <h3 id="ExpressionsAndOperators_Variables_ClassVar">Зьменныя клясаў</h3>
  <p>Зьменныя яшчэ больш высокага ўзроўню (у параўнаньні зь лякальнымі і экзэплярнымі)&nbsp;&mdash; зьменныя <strong><a href="#LangParts_Classes">клясаў</a></strong>. Яны пачынаюцца з падвойнага знака &#64;:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        @@x, @@y
        ]]></script>
  <p>І пазначаюць характарыстыку ўсёй клясы (усіх экзэмпляраў гэтай клясы). Зьяўляюцца аналягамі статычных зьменных у <a href="../java/index.html"><span class="term">Java</span></a>.</p>

  <h3 id="ExpressionsAndOperators_Variables_GlobalVar">Глябальныя зьменныя</h3>
  <p>Ну і зьменнымі найбольш высокага ўзроўню зьяўляюцца глябальныя зьменныя. Яны пачынаюцца са знака &#36; і даступны зь любога месца праграмы:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        $x, $y
        ]]></script>

  <h2 id="ExpressionsAndOperators_Consts">Канстанты</h2>
  <p>Канстанты як зьменныя, але пачынаюцца зь вялікай літары і не павінны зьмяняць сваё значэньня цягам працы праграмы. Хаця апошняе строга не забаронена&nbsp;&mdash; пры зьмене значэньня канстанты інтэрпрэтатар Ruby выдасьць толькі папярэджаньне. Акрамя гэтага ёсьць яшчэ адна асаблівасьць&nbsp;&mdash; імя канстант вядзецца запісваць ня проста зь вялікай літары, а ўсімі вялікімі літарамі:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          EMPIRE_STATE_BUILDING = "350 5th Avenue, NYC, NY"
        ]]></script>
  <p>Канстанта можа быць вызначана як на глябальным узроўні (<i>global scope</i>), так і на ўзроўні клясаў ці модуляў:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          Conversions::CM_PER_INCH              # Зьвяртаньне да канстанты, вызначанай у модулі/клясе Conversions

          Conversions::Area::HECTARES_PER_ACRE  # Укладзеная герархія модуляў

          ::ARGV                                # Зьвяртаньне да глябальнай канстанты ARGV
        ]]></script>

  <h2 id="ExpressionsAndOperators_Operators" data-content-item-open>Апэрацыі</h2>
  <p>Апэрацыі выкарыстоўваюцца ў праграме для выкананьня матэматычных і лягічных апэрацый, для параўнаньня і інш. Шмат зь іх рэалізваныя праз <a href="#LangParts_Methods">мэтады</a>, і <a href="#LangParts_Classes">клясы</a> могуць вызначаць (ці перавызначаць) іх на свой капыл. Напрыклад, апэрацыі <code>+</code> і <code>*</code> дзейнічаюць па-рознаму для <a href="#Types_Numbers">лікаў</a> і <a href="#Types_Strings">сымбальных чародаў</a>. А ўва ўласных варыянтах гэтых клясаў можна ўвогуле вызначыць свае варыянты гэтых мэтадаў. Іншы прыклад, каторы ілюструе гэты падыход&nbsp;&mdash; апэрацыя <code>&lt;&lt;</code>. Лікавыя клясы <code class="class">Fixnum</code> і <code class="class">Bignum</code> рэалізуюць яе для бітавага зруху ўлева, у той час як іншыя клясы (<a href="#Types_Strings">сымбальныя чароды</a>, <a href="#Types_Arrays">масівы</a>) рэалізуюць яе як дадаваньне зьместу.</p>

  <h3 id="ExpressionsAndOperators_Operators_UnaryMinus">Унарныя <code>+</code> і <code>-</code></h3>
  <p>Унарная апэрацыя <code>-</code>, каторая зьмяшчаецца перад лікам, зьмяняе яго знак на адваротны. Унарны <code>+</code> перад лікам таксама дазваляецца, але ён не аказвае ніякага ўзьдзеяньня. Каб адрозьніваць гэтыя апэрацыя ад адпаведных арытмэтычных, мэтады, якія вызначаюць гэтыя апэрацыі, маюць назвы <code class="method">-@</code> і <code class="method">+@</code>.</p>

  <h3 id="ExpressionsAndOperators_Operators_Exponentiation">Cтупеняваньне: <code>**</code></h3>
  <p>Апэрацыя <code>**</code> падвышае першы аргумэнт у ступень другога. Другі аргумэнт можа быць дробавым (кубічны корань ад <code>x</code>: <code>x**(1.0/3.0)</code>), а таксама адмоўным (<code>x**-y</code> эквівалентна <code>1/(x**y)</code>).</p>

  <h3 id="ExpressionsAndOperators_Operators_Arithmetic">Арытмэтычныя: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> і <code>%</code></h3>
  <p>Апэрацыя <code>+</code>, <code>-</code>, <code>*</code> і <code>/</code> выконваюць адпаведна арытмэтычнае складаньне, адніманьне, памнажэньне і дзяленьне сваіх лікавых аргумэнтаў. Цэлалікавае дзяленьне дае заўсёды цэлалікавы вынік, а астача адкідваецца. Астачу цэлалікавага дзяленьня можна вызначыць пры дапамозе апэрацыі <code>%</code>.</p>
  <p>Сымбальныя чароды выкарыстоўваюць апэрацыю <code>+</code> для спалучэньня некалькіх чародаў, апэрацыю <code>*</code> для паўтарэньня чародаў і апэрацыю <code>%</code> у якасьці аргумэнту мэтаду <code class="method">sprintf</code>.</p>
  <p>У выпадку масіваў апэрацыя <code>+</code> спалучае масівы, апэрацыя <code>-</code> аднімае масівы. Паводзіны апэрацыі <code>*</code> залежаць ад другога аргумэнту. Калі другім аргумэнтам зьяўляецца лік, тады у выніку атрымліваецца іншы масіў, у каторым першапачатковы паўтараецца столькі разоў, як гэты лік. Калі ж другі аргумэнт&nbsp;&mdash; сымбальная чарада, тады гэтая апэрацыя эквівалентна мэтаду <code class="method">join</code>.</p>

  <h3 id="ExpressionsAndOperators_Operators_ShiftAppend">Зрух і дадаваньне: <code>&lt;&lt;</code> і <code>&gt;&gt;</code></h3>
  <p>Апэрацыі <code>&lt;&lt;</code> і <code>&gt;&gt;</code> у выпадку лікавых апэрандаў робяць бітавы зрух першага апэранду адпаведна ўлева і ўправа на колькасьць бітаў, пазначаных другім апэрандам.</p>
  <p>У выпадку сымбальных чародаў і масіваў апэрацыя <code>&lt;&lt;</code> дадае да левага свайго апэранду зьмест правага апэранду:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          message = "hello"       #=> "hello"
          messages = []           #=> []
          message << " world"     #=> "hello world"
          messages << message     #=> ["hello world"]
        ]]></script>

  <h3 id="ExpressionsAndOperators_Operators_Bitwise">Бітавыя: <code>~</code>, <code>&amp;</code>, <code>|</code> і <code>^</code></h3>
  <p>Лягічныя пабітавыя апэрацыі (адпаведна) NOT, AND, OR і XOR.</p>

  <h3 id="ExpressionsAndOperators_Operators_Comparison">Параўнаньне: <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> і <code>&lt;=&gt;</code></h4>
    <p>Апэрацыі праверкі ці першы аргумэнт (адпаведна) большы за другі, большы альбо роўны другому, меншы другога, меншы альбо роўны другому. Апошняя з гэтых апэрацыяў (<code>&lt;=&gt;</code>) мае трохі адрознае значэньне. Гэта ўнівэрсальная апэрацыя параўнаньня: калі левы апэранд меньшы за правы, яна вяртае <code>-1</code>, калі левы апэранд большы за правы, яна вяртае <code>1</code>, і калі яны роўныя, вяртае <code>0</code>.</p>

    <h3 id="ExpressionsAndOperators_Operators_Equality">Роўнасьць: <code>==</code>, <code>!=</code>, <code>=~</code>, <code>!~</code> і <code>===</code></h3>
    <p>Апэрацыя <code>==</code> правярае ці яе апэранды &laquo;роўныя&raquo; (у разуменьні левага апэранду). Апэрацыя <code>!=</code> вяртае супрацьлеглае значэньне апэрацыі <code>==</code>.</p>
    <p>Апэрацыя <code>=~</code> правярае ці сымбальная чарада адпавядае шаблёну (<i>Regexp</i>), а апэрацыя <code>!~</code> робіць адваротнае.</p>
    <p>Апэрацыя <code>===</code> правярае ці ўваходзіць пэўнае значэньне ў пазначаны дыяпазон.</p>

    <h3 id="ExpressionsAndOperators_Operators_Boolean">Лягічныя: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>, <code>and</code>, <code>or</code>, <code>not</code></h3>
    <p>Вынікам апэрацыі <code>&amp;&amp;</code> будзе <code class="keyword">true</code>, калі абодва яе аргумэнта маюць значэньне <code class="keyword">true</code>, інакш вынікам будзе <code class="keyword">false</code>. Вынікам апэрацыі <code>||</code> будзе <code class="keyword">true</code>, калі хаця б адзін зь яе аргумэнтаў мае значэньне <code class="keyword">true</code>, а вынікам <code class="keyword">false</code> будзе толькі тады, калі абодва аргумэнта таксама маюць значэньне <code class="keyword">false</code>. Апэрацыя <code>!</code> робіць булеўскае адмаўленьне свайго адзінага аргумэнта, то бок вяртае <code class="keyword">false</code>, калі аргумэнт мае значэньне <code class="keyword">true</code>, і, наадварот, вяртае <code class="keyword">true</code>, калі калі аргумэнт мае значэньне <code class="keyword">false</code>.</p>
    <p>Апэрацыі <code>and</code>, <code>or</code> і <code>not</code> зьяўляюцца меньш прыярытэтнымі эквівалентамі адпаведна апэрацый <code>&amp;&amp;</code>, <code>||</code> і <code>!</code>.</p>

    <h3 id="ExpressionsAndOperators_Operators_Ranges">Дыяпазону: <code>..</code> i <code>...</code></h3>
    <p>Гэтая апэрацыя служыць для стварэньня <a href="#Types_Ranges">дыяпазонаў</a> як аб'ектаў, дыяпазонных выразаў, а таксама ўмоўных дыяпазонаў.</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          1..10                 # новы Range аб#39;ект, аналяг: Range.new(1,10)
          x+1..x*x              # дыяпазонны выраз
          x==3..x==5            # умоўны дыяпазон
        ]]></script>
    <p>Апэрацыя мае 2 варыянты: уключны (<code>..</code>) і выключны (<code>...</code>):</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          1..10                 # значэньні ад 1 да 10 уключна
          1...10                # значэньні ад 1 да 9 уключна (без уліку апошняга значэньня)
        ]]></script>

    <h3 id="ExpressionsAndOperators_Operators_Conditional">Умоўная: <code>?:</code></h3>
    <p>Гэта адзіная тэрнарная (мае 3 апэранда) апэрацыя ў Ruby. Першы апэранд зьмяшчаецца перад пытальнікам, другі&nbsp;&mdash; паміж пытальнікам і двукроп'ем, а трэці&nbsp;&mdash; пасьля двукроп'я. Апэрацыя спачатку вылічвае свой першы апэранд, калі ён ня роўны <code class="keyword">false</code> ці <code class="keyword">nil</code>, тады апэрацыя вяртае другі свой апэранд, у адваротным выпадку&nbsp;&mdash; свой трэці апэранд. Можна сказаць, што гэтая апэрацыя зьяўляецца кароткай формай <a href="#LangParts_Statements_Conditional">ўмоўнага апэратара</a> (<code>if/then/else</code>). Прыклады:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          "You have #{n} #{n==1 ? 'message' : 'messages'}"

          # Наконт прагалаў паміж апэрандамі і знакамі апэрацыі:
          x==3?y:z      # Гэта дазваляльна
          3==x?y:z      # Сынтаксычная памылка: x? інтэрпрэтуецца як імя мэтаду
          (3==x)?y:z    # Дазваляльна: дужкі выпраўляюць праблему
          3==x ?y:z     # ...як і прагал перад пытальнікам

          # Наконт парадку разбору пры ўкладзеных апэрацыях:
          max = x>y ? x>z ? x : z : y>z ? y : z
          max = x>y ? (x>z ? x : z) : (y>z ? y : z)   # Эквівалентна папярэдняму
        ]]></script>

    <h3 id="ExpressionsAndOperators_Operators_Defined">Праверка вызначэньня: <code>defined?</code></h3>
    <p>Апэрацыя правярае ці вызначаны яе адзіны апэранд. </p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          # Прысвойвае значэньне f(x) зьменнай y, але толькі ў тым выпадку, калі
          # ў праграме ёсьць вызначэньне і мэтаду f, і зьменнай x
          y = f(x) if defined? f(x)
        ]]></script>

    <h3 id="ExpressionsAndOperators_Operators_Assignments">Прысваеньня</h3>
    <p>Апэрацыі прысваеньня звычайна даволі інтуітыўна зразумелыя, але што тычыцца гэтых апэрацыяў у Ruby, трэба спыніцца на некалькіх асаблівасьцях. Па-першае, значэньнем выразу прысваеньня зьяўляецца правы апэранд апэрацыі. Па-другое, апэрацыя прысваеньня зьяўляецца права-асацыятыўнай. Гэтыя дзьве асаблівасьці прыводзяць да таго, што выразы наступнага выгляду дазваляльныя ў Ruby:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          x = y = z = 0           # Прысвойвае значэньне 0 зьменным x, y, і z
          x = (y = (z = 0))       # Эквівалентна папярэдняму з пазнакай парадку прысваеньня
        ]]></script>

    <h4 id="ExpressionsAndOperators_Operators_Assignments_LocalVars">Прысваеньне лякальным зьменным</h4>
    <p>Наступнай асаблівасьцю зьяўляецца той факт, што ў Ruby няма яўных мэханізмаў у сынтаксе адрозьніць <a href="#LangParts_Variables">зьменную</a> ад <a href="#LangParts_Methods">мэтаду</a>. Гэта прыводзіць да таго, што выраз <code>x</code> у Ruby можа зьвяртацца да аднайменнай лякальнай зьменнай, альбо да аднайменнага мэтаду. Каб вырашыць гэтую неадназначнасьць, Ruby трактуе такі выраз як зьвяртаньне да лякальнай зьменнай, калі да гэтага было прысваеньне гэтай зьменнай:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          class Ambiguous
            def x; 1; end       # Мэтад зь імем "x". Заўсёды вяртае 1

            def test
              puts x            # Прысваеньня зьменнай не было, таму робіць выклік мэтада вышэй: друкуе 1

              # Хаця прысваеньне ніжэй ніколі ня будзе выканана (з-за "if false") парсэр "убачыць"
              # прысваеньне зьменнай x і будзе трактаваць выраз "х" да канца мэтаду
              # як зьвяртаньне да зьменнай.
              x = 0 if false

              puts x            # зараз x - гэта зьменная, але ёй ніколі не было
                                # прысвоена значэньне, таму: друкуе nil

              x = 2             # На гэты раз прысваеньне будзе выканана
              puts x            # Таму гэты выраз прывядзе да друкаваньня 2
            end
          end
        ]]></script>

    <h4 id="ExpressionsAndOperators_Operators_Assignments_AttrsArrays">Прысваеньне атрыбутам і масівам</h4>
    <p>Прысваеньне <mark>атрыбутам</mark> і <a href="#Types_Arrays">масівам</a> у Ruby зьяўляецца на самай справе кароткай формай выклікаў адпаведных мэтадаў. Уявім, што аб'ект <code>o</code> мае аб'яўленьне мэтаду <code class="method">m=</code>, тады выраз <code>o.m</code> можа зьяўляцца левым апэрандам апэрацыі прысваеньня:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          o.m = v
        ]]></script>
    <p>Гэта прысваеньне інтэрпрэтатар Ruby пераўтворыць у выклік мэтаду:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          o.m=(v)
        ]]></script>
    <p>Звычайна аб'яўленьне мэтаду <code class="method">m=</code> ідзе ў пары з аб'яўленьнем мэтаду <code class="method">m</code>, каторы проста вяртае значэньне, апошні раз перададзенае мэтаду <code class="method">m=</code>. Калі аб'ект мае такую пару мэтадаў, кажуць, што аб'ект мае атрыбут <code class="attr">m</code>. Мэтад <code class="method">m=</code> называюць пры гэтым <i>setter</i>, а мэтад <code class="method">m</code>&nbsp;&mdash; <i>getter</i>.</p>
    <p>Прысваеньне элемэнтам масіву таксама адбываецца праз выклік адпаведнага мэтаду. Калі аб'ект <code>o</code> мае аб'яўленьне мэтаду <code class="method">[]=</code>, каторы прымае 2 аргумэнты, тады выраз <code>o[x] = y</code> будзе на самай справе выкананы як:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          o.[]=(x,y)
        ]]></script>
    <p>Па аналёгіі, калі аб'ект <code>o</code> мае аб'яўленьне мэтаду <code class="method">[]=</code>, каторы прымае 3 аргумэнты, тады выраз <code>o[x,y] = z</code> будзе на самай справе выкананы як:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          o.[]=(x,y,z)
        ]]></script>

    <h4 id="ExpressionsAndOperators_Operators_Assignments_Abbreviated">Скарочаныя формы прысваеньняў</h4>
    <p>Скарочаныя формы прысваеньняў камбінуюць прысваеньне з іншай апэрацыяй. Найбольш ужываныя з такіх прысваеньняў&nbsp;&mdash; гэта апэрацыі інкрымэнту і дэкрымэнту:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          x += 1            # Эквівалентна x = x + 1

          x -= 1            # Эквівалентна x = x - 1
        ]]></script>
    <p>Яшчэ адна скарочаная форма, каторая ўжываецца часьцей за астатнія, гэта <code>||=</code>. Яна звычайна ўжываецца ў выпадку, калі трэба зьвярнуцца да масіву ці хэшу, каторыя могуць быць яшчэ не ініцыялізаваны (роўныя <code class="keyword">nil</code>):</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          results ||= []

          # Што эквівалентна:
          results = results || []
        ]]></script>
    <p>Такі выраз прывядзе да таго, што калі <code class="var">results</code> роўны <code class="keyword">nil</code>, будзе выкананы правы апэранд булеўскай апэрацыі <code>||</code> і <code class="var">results</code> будзе праініцыялізаваны пустым масівам. Інакш, калі ён ня роўны <code class="keyword">nil</code> (то бок ужо праініцыялізваны раней), ён застанецца нязьменным.</p>

    <h4 id="ExpressionsAndOperators_Operators_Assignments_Parallel">Паралельныя прысваеньні</h4>
    <p>Гэта прысваеньні, у каторых альбо cправа, альбо зьлева, альбо і там, і там больш чым адзін апэранд. Гэтыя множныя апэранды падзяляюцца паміж сабой коскамі, і перад некаторымі зь іх можа стаяць зорачка (тлумачэньне будзе ніжэй).</p>
    <p>Некаторыя варыянты такіх прысваеньняў даволі відавочныя, але ёсьць і складаныя. Таму разгледзем такія прысваеньні больш падрабязна:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          # Аднолькавая колькасьць апэрандаў зьлева і справа:
          x, y, z = 1, 2, 3         # x=1; y=2; z=3

          x,y = y,x                 # Абмен значэньнямі, апэрацыі выконваюцца паралельна
          x = y; y = x              # Ня тое ж самае, што вышэй: апэрацыі выконваюцца пасьлядоўна

          # Адзін апэранд зьлева, шмат апэрандаў справа:
          x = 1, 2, 3               # x = [1,2,3]
          x, = 1, 2, 3              # x = 1; астатнія апэранды справа адкідваюцца

          # Шмат апэрандаў зьлева, адзін масіў справа:
          x, y, z = [1, 2, 3]       # Тое ж, што і: x,y,z = 1,2,3

          # Больш за 1 апэранд зьлева і справа, але не аднолькавая іх колькасьць:
          x, y, z = 1, 2            # x=1; y=2; z=nil
          x, y = 1, 2, 3            # x=1; y=2; 3 адкідваецца

          # Splat-апэрацыя (зорка перад апэрандам):
          x, y, z = 1, *[2,3]       # Тое ж, што і: x,y,z = 1,2,3

          x,*y = 1, 2, 3            # x=1; y=[2,3]
          x,*y = 1, 2               # x=1; y=[2]
          x,*y = 1                  # x=1; y=[]

          # Толькі Ruby 1.9
          *x,y = 1, 2, 3 # x=[1,2]; y=3
          *x,y = 1, 2 # x=[1]; y=2
          *x,y = 1 # x=[]; y=1

          x, y, *z = 1, *[2,3,4]    # x=1; y=2; z=[3,4]

          # Дужкі пры паралельным прысваеньні:
          x,(y,z) = a, b            # Тое ж, што і: x = a; y,z = b

          x,y,z = 1,[2,3]           # Бяз дужак: x=1; y=[2,3]; z=nil
          x,(y,z) = 1,[2,3]         # З дужкамі: x=1; y=2; z=3
        ]]></script>
</section>

<section>
  <h1 id="StatementsAndControl" data-content-item-open>Апэратары і кіруючыя структуры</h1>

  <h2 id="StatementsAndControl_Conditionals">Умоўнае выкананьне</h2>

  <h2 id="StatementsAndControl_Loops">Цыклі</h2>

  <h2 id="StatementsAndControl_Iterators">Ітэратары і пералічэньні</h2>

  <h2 id="StatementsAndControl_Blocks">Блёкі</h3>
    <p>Пэўны код, заключаны ў фігурныя дужкі альбо паміж ключавымі словамі <code class="keyword">do</code> і <code class="keyword">end</code>, называецца блёкам. Блёкі неабходны для групаваньня некалькіх інструкцыяў:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        2.times {
          print "Hello!"
          print "Hello!"
        }

        loop do
          print "Much better."
          print "Ah.  More space!"
          print "My back was killin' me in those crab pincers."
        end
        ]]></script>
    <p>Блёкі можна асацыяваць з выклікамі мэтадаў. Такія мэтады могуць выклікаць тады гэтыя блёкі пры дапамозе ключавога слова <code class="keyword">yield</code>:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        def sampleMethod
          yield
          yield
        end

        sampleMethod { puts "In the block" }
        ]]></script>
    <p>У выніку будзе выведзена на экран:</p>
    <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        In the block
        In the block
        ]]></script>

    <h3 id="StatementsAndControl_Blocks_Arguments">Аргумэнты блёкаў і ітэратары</h3>
    <p>У блёкі могуць перадавацца аргумэнты. У гэтым выпадку яны зьмяшчаюцца ў самым пачатку блёку, заключаюцца ў знакі вертыкальных ліній і падзяляюцца коскамі:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        { |x, y| x + y }
        ]]></script>
    <p>У прыкладзе вышэй <code class="local_var">x</code> і <code class="local_var">y</code>&nbsp;&mdash; аргумэнты блёку, каторы ўтрымлівае адзіную інструкцыю&nbsp;&mdash; складаньне значэньняў гэтых аргумэнтаў.</p>
    <p>Аргумэнты блёкаў актыўна выкарыстоўваюцца ў ітэратарах:</p>
    <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        a = ['ant', 'bee', 'cat', 'dog', 'elk']   # ствараем масіў радкоў
        a.each { |animal| puts animal }           # ітэратар праходзіць праз элемэнты масіва,
                                                  # каторыя перадаюцца ў якасьці аргумэнту animal у блёк
        ]]></script>
    <p>У выніку на экран будзе выведзена:</p>
    <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        ant
        bee
        cat
        dog
        elk
        ]]></script>

    <h2 id="StatementsAndControl_AlteringControlFlow">Зьмена нармальнай хады праграмы</h2>

    <h2 id="StatementsAndControl_Exceptions">Выключэньні і іх апрацоўка</h2>

    <h2 id="StatementsAndControl_Threads">Плыні і ніці</h2>
</section>

<section>
  <h1 id="MethodsAndProcs" data-content-item-open>Мэтады, працэдуры, лямбды і замыканьні</h1>

  <h2 id="MethodsAndProcs_Methods">Мэтады</h2>

  <h2 id="MethodsAndProcs_ProcsAndLambdas">Працэдуры і лямбды</h2>

  <h2 id="MethodsAndProcs_Closures">Замыканьні</h2>
</section>

<section>
  <h1 id="ClassesAndModules" data-content-item-open>Клясы і модулі</h1>

  <h2 id="ClassesAndModules_Classes">Клясы</h2>

  <h2 id="ClassesAndModules_Modules">Модулі</h2>

</section>

<section>
  <h1 id="LangParts">Часткі мовы</h1>
  <p>Любая мова, у тым ліку і праграмаваньня, складаецца з пэўных частак. Разгледзім часткі, зь якіх складаецца <i>Ruby</i>.</p>





  <h2 id="LangParts_Classes">Клясы</h2>

  <h2 id="LangParts_Methods">Мэтады</h2>
  <p><a href="http://rubysource.com/functional-programming-techniques-with-ruby-part-ii/?utm_medium=email&utm_campaign=RubySource+3rd+April&utm_content=RubySource+3rd+April+CID_29d66d58498d41d09092a4ead0696666&utm_source=Newsletter&utm_term=Functional+Programming+Techniques+With+Ruby+Part+2">Functional Programming Techniques With Ruby</a></p>
  <p>Як ужо пазначалася вышэй мэтады&nbsp;&mdash; гэта запыты да аб&#8217;ектаў. Каб зрабіць выклік мэтаду, пазначаецца <a href="#LangParts_Variables">зьменная</a> ці <a href="#LangParts_Consts">канстанта</a>, пасьля каторай ставіцца кропка і потым імя мэтаду:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          front_door.open
        ]]></script>
  <p>Выклікі мэтадаў могуць ісьці адзін за адным, таму што, як мы памятаем, вынік мэтаду&nbsp;&mdash; гэта таксама аб&#8217;ект:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          front_door.open.close
        ]]></script>
  <p>Гэты складаны выклік кажа ўваходным дзьвярам адчыніцца і адразу ж зачыніцца. Імёны мэтадаў могуць утрымліваць клічнікі і пытальнікі:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          front_door.is_open?
        ]]></script>
  <p>Некаторыя мэтады зьяўляюцца ядром мовы і могуць быць выкліканы без пазначэньня экзэмпляру, да каторага яны адносяцца:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          print "Hello!"
        ]]></script>
  <p>Як гэта працуе? У Ruby на самым версе герархіі клясаў знаходзіцца кляса <code class="class">Object</code>. Усе мэтады гэтай клясы, адпаведна, калі не перавызначыныя яўна, успадкоўваюцца ўсімі іншымі клясамі. Дык вось у <code class="class">Object</code> <mark>дамешваецца</mark> модуль <code class="class">Kernel</code> (<i>kernel</i> па ангельску азначае <i>ядро</i>). Адпаведна, <a href="http://www.ruby-doc.org/core/classes/Kernel.html">усе мэтады ядра мовы</a> даступны глябальна і без патрэбы пазначаць экземпляр нейкай клясы.</p>

  <h3 id="LangParts_Methods_redo">redo</h3>
  <p>Выклік <code class="keyword">redo</code> у мэтадзе прыводзіць да яго ж выкліку яшчэ раз:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          class LotteryTicket

            NUMERIC_RANGE = 1..25

            attr_reader :picks, :purchased

            def initialize(*picks)
              if picks.length != 3
                raise ArgumentError, "three numbers must be picked"
              elseif picks.uniq.length != 3
                raise ArgumentError, "the three pick must be different numbers"
              elseif picks.detect { |p| not NUMERIC_RANGE === p}
                raise ArgumentError, "the three pick must be numbers between 1 and 25"
            end

            @picks = picks
            @purchased = Time.now
          end

          def self.new_random
            new(rand(25) + 1, rand(25) + 1, rand(25) + 1)
          rescue ArgumentError
            redo
          end
        ]]></script>
  <p>Калі ў выпадку выкліку <code>LotteryTicket.new_random</code> будуць згенерэны хаця б дзьве аднолькавыя лічбы, тады <code>picks.uniq.length != 3</code> прывядзе да кіданьня памылкі, але <code>rescue ArgumentError</code> зловіць яе, а <code class="keyword">redo</code> выкліча мэтад <code class="method">new_random</code> яшчэ раз і гэта ўсё столькі разоў, пакуль усе 3 лічбы ня будуць унікальнымі.</p>

  <h2 id="LangParts_MethodArguments">Аргумэнты мэтадаў</h2>
  <p>Некаторыя мэтады патрабуюць дадатковую інфармацыю, каб выканаць свае дзеяньні. Гэтую інфармацыю ім перадаюць пры дапамозе аргумэнтаў, каторыя ідуць пасьля імені мэтаду, заключаюцца ў дужкі (не абавязкова) і падзяляюцца коскамі:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        front_door.paint(3, :red)
        ]]></script>
  <p>Калі перад аргумэнтам мэтаду стаіць зорачка, гэта азначае, што можа быць любая колькасьць фактычных парамэтраў мэтаду і яны будуць перададзеныя як масіў:</code></p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        def initialize(*picks)
          if picks.length != 3
            raise ArgumentError, "three numbers must be picked"
          ...
        end
        ]]></script>

  <h2 id="LangParts_ClassMethods">Мэтады клясаў</h2>
  <p>Мэтады клясаў (аналяг статычных мэтадаў у <a href="../java/index.html"><span class="term">Java</span></a>) гэта запыты да клясаў, а не іх экзэмпляраў. Выклік адбываецца праз пазначэньне імені клясы, за каторым ідзе падвойнае двукропье і потым імя мэтаду:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          Door::new(:oak)
        ]]></script>



  <!-- TODO!!!! -->

  <h2 id="Basics_classes_attrs">Атрыбуты</h2>
  <p>Уводзіць у клясу зьменныя <code class="local_var">a</code> і <code class="local_var">b</code>:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        attr :a, :b
        ]]></script>
  <p>Уводзіць у клясу зьменныя <code class="local_var">a</code> і <code class="local_var">b</code>, а таксама <i>getter</i>- і <i>setter</i>-мэтады для ніх:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        attr_accessor :a, :b
        ]]></script>
  <p>Уводзіць у клясу зьменныя <code class="local_var">a</code> і <code class="local_var">b</code>, а таксама <i>getter</i>-мэтады для ніх:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        attr_reader :a, :b
        ]]></script>
  <p>Уводзіць у клясу зьменныя <code class="local_var">a</code> і <code class="local_var">b</code>, а таксама <i>setter</i>-мэтады для ніх:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        attr_writer :a, :b
        ]]></script>

  <h2 id="Basics_classes_extending">Пашырэньне</h2>
  <p>Любая кляса, нават базавая, можа быць пашыраная:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class String
          def new_method_name
            p "Hello the World!"
          end
        end

        "asdf".new_method_name
        ]]></script>
  <p>Папярэдні прыклад вывядзе ў кансоль <code>Hello the World!</code></p>

  <!-- TODO!!!! -->

</section>




<section>
  <h1 id="Types">Стандартныя тыпы</h1>
  <p>Стандартныя тыпы, як лікі, радкі сымбаляў і інш.&nbsp;&mdash; гэта базавыя цаглінкі, з каторых будуецца Ruby-праграма.</p>

  <h2 id="Types_Object">Object</h2>
  <p><code class="class">Object</code> у Ruby зьяўляецца базавай для астатніх клясаў, каторыя ўскосна ўспадкоўваюць ад яе. Хаця сама знаходзіцца не ў самым версе герархіі клясаў, а зьяўляецца спадчыннай ад клясы <code class="class">BasicObject</code>.</p>

  <h3 id="Types_Object_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Object.html">Object</a></li>
    </ul>
  </div>
  <p>Разгледзем у гэтым разьдзеле асноўныя мэтады, каторыя вызначаюцца ў <code class="class">Object</code>. Пры разглядзе іншых клясаў мэтады, прыведзеныя тут і сэнс каторых у тых клясах не зьмяняецца, рязглядацца ня будуць.</p>

  <h4 id="Types_Object_Methods_ID">Вызначэньне ID аб&#8217;екта</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # ніякія з любых двух аб'ектаў ня маюць аднолькавага ID
        "Hello".object_id #=> напр. 22628100
        ]]></script>

  <h4 id="Types_Object_Methods_Class">Вызначэньне клясы аб&#8217;екта</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1.class           #=> Fixnum
        "Hello".class     #=> String
        ]]></script>

  <h4 id="Types_Object_Methods_InstanceOf">Праверка прыналежнасьці да клясаў</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        module M;    end
        class A
          include M
        end
        class B < A; end
        class C < B; end
        b = B.new
        b.instance_of? A    #=> false
        b.instance_of? B    #=> true
        b.instance_of? C    #=> false
        b.instance_of? M    #=> false
        b.kind_of? A        #=> true
        b.kind_of? B        #=> true
        b.kind_of? C        #=> false
        b.kind_of? M        #=> true
        ]]></script>
  <p><code class="method">instance_of?</code>&nbsp;&mdash; строгая праверка прыналежнасьці аб&#8217;екта да пэўнай клясы (без уліку герархіі і ўключаных модуляў). <code class="method">kind_of?</code> (альбо <code class="method">is_a?</code>)&nbsp;&mdash; мяккая праверка прыналежнасьці аб&#8217;екта да клясы, то бок ня толькі непасрэднай клясы, але і ўсёй герархіі клясаў альбо ўключаных модуляў (гл. прыклад вышэй). Будзьце ўважлівымі тыя, хто пераходзіць да вывучэньня Ruby з <a href="../java/index.html"><span class="term">Java</span></a>. Той сэнс, каторы рэалізаваны яваўскім <code class="method">instance_of</code>, у Ruby рэалізуецца мэтадам <code class="method">kind_of?</code> (альбо <code class="method">is_a?</code>), а не <code class="method">instance_of?</code>.</p>

  <h4 id="Types_Object_Methods_Compare">Апэрацыі параўнаньня</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # правярае ці спасылаюцца ідэнтыфікатары (зьменныя) на тыя ж самыя аб'екты
        a = "Hello"
        b = "Hello"
        a.equal? b        #=> false - ня гледзячы на тое, што a і b маюць адно
                          # і тое ж значэньне, спасылаюцца яны на розныя аб'екты

        # звычайна, калі не пазначана інакш у адпаведнай клясе, параўнаньне значэньняў аб'ектаў:
        1 == 1.0          #=> true
        a.eql? b          #=> true (a i b - радкі "Hello", вызначаныя вышэй)

        # параўноўвае значэньні аб'ектаў а-ля Comparable:
        1 <=> 1           #=> 0
        1 <=> 2           #=> -1
        2 <=> 1           #=> 1
        ]]></script>

  <h4 id="Types_Object_Methods_nil">Праверка на <code class="keyword">nil</code></h4>
  <p>Аб&#8217;ект, каторы нікуды не спасылаецца, ня проста "нішто", як напрыклад у <a href="../java/index.html"><span class="term">Java</span></a>, але пусты аб&#8217;ект, у каторага можна выклікаць пэўныя мэтады. Адным з такіх мэтадаў і зьяўляецца праверка на тое, пусты аб&#8217;ект ці не:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        nil.nil?          #=> true

        a = 5
        a.nil?            #=> false
        a = nil
        a.nil?            #=> true
        ]]></script>

  <h4 id="Types_Object_Methods_Clone">Кланаваньне</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class Klass
            attr_accessor :str
        end
        s1 = Klass.new
        s1.str = "Hello"    #=> s1.str="Hello"
        s2 = s1.clone       #=> s2.str="Hello"
        s3 = s1.dup         #=> s3.str="Hello"
        s2.str[1,4] = "i"   #=> s1.str="Hi", s2.str="Hi", s3.str="Hi"
        ]]></script>
  <p>Мэтады <code class="method">clone</code> і <code class="method">dup</code> у <code class="class">Object</code> падобны&nbsp;&mdash; яны капіруюць зьменныя аднаго экзэмпляру ў іншы. Пры гэтым капіруюцца спасылкі, а не значэньні. Але адрозьніваюцца яны тым, што мэтад <code class="method">clone</code> акрамя гэтага капіруе яшчэ і <a href="#Types_Object_Methods_Freeze"><code class="method">frozen</code></a>-стан экзэмпляру, а <code class="method">dup</code> гэтага ня робіць.</p>

  <h4 id="Types_Object_Methods_Freeze">Замарозка</h4>
  <p>Мэтад <code class="method">freeze</code> прадухіляе аб&#8217;ект ад далейшых зьменаў.</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        a = [ "a", "b", "c" ]
        a.freeze
        a.frozen?           #=> true
        a << "z"            #=> prog.rb:4:in `<<': can't modify frozen array (RuntimeError)
                            #=> from prog.rb:4
        ]]></script>

  <h4 id="Types_Object_Methods_StrRepr">Радковае прадстаўленьне аб&#8217;ектаў</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class Klass
            attr_accessor :str
        end
        s1 = Klass.new
        s1.str = "Hello"
        s1.inspect          #=> "#<Klass:0x2922a68 @str=\"Hello\">"
        s1.to_s             #=> "#<Klass:0x2922a68>"
        ]]></script>
  <p>Мэтад <code class="method">inspect</code> вяртае радок, які ўтрымлівае чытэльнае чалавекам прадстаўленьне аб&#8217;екта. Мэтад <code class="method">to_s</code>, вызначаны ў <code class="class">Object</code>, вяртае імя клясы і ID аб&#8217;екта.</p>

  <h4 id="Types_Object_Methods_ClassStructure">Мэтады інспэкцыі структуры клясы</h4>
  <p>Асобнай групай стаяць мэтады інспэкцыі структуры клясы&nbsp;&mdash; вызначэнье якія ёсьць у аб&#8217;екта зьменныя, мэтады і іншыя атрыбуты:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class Klass
          attr_accessor :a1

          def initialize(p1)
            @a2 = 3
            @a3 = p1
          end

          def kMethod()
          end
        end
        k = Klass.new

        # масіў усіх мэтадаў, каторыя могуць быць выкліканыя ў аб&#8217;екта:
        k.methods           #=> ["kMethod", "freeze", "nil?", "is_a?", "class", ... і гэтак далей

        # масіў прыватных, пратэктэд і паблік мэтадаў, каторыя могуць быць выкліканыя ў аб'екта:
        k.private_methods
        k.protected_methods
        k.public_methods

        # правярае ці мае аб'ект пэўны мэтад:
        k.respond_to?("aMethod")  #=> false
        k.respond_to?("kMethod")  #=> true

        # масіў зьменных аб&#8217;екта (зьвярніце ўвагу, што аб'яўленьне accessor'аў - a1 у нашым
        # выпадку, не прыводзіць да ўстаўкі паўнавартасных зьменных):
        k.instance_variables      #=> [:@a1, :@a2]

        # правярае ці мае аб'ект зьменную:
        instance_variable_defined?(:@a1)      #=> true
        instance_variable_defined?("@a2")     #=> true
        instance_variable_defined?(:@b)       #=> false
        ]]></script>

  <h2 id="Types_Numbers">Лікі</h2>
  <figure style="float: right;">
    <img alt="Герархія ўбудаваных лікавых клясаў" title="Герархія ўбудаваных лікавых клясаў" src="../images/ruby_numeric_types.png"/>
    <figcaption class="imgcaption">Герархія ўбудаваных лікавых клясаў</figcaption>
  </figure>
  <p>Ruby утрымлівае 5 убудаваных клясаў для прадстаўленьня цэлых і рэчаісных лікаў (гл. схему).</p>

  <h3 id="Types_Numbers_Integers">Цэлыя</h3>
  <p>Цэлыя лікі (экзэмпляры базавай для ўсіх цэлых лічбаў клясы <code class="class">Integer</code>) складаюцца з пасьлядоўнасьці лічбаў, перад каторымі <i>можа</i> стаяць знак плюсу ці мінусу:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1, 23, -10000
        ]]></script>
  <p>У мэтах візуальнага падзяленьня тысячаў у ліках дазваляецца выкарыстоўваць знак падкрэсьліваньня:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        population = 12_000_000_000
        ]]></script>
  <p>Цэлыя могуць быць адвольнай дліны ці памеру (аж да значэньня, каторае абмежавана даступнай свабоднай памяцьцю кампутара). У межах пэўнага дыяпазону (звычайна ад -2<sup>30</sup> да 2<sup>30</sup>-1 ці ад -2<sup>62</sup> да 2<sup>62</sup>-1) цэлыя прадстаўляюцца як аб&#8217;екты клясы <code class="class">Fixnum</code>&nbsp;&mdash; малыя цэлыя. Калі ж яны выходзяць за гэты дыяпазон, то Ruby пераводзіць іх у аб&#8217;екты клясы <code class="class">Bignum</code>&nbsp;&mdash; вялікія цэлыя, і наадварот. Прычым гэты працэс пераводу лікаў з <code class="class">Fixnum</code> у <code class="class">Bignum</code> і наадварот&nbsp;&mdash; празрысты для распрацоўшчыка, Ruby робіць гэта сам:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        num = 8
        7.times do
          print num.type, " ", num, "\n"
          num *= num
        end
        ]]></script>
  <p>У выніку на экран будзе выведзена:</p>
  <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        Fixnum 8
        Fixnum 64
        Fixnum 4096
        Fixnum 16777216
        Bignum 281474976710656
        Bignum 79228162514264337593543950336
        Bignum 6277101735386680763835789423207666416102355444464034512896
        ]]></script>
  <p>Цэлыя могуць быць таксама запісаныя ў васьмірычным, шаснаццацірычным ці дваічным выглядзе:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        0377            # васьмірычны выгляд, з прэфіксам 0
        0xaabb          # шаснаццацірычны выгляд, з прэфіксам 0x
        0b101_010       # бінарны выгляд, з прэфіксам 0b
        ]]></script>
  <p>Акрамя гэтага цэлы лік, як адлюстраваньне коду сымбалю, можна атрымаць паставіўшы знак пытальніку перад гэтым сымбалем:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        ?a              # код сымбалю 'a' (0x61)
        ?\n             # код пераводу радка (0x0a)
        ]]></script>

  <h3 id="Types_Numbers_Float">Рэчаісныя</h3>
  <p>Рэчаісныя лікі (экзэмпляры клясы <code class="class">Float</code>) складаюцца з пасьлядоўнасьці лічбаў і нефіксаванай кропкі ці навуковай натацыі:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        3.14, -808.08, 12.043e-04
        ]]></script>
  <p>Зьвярніце ўвагу, што пасьля нефіксаванай кропкі абавязкова павінна стаяць лічба:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1.e3            # у гэтым выпадку Ruby паспрабуе выклікаць мэтад e3 у цэлага 1
        ]]></script>

  <h3 id="Types_Numbers_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Numeric.html">Numeric</a></li>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Integer.html">Integer</a></li>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Fixnum.html">Fixnum</a></li>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Bignum.html">Bignum</a></li>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Float.html">Float</a></li>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/BigDecimal.html">BigDecimal</a></li>
    </ul>
  </div>
  <p>Коратка пра мэтады, каторыя прадстаўляюцца лікамі (поўныя сьпісы і тлумачэньні даступныя па спасылкам зьлева):</p>

  <h4 id="Types_Numbers_Methods_Math">Матэматычныя апэрацыі</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1 + 2             #=> 3 (складаньне)
        5 - 3             #=> 2 (адніманьне)
        2 * 3             #=> 6 (памнажэньне)
        5 / 3             #=> 1 (цэлалікавае дзяленьне)
        6 / 4.0           #=> 1.25 (рэчаіснае дзяленьне)
        2 ** 3            #=> 8 (ступень)
        1.next            #=> 2 (інкрэмэнт, тое ж што і 1.succ)
        ]]></script>

  <h4 id="Types_Numbers_Methods_Binary">Бінарныя апэрацыі</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1 & 2             #=> 3 (бінарнае AND)
        1 ^ 5             #=> 4 (бінарнае XOR)
        1 | 3             #=> 3 (бінарнае OR)
        ~4                #=> 3 (бінарнае адмаўленьне)

        4 >> 1            #=> 2 (бінарны зрух управа, "хуткае дзяленьне на адпаведную ступень 2")
        4 << 1            #=> 8 (бінарны зрух улева, "хуткае памнажэньне на адпаведную ступень 2")
        ]]></script>

  <h4 id="Types_Numbers_Methods_Compare">Апэрацыі параўнаньня</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1 < 2             #=> true (строгае меньш)
        1 > 2             #=> false (строгае больш)
        1 <= 1            #=> true (меньш альбо роўна)
        2 >= 1            #=> true (больш альбо роўна)
        1 == 1.0          #=> true (параўнаньне значэньняў)

        # параўноўвае значэньні а-ля Comparable:
        1 <=> 1           #=> 0
        1 <=> 2           #=> -1
        2 <=> 1           #=> 1

        # параўноўвае тыпы і значэньні (true толькі калі роўныя і тыпы, і значэньні):
        1.eql?(1.0)       #=> false
        (1.0).eql?(1.0)   #=> true
        ]]></script>

  <h4 id="Types_Numbers_Methods_CriteriaCheck">Праверкі адпавяданьня пэўнаму крытэру</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # правярае ці лік цэлы:
        1.integer?        #=> true
        1.2.integer?      #=> false

        # правярае ці лік не нулявы:
        1.nonzero?        #=> 1
        0.nonzero?        #=> nil

        # правярае ці лік нулявы:
        1.zero?           #=> false
        0.zero?           #=> true

        # правярае ці лік цотны/няцотны:
        2.even?           #=> true
        1.odd?            #=> true
        ]]></script>

  <h4 id="Types_Numbers_Methods_NumberTransform">Мэтады лікавых трасфармацый</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # модуль ліку:
        -12.abs           #=> 12

        # бліжэйшае большае цэлае:
        1.2.ceil          #=> 2
        (-1.2).ceil       #=> -1

        # бліжэйшае меншае цэлае:
        1.2.floor         #=> 1
        (-1.2).floor      #=> -2

        # акругленьне і адкіданьне дробнай часткі:
        1.5.round         #=> 2
        1.5.truncate      #=> 1 (тое ж што і to_i, to_int для рэчаісных лікаў)
        ]]></script>

  <h4 id="Types_Numbers_Methods_Iterators">Ітэратары</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        5.times { |i| print i, " " }        #=>0 1 2 3 4
        5.downto(1) { |i| print i, " " }    #=>5 4 3 2 1
        5.upto(10) { |i| print i, " " }     #=>5 6 7 8 9 10
        50.step(80, 5) { |i| print i, " " } #=>50 55 60 65 70 75 80
        ]]></script>

  <h4 id="Types_Numbers_Methods_TypeTransform">Мэтады трасфармацый у іншыя тыпы</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # трансфармацыя ў сымбаль, чый код прадстаўляе лік:
        65.chr                      #=> "A"
        255.chr(Encoding::UTF_8)    #=> "\303\277"

        # трансфармацыя ў радок:
        12345.to_s        #=> "12345" (то е ж што і 12345.to_s(10))
        12345.to_s(2)     #=> "11000000111001"
        12345.to_s(16)    #=> "3039"

        # трансфармацыя ў рэчаісны лік (калі Bignum трансфармуецца і яго значэньне не зьмяшчаецца
        # у Float, вынік будзе нявызначаны):
        5.to_f            #=> 5.0

        # трансфармацыя ў цэлы лік:
        1.5.to_i          #=> 1 (тое ж што і to_int, trancate для рэчаісных лікаў)

        ]]></script>

  <h4 id="Types_Numbers_Methods_DivideModulo">Мэтады дзяленьня і знаходжаньня астачы</h4>
  <p>Асобна спынімся на мэтадах дзяленьня і знаходжаньня астачы (рэшты) ад цэлага дзяленьня. Заўважым, што мэтад <code class="method">divmod</code> вяртае не адно, а масіў значэньняў. Прычым, калі <code>q, r = x.divmod(y)</code>, тады:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        q = floor(float(x)/float(y))
        x = q*y + r
        ]]></script>
  <p>Параўнаўчая табліца:</p>
  <pre>
           &nbsp;&nbsp;a &nbsp;&nbsp;| &nbsp;b | a.divmod(b) | a.div(b), a/b | a.modulo(b), a%b | a.remainder(b)
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;13 &nbsp;&nbsp;| &nbsp;4 | &nbsp;&nbsp;3, &nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;13 &nbsp;&nbsp;| -4 | &nbsp;-4, &nbsp;-3 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
           ------+----+-------------+---------------+------------------+---------------
           -13 &nbsp;&nbsp;| &nbsp;4 | &nbsp;-4, &nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-1
           ------+----+-------------+---------------+------------------+---------------
           -13 &nbsp;&nbsp;| -4 | &nbsp;&nbsp;3, &nbsp;-1 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-1
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;11.5 | &nbsp;4 | &nbsp;&nbsp;2, &nbsp;&nbsp;3.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;11.5 | -4 | &nbsp;-3, &nbsp;-0.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-0.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5
           ------+----+-------------+---------------+------------------+---------------
           -11.5 | &nbsp;4 | &nbsp;-3, &nbsp;&nbsp;0.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-3.5
           ------+----+-------------+---------------+------------------+---------------
           -11.5 | -4 | &nbsp;&nbsp;2, &nbsp;-3.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-3.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-3.5
        </pre>

  <h2 id="Types_Enumerable">Пералічэньне</h2>
  <p><mark>Модуль</mark> <code class="class">Enumerable</code> не зьяўляецца самастойнай клясай, але <mark>дамешкам</mark> да іншых клясаў, каб надаць ім уласьцівасьці калекцыяў аб'ектаў.</p>

  <h3 id="Types_Enumerable_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Enumerable.html">Enumerable</a></li>
    </ul>
  </div>
  <p>Коратка пра мэтады, каторыя прадстаўляюцца пералічэньнямі (поўны сьпіс і тлумачэньне даступныя па спасылцы зьлева).</p>

  <h4 id="Types_Enumerable_Methods_Checking">Праверка элемэнтаў</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          # правярае ці ўсе элемэнты задавальняюць умове;
          # калі ўмова не задана, правярае ці ўсе элемэнты не nil (і не false):
          ["ant", "bear", "cat"].all? { |word| word.length >= 3 }   #=> true
          [nil, true, 99].all?                                      #=> false

          # правярае ці хаця б адзін элемэнт задавальняе умове;
          # калі ўмова не задана, правярае ці ёсьць хаця б адзін элемэнт не nil (альбо не false):
          ["ant", "bear", "cat"].any? { |word| word.length >= 4 }   #=> true
          [nil, true, 99].any?                                      #=> true

          # правярае ці ніводны элемэнт не задавальняе умове;
          # калі ўмова не задана, правярае ці ўсе элемэнты nil (альбо false):
          ["ant", "bear", "cat"].none? { |word| word.length >= 4 }  #=> false
          [nil, false].none?                                        #=> true

          # правярае ці дакладна адзін элемэнт задавальняе умове;
          # калі ўмова не задана, вярне true толькі, калі дакладна адзін элемэнт не nil (не false):
          ["ant", "bear", "cat"].one? { |word| word.length == 4 }   #=> true
          [nil, true, 99].one?                                      #=> false

          # вяртае true, калі хаця б адзін элемэнт пералічэньня роўны парамэтру:
          ["ant", "bear", "cat"].include?("cat")                    #=> true
        ]]></script>

  <h4 id="Types_Enumerable_Methods_Search">Пошук элемэнтаў</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          # перадае кожны элемэнт пералічэньня ў блёк і вяртае першы зь іх, для каторага блёк вяртае true;
          # калі ніводнага не было знойдзена, вяртаецца nil:
          (1..10).detect { |i| i % 5 == 0 and i % 7 == 0 }          #=> nil
          (1..100).find { |i| i % 5 == 0 and i % 7 == 0 }           #=> 35

          # перадае кожны элемэнт пералічэньня ў блёк і вяртае масіў тых зь іх, для каторых блёк вяртае true:
          (1..10).find_all { |i|  i % 3 == 0 }                      #=> [3, 6, 9]

          # вяртае індэкс першага з элемэнтаў, каторы задавальняе ўмове блёку, ці роўны аргумэнту:
          (1..100).find_index { |i| i % 5 == 0 and i % 7 == 0 }     #=> 34
          (1..100).find_index(50)                                   #=> 49

          # вяртае максымальны з элемэнтаў пералічэньня:
          a = %w(albatross dog horse)
          a.max                                                     #=> "horse"
          a.max { |a,b| a.length <=> b.length }                     #=> "albatross"

          # вяртае мінімальны з элемэнтаў пералічэньня:
          a = [1, 3, 5, 7]
          a.min                                                     #=> 1
        ]]></script>

  <h4 id="Types_Enumerable_Methods_Rundown">Перабор элемэнтаў</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          # выклікае ўнутраны блёк для кожнага элемэнту пералічэньня,
          # вяртае масіў, які ўтрымлівае вынік выкананьня блёку для кожнага з элемэнтаў:
          (1..4).collect {|i| i*i }                                 #=> [1, 4, 9, 16]
        ]]></script>

  <h2 id="Types_Strings">Сымбальныя чароды</h2>
  <p>Сымбальныя чароды&nbsp;&mdash; гэта пасьлядоўнасьць любых сымбаляў (літараў, лічбаў, знакаў прыпынку), якія ўзяты ў апострафы ці двукосьсе. Уключаюць у сябе <mark>дамешак</mark> <a href="#Types_Enumerable"><code class="class">Enumerable</code></a>.</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "sealab", '2021', ці "These cartoons are hilarious!"
        ]]></script>
  <p>У сымбальных чародах, каторыя ўзятыя ў адзіночныя апострафы, дазваляюцца простыя <i>sequence</i>-пасьлядоўнасьці:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        'escape using "\\"'     #=> escape using "\"
        'That\'s right'         #=> That's right
        ]]></script>
  <p>У сымбальных чародах, ўзятых ў двукосьсе, дазваляецца большая колькасьць <i>sequence</i>-пасьлядоўнасьцяў (напр. "\n"). Акрамя гэтага ў такія чароды можна падставіць любы выраз пры дапамозе <code>#{ }</code>:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "Seconds/day: #{24*60*60}"      #=> Seconds/day: 86400
        "#{'Ho! '*3}Merry Christmas"    #=> Ho! Ho! Ho! Merry Christmas
        "This is line #$."              #=> This is line 3
        ]]></script>
  <p>Каб пазначыць адзін сымбаль/знак (не чараду з аднаго знаку, а менавіта знак), перад ім ставіцца пытальнік:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "hello".index(?e)               #=> 1
        ]]></script>

  <h3 id="Types_Strings_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/String.html">String</a></li>
    </ul>
  </div>
  <p>Коратка пра мэтады, каторыя прадстаўляюцца чародамі (поўны сьпіс і тлумачэньне даступныя па спасылцы зьлева).</p>

  <h4 id="Types_Strings_Methods_Size">Памер чарады</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # правярае ці пустая чарада:
        "hello".empty?      #=> false
        "".empty?           #=> true

        # вяртае колькасьць сымбаляў у чарадзе:
        "hello".length      #=> 5
        "hi".size           #=> 2
        ]]></script>

  <h4 id="Types_Strings_Methods_Compare">Параўнаньне чародаў</h4>
  <p>Акрамя <a href="#Types_Object_Methods_Compare">стандартных мэтадаў параўнаньня</a>, у <code class="class">String</code> яшчэ існуе мэтад параўнаньня чародаў аналягічны мэтаду <code class="class"><String>&lt;=&gt;</code>, але без уліку рэгістру літар:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "abcdef".casecmp("abcde")     #=> 1
        "aBcDeF".casecmp("abcdef")    #=> 0
        "abcdef".casecmp("abcdefg")   #=> -1
        "abcdef".casecmp("ABCDEF")    #=> 0
        ]]></script>

  <h4 id="Types_Strings_Methods_Array">Паэлемэнтны доступ</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        a = "hello there"
        a[1]                  #=> "e" (доступ да сымбалю з індэксам 1)
        a[1,3]                #=> "ell" (доступ да трох сымбаляў пачынаючы з індэксу 1)
        a[1..3]               #=> "ell" (доступ да сымбаляў з індэксамі 1..3)
        a[-3,2]               #=> "er" (у выпадку адмоўных значэньняў індэкс лічыцца з канца)
        a[-4..-2]             #=> "her"
        a[12..-1]             #=> nil
        a[-2..-4]             #=> ""
        a[/[aeiou](.)\1/]     #=> "ell" (у выпадку рэгулярных выразаў, вяртаецца знойдзеная чарада)
        a[/[aeiou](.)\1/, 0]  #=> "ell" (калі другім парамэтрам ідзе лік, вяртаецца адпаведны
        a[/[aeiou](.)\1/, 1]  #=> "l"   кампанэнт у MatchData)
        a[/[aeiou](.)\1/, 2]  #=> nil
        a["lo"]               #=> "lo"  (вяртаецца перададзеная ў якасьці аргумэнту чарада,
        a["bye"]              #=> nil   калі яна знойдзена ў якасьці падчарады ў зыходнай)
        ]]></script>
  <p>Акрамя формы а-ля масіў, прыведзенай у прыкладзе вышэй, можна яшчэ ўжываць мэтад <code class="method">slice</code>&nbsp;&mdash; бязь зьмены зыходнай чарады, ці <code class="method">slice!</code>&nbsp;&mdash; са зьменай зыходнай чарады.</p>

  <h4 id="Types_Strings_Methods_ContentTransforms">Мадыфікацыя зьместу</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # "абнуленьне" чарады:
        s = "Hello!"            #=> "Hello!"
        s.clear                 #=> ""

        # дубляваньне чарады пэўную колькасьць разоў:
        "Ho! " * 3              #=> "Ho! Ho! Ho! "

        # злучэньне чародаў:
        "Hello " + "world!"     #=> "Hello world!"
        a = "Hello "
        a << "world"            #=> "Hello world"
        a.concat(33)            #=> "Hello world!" (калі ў выпадку << ці concat аргумэнтам
                                #   зьяўляецца цэлы лік, ён трактуецца як код знаку)

        # пераварочваньне чарады (існуе форма reverse!):
        "stressed".reverse      #=> "desserts"

        # устаўка і замена падчародаў:
        "abcd".insert(0, 'X')   #=> "Xabcd"
        "abcd".insert(4, 'X')   #=> "abcdX"
        "abcd".insert(-3, 'X')  #=> "abXcd"
        "abcd".insert(-1, 'X')  #=> "abcdX"
        s = "hello"             #=> "hello"
        s.replace "world"       #=> "world"

        # адкідваньне з канца чарады знаку "перавод радка" (\n, \r ці \r\n), калі выкліканы без
        # аргумэнтаў, ці падчарады, пазначанай ў якасьці аргумэнту (існуе форма chomp!):
        "hello".chomp           #=> "hello"
        "hello\n".chomp         #=> "hello"
        "hello\r\n".chomp       #=> "hello"
        "hello\n\r".chomp       #=> "hello\n"
        "hello\r".chomp         #=> "hello"
        "hello \n there".chomp  #=> "hello \n there"
        "hello".chomp("llo")    #=> "he"

        # адкіданьне галаўных і канцавых прагалаў (для ўсіх 3х функцыяў існуюць варыянты з !):
        "    hello    ".strip   #=> "hello"
        "\tgoodbye\r\n".strip   #=> "goodbye"
        "  hello  ".rstrip      #=> "  hello"
        "  hello  ".lstrip      #=> "hello  "

        # замена ў чарадзе яе пэўнай падчарады на іншую. sub - замяняе першую знойдзеную
        # падчараду, gsub - усе знойдзеныя падчароды. Існуюць формы мэтадаў з !
        "hello".gsub(/[aeiou]/, '*')                  #=> "h*ll*"
        "hello".gsub(/([aeiou])/, '<\1>')             #=> "h<e>ll<o>"
        "hello".gsub(/./) {|s| s[0].ord.to_s + ' '}   #=> "104 101 108 108 111 "
        "hello".gsub(/(?<foo>[aeiou])/, '{\k<foo>}')  #=> "h{e}ll{o}"
        ]]></script>

  <h4 id="Types_Strings_Methods_CaseTransforms">Мадыфікацыя рэгістру літар</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # першая літара чарады - з вялікай літары, астатнія - малыя (існуе форма з !):
        "hello world".capitalize    #=> "Hello world"
        "HELLO".capitalize          #=> "Hello"
        "123ABC".capitalize         #=> "123abc"

        # усе літары чарады робіць вялікімі (існуе форма з !):
        "hEllO".upcase              #=> "HELLO"

        # усе літары чарады робіць малымі (існуе форма з !):
        "hEllO".downcase            #=> "hello"

        # робіць рэгістар літар зваротным (існуе форма з !):
        "Hello".swapcase            #=> "hELLO"
        "cYbEr_PuNk11".swapcase     #=> "CyBeR_pUnK11"
        ]]></script>

  <h4 id="Types_Strings_Methods_Rundown">Паэлемэнтны перабор</h4>
  <p>Існуюць 4 мэтады: <code class="method">bytes</code>, <code class="method">chars</code>, <code class="method">codepoints</code> і <code class="method">lines</code>, а таксама іх аналягі з прэфіксам <code>each_</code>. Першыя чатыры, калі ім перадаецца блёк, аналягічныя апошнім чатыром. Калі ж яны выклікаюцца бяз блёку, то проста вяртаюць пералічэньне з байтаў, сымбаляў, кодаў ці радкоў адпаведна.</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "hello".bytes.to_a                      #=> [104, 101, 108, 108, 111]
        "hello".each_byte {|c| print c, ' ' }   #=> 104, 101, 108, 108, 111

        "foo".chars.to_a                        #=> ["f","o","o"]

        "foo\nb ar".lines.sort                  #=> ["b ar", "foo\n"]

        "hello\u0639".each_codepoint {|c| print c, ' ' }    #=> 104 101 108 108 111 1593
        ]]></script>

  <h4 id="Types_Strings_Methods_Analysis">Разбор чарады</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # ці пачынаецца чарада з пазначанай падчарады:
        "Hello".start_with?("He")       #=> true

        # ці ўключае чарада пазначаны падчараду:
        "Hello".include?("Hi")          #=> false

        # вяртае індэкс, з каторага пазначаная падчарада уключаецца ў зыходную чараду:
        "hello".index('e')              #=> 1
        "hello".index('lo')             #=> 3
        "hello".index('a')              #=> nil
        "hello".index(/[aeiou]/, -3)    #=> 4 (калі другім аргумэнтам пазначаны цэлы лік, ён кажа зь
                                        #      якога індэксу зыходнай чарады трэба пачынаць пошук)

        # дзяленьне чарады па пэўным падзяляльнікам:
        " now's  the time".split        #=> ["now's", "the", "time"]
        " now's  the time".split(' ')   #=> ["now's", "the", "time"]
        " now's  the time".split(/ /)   #=> ["", "now's", "", "the", "time"]
        "1, 2.34,56, 7".split(%r{,\s*}) #=> ["1", "2.34", "56", "7"]
        "hello".split(//)               #=> ["h", "e", "l", "l", "o"]
        "mellow yellow".split("ello")   #=> ["m", "w y", "w"]

        a = "cruel world"
        a.scan(/\w+/)                   #=> ["cruel", "world"]
        a.scan(/.../)                   #=> ["cru", "el ", "wor"]
        a.scan(/\w+/) {|w| print "<<#{w}>> " }      #=> <<cruel>> <<world>>

        # таксама падзяляе чараду, але толькі на: 1. тое што да падзяляльніка; 2. падзяляльнік;
        # 3. тое, што пасьля падзяляльніка. Існуе таксама форма rpartition, каторая шукае з канца.
        "hello".partition("l")          #=> ["he", "l", "lo"]
        "hello".partition("x")          #=> ["hello", "", ""]
        "hello".partition(/.l/)         #=> ["h", "el", "lo"]

        # шукае ўваходжаньне <i>regexp</i>-патэрнаў у чарадзе і вяртае экзэмпляр MatchData
        'hello'.match('(.)\1')          #=> #<MatchData "ll" 1:"l">
        ]]></script>

  <h4 id="Types_Strings_Methods_Encoding">Кадоўка знакаў</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # атрыманьне цяперашняй кадоўкі знакаў чарады:
        "Hello".encoding                #=> #<Encoding:IBM866> (аб'ект клясы Encoding)

        # ужыць кадоўку: мэтады encode, encode!, force_encoding
        # больш падрабязна гл. афіцыйны даведнік

        # праверыць ці кадоўка валідная:
        "\xc2\xa1".force_encoding("UTF-8").valid_encoding?    #=> true
        "\xc2".force_encoding("UTF-8").valid_encoding?        #=> false
        "\x80".force_encoding("UTF-8").valid_encoding?        #=> false
        ]]></script>

  <h4 id="Types_Strings_Methods_TypeTransforms">Трансфармацыя ў іншыя тыпы</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          # у рэчаісны лік:
          "123.45e1".to_f         #=> 1234.5
          "45.67 degrees".to_d    #=> 45.67
          "thx1138".to_f          #=> 0.0

          # у цэлы лік:
          "12345".to_i            #=> 12345
          "99 red balloons".to_i  #=> 99
          "0a".to_i               #=> 0
          "0a".to_i(16)           #=> 10
          "hello".to_i            #=> 0
          "1100101".to_i(16)      #=> 17826049
        ]]></script>

  <h2 id="Types_Arrays">Масівы</h2>
  <p>Масівы&nbsp;&mdash; гэта пасьлядоўнасьць значэньняў (неабавязкова аднолькавага тыпу), доступ да каторых можна атрымаць па іх парадкаваму нумару (індэксу). Нумарацыя элемэнтаў ў масіве пачынаецца з нуля. Нумараваць элемэнты можна ў тым ліку з канца, у гэтым выпадку індэкс будзе мець негатыўнае значэньне (<code>-1</code> адпавядае апошняму элемэнту, <code>-2</code>&nbsp;&mdash; перадапошняму і г.д.). Масівы ўключаюць у сябе дамешак <a href="#Types_Enumerable"><code class="class">Enumerable</code></a></p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          [1, 2, 3]                         # масіў лічбаў 1, 2, 3
          ['coat', 'mittens', 'snowboard']  # масіў сымбальных чародаў
          [1, 'coat', 5, 7, 'snowboard']    # разнародны масіў
        ]]></script>

  <h3 id="Types_Arrays_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Array.html">Array</a></li>
    </ul>
  </div>
  <p>Коратка пра мэтады, уласьцівыя масівам (поўны сьпіс і тлумачэньне даступныя па спасылцы зьлева).</p>

  <h4 id="Types_Arrays_Methods_Common">Агульнага прызначэньня</h4>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          a = [0, 1, 4, 9, 16]                  #=> [0, 1, 4, 9, 16]
          a[0] = "zero"                         #=> ["zero", 1, 4, 9, 16]
          a[-1] = 1..16                         #=> ["zero", 1, 4, 9, 1..16]
          a[8] = 64                             #=> ["zero", 1, 4, 9, 1..16, nil, nil, nil, 64]
          a[-9] = 81                            # Памылка: немагчыма дадаць элемэнт да пачатку масіва

          a = ('a'..'e').to_a                   #=> Дыяпазон пераўтвораны ў масіў ['a', 'b', 'c', 'd', 'e']
          a[0,2] = ['A', 'B']                   #=> ['A', 'B', 'c', 'd', 'e']
          a[2...5]=['C', 'D', 'E']              #=> ['A', 'B', 'C', 'D', 'E']
          a[0,0] = [1,2,3]                      #=> [1, 2, 3, 'A', 'B', 'C', 'D', 'E']
          a[0..2] = []                          #=> ['A', 'B', 'C', 'D', 'E']
          a[-1,1] = ['Z']                       #=> ['A', 'B', 'C', 'D', 'Z']
          a[-1,1] = 'Z'                         #=> тое ж самае, што і вышэй (калі адзіны элемэнт)
          a[-2,2] = nil                         #=> ['A', 'B', 'C'] у Ruby 1.8
                                                #=> але ['A', 'B', 'C', nil, nil] у Ruby 1.9

          a = [1, 2, 3] + [4, 5]                #=> [1, 2, 3, 4, 5]
          a = a + [[6, 7, 8]]                   #=> [1, 2, 3, 4, 5, [6, 7, 8]]

          ['a', 'b', 'c', 'b', 'a'] - ['b', 'c', 'd']   #=> ['a', 'a']

          a = []                                #=> []
          a << 1                                #=> [1]
          a << 2 << 3                           #=> [1, 2, 3]
          a << [4,5,6]                          #=> [1, 2, 3, [4, 5, 6]]

          a = [0] * 8                           #=> [0, 0, 0, 0, 0, 0, 0, 0]

          a = [1, 1, 2, 2, 3, 3, 4]
          b = [5, 5, 4, 4, 3, 3, 2]
          a | b                                 #=> [1, 2, 3, 4, 5]: выдаляюцца дублікаты
          b | a                                 #=> [5, 4, 3, 2, 1]: тое ж самае, што і вышэй,
                                                #=> толькі парадак іншы
          a & b                                 #=> [2, 3, 4]: застаюцца толькі элемэнты, каторыя
                                                #=> сустракаюцца ў абодвух масівах
          b & a                                 #=> [4, 3, 2]

          # вяртае чараду, якая складаецца з усіх элемэнтаў масіву, пераведзеных у сымбальнае
          # прадстаўленьне і падзеленых неабавязковым аргумэнтам (ня блытаць з concat):
          ["a", "b", "c"].join                  #=> "abc"
          ["a", "b", "c"].join("-")             #=> "a-b-c"

          # аб'ядноўвае два масіва ў адзін (ня блытаць з join):
          ["a", "b"].concat(["c", "d"])         #=> ["a", "b", "c", "d"]

          # пераварочвае масіў:
          ["a", "b", "c"].reverse               #=> ["c", "b", "a"]

          # вяртае масіў, зь якога выдаленыя дублікаты зыходнага масіва:
          a = ["a", "a", "b", "b", "c"]
          a.uniq                                #=> ["a", "b", "c"]

          # выдаляе пэўныя элемэнты з масіву; вяртае значэньне выдаленага(-ых) элемэнту(-аў),
          # калі такі меўся, ці nil у адваротным выпадку:
          a = [ "a", "b", "b", "b", "c" ]
          a.delete("b")                         #=> "b"
          a                                     #=> ["a", "c"]
          a.delete("b")                         #=> nil

          # устаўляе пазначаныя элемэнты перад тым, чый індэкс пазначаны ў якасьці аргумэнту:
          a = %w{ a b c d }
          a.insert(2, 99)                       #=> ["a", "b", 99, "c", "d"]
          a.insert(-2, 1, 2, 3)                 #=> ["a", "b", 99, "c", 1, 2, 3, "d"]
        ]]></script>

  <h4 id="Types_Arrays_Methods_StackQueue">Stack / Queue</h4>
  <p>Асобна прывядзем мэтады масіваў, каторыя мадэлююць зь іх чэргі, стэкі і сьпісы. А спачатку дыяграма гэтых мэтадаў для нагляднага азнаямленьня:</p>
  <figure>
    <img alt="Дыяграма стэкавых мэтадаў" title="Дыяграма стэкавых мэтадаў" src="../images/ruby_stack_methods.png"/>
  </figure>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          # вяртае адзін (калі аргумэнт не зададзены ці роўны 1) ці некалькі
          # (калі аргумэнт прысутнічае і большы за 1) апошніх элемэнтаў масіву і робіць масіў
          # меншым на гэтую колькасьць элемэнтаў (зрухвае яго направа):
          a = ["a", "b", "c", "d"]
          a.pop                                 #=> "d"
          a                                     #=> ["a", "b", "c"]
          a.pop(2)                              #=> ["b", "c"]
          a                                     #=> ["a"]

          # дадае пазначаны(я) элемэнт(ы) да канца масіву; у якасьці выніку вяртае новы масіў,
          # таму выклікі мэтаду могуць ісьці адзін за адным:
          a = ["a", "b", "c"]
          a.push("d", "e", "f")                 #=> ["a", "b", "c", "d", "e", "f"]

          # вяртае першы элемэнт масіву, адначасова выдаляючы яго з масіву і робячы масіў меншым
          # (зрухвае яго налева). Калі масіў пусты, вяртае nil. Калі выклікаецца з аргумэнтам (n),
          # вяртае масіў першых n элемэнтаў і выдаляе/памяншае зыходны масіў на гэную колькасьць элемэнтаў:
          args = [ "-m", "-q", "filename" ]
          args.shift                            #=> "-m"
          args                                  #=> ["-q", "filename"]

          args = [ "-m", "-q", "filename" ]
          args.shift(2)                         #=> ["-m", "-q"]
          args                                  #=> ["filename"]

          # дадае пазначаны(я) элемэнт(ы) да пачатку масіву, зрухваючы зыходныя элемэнты масіву направа:
          a = [ "b", "c", "d" ]
          a.unshift("a")                        #=> ["a", "b", "c", "d"]
          a.unshift(1, 2)                       #=> [ 1, 2, "a", "b", "c", "d"]
        ]]></script>

  <h2 id="Types_Hashes">Хэшы</h2>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Hash.html">Hash</a></li>
    </ul>
  </div>
  <p>Хэшы&nbsp;&mdash; гэта структуры даных, у каторых пэўным ключам пастаўлены ў адпаведнасьць іх значэньні (пару ключ/значэньне будзем называць вызначэньнем). Шэраг вызначэньняў заключаны паміж фігурнымі дужкамі, а вызначэньні ў гэтым шэрагу падзелены паміж сабой коскамі. Паміж ключом і яго значэньнем стаяць знакі <code>=&gt;</code>:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          {'a' => 'aardvark', 'b' => 'badger'}
        ]]></script>
  <p>Хэшы ўключаюць у сябе дамешак <a href="#Types_Enumerable"><code class="class">Enumerable</code></a>.</p>
  <p>У адрозьненьне ад масіваў значэньні хэшаў утрымліваюцца <strong>не</strong>пасьлядоўна і доступ да іх адбываецца не па парадкаваму нумару, а па яго ключу.</p>

  <h2 id="Types_Ranges">Дыяпазоны</h2>
  <p>Дыяпазоны паўсюдна сустракаюцца ў штодзённым жыцьці: са студзеня па люты, ад 0 да 9, радкі з 57 па 60 і г.д. Ruby падтрымлівае гэтыя існасьці праз тып <code class="class">Range</code>. Прычым у Ruby гэты тып выкарыстоўваецца для прадстаўленьня <i>пасьлядоўнасьцей</i>, <i>умоваў</i> і <i>інтэрвалаў</i>. Дыяпазоны ўключаюць у сябе дамешак <a href="#Types_Enumerable"><code class="class">Enumerable</code></a>.</p>

  <h3 id="Types_Ranges_AsSequences">Як пасьлядоўнасьці</h3>
  <p>Найбольш натуральнае выкарыстаньне дыяпазонаў&nbsp;&mdash; для прадстаўленьня пасьлядоўнасьцяў. Запісваюцца яны праз пазначэньне пачатковага значэньня, потым ідзе <a href="#LangParts_Operators_Ranges">апэрацыя дыяпазону</a>, пасьля каторай пазначаецца канцавое значэньне пасьлядоўнасьці. Апэрацыя дыяпазону можа быць альбо <code>..</code> (з уключэньнем апошняга пазначанага значэньня пасьлядоўнасьці), альбо <code>...</code> (без уключэньня апошняга значэньня):</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        'a'..'z'                # пасьлядоўнасьць усіх радковых літар лацінскага альфабэту
        1...9                   # пасьлядоўнасьць лічбаў ад 1 па 8 уключна, без уліку апошняга значэньня 9
        ]]></script>
  <p>Унутрана дыяпазоны захоўваюцца ня ў выглядзе сьпісу з усіх значэньняў, а ў выглядзе пачатковага і канцавога значэньняў. Таму, каб атрымаць сьпіс значэньняў, трэба выклікаць мэтад <code class="method">to_a</code>, каторы пераўтворыць дыяпазон у масіў усіх яго значэньняў:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1..10                   #=> 1..10 (выводзіць не пералік усіх значэньняў, а пачатковае і канцавое)
        (1..10).to_a            #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (пералік усіх значэньняў)
        ]]></script>
  <p>Дыяпазоны можна ўтвараць ня толькі з лікаў ці сымбаляў, але і з любых іншых аб&#8217;ектаў. Але існуюць пэўныя патрабаваньні да клясаў, чые экзэмпляры могуць утвараць дыяпазоны: 1. утрымліваць <mark>дамешак</mark> <code class="class">Comparable</code> і, адпаведна, <em>правільна</em> рэалізоўваць мэтад <code class="method">&lt;=&gt;</code>; 2. рэалізоўваць мэтад <code class="method">succ</code>, каторы вяртае наступны элемэнт у дыяпазоне:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class VU
          include Comparable

          attr :volume

          def initialize(volume)  # 0..9
            @volume = volume
          end

          def inspect
            '#' * @volume
          end

          # Рэалізоўваем падтрымку дыяпазонаў:

          def <=>(other)
            self.volume <=> other.volume
          end

          def succ
            raise(IndexError, "Значэньне завялікае") if @volume >= 9
            VU.new(@volume.succ)
          end
        end
        ]]></script>
  <p>Пасьля гэтага магчымае наступнае ўжываньне:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        m = VU.new(4)..VU.new(7)
        m.to_a                       #=> [####, #####, ######, #######]
        m.include?(VU.new(3))        #=> false
        ]]></script>

  <h3 id="Types_Ranges_AsConditions">Як умовы</h3>
  <p>Акрамя пасьлядоўнасьцяў дыяпазоны ўжываюцца ў якасьці ўмоўных выразаў:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        while input = gets
          puts input if input =~ /start/ .. input =~ /end/
        end
        ]]></script>

  <h3 id="Types_Ranges_AsIntervals">Як інтэрвалы</h3>
  <p>А яшчэ дыяпазоны ўжываюцца для праверкі ці ўваходзіць значэньне ў пэўны інтэрвал пры дапамозе апэрацыі <code>===</code>:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        (1..10) === 5              #=> true    (5 уваходзіць у інтэрвал значэньняў ад 1 да 10
        (1..10) === 15             #=> false    а 15 не ўваходзіць)
        ]]></script>
  <p>Апэрацыя <code>===</code> яшчэ называецца <code class="keyword">case</code>-параўнальнай, таму што выкарыстоўваецца ў <mark>аператары <code class="keyword">case</code></mark>, калі ў ім ужываюцца дыяпазоны:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        score = 70

        result = case score
          when 0..40 then "Fail"
          when 41..60 then "Pass"
          when 61..70 then "Pass with Merit"
          when 71..100 then "Pass with Distinction"
          else "Invalid Score"
        end                         #=> "Pass with Merit"
        ]]></script>

  <h3 id="Types_Ranges_Methods">Мэтады</h3>
  <div class="refs">
    <ul>
      <li><a href="http://ruby-doc.org/ruby-1.9/classes/Range.html">Range</a></li>
    </ul>
  </div>
  <p>Коратка пра мэтады, каторыя прадстаўляюцца дыяпазонамі (поўны сьпіс і тлумачэньне даступныя па спасылцы зьлева):</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          # атрымаць першы(-я) элемэнт(-ы) дыяпазону:
          (1..5).begin                #=> 1
          (1..5).first                #=> 1
          (1..5).first(2)             #=> [1, 2]

          # атрымаць апошні(-я) элемэнт(-ы) дыяпазону:
          (1..5).end                  #=> 5
          (1..5).last                 #=> 5
          (1..5).last(2)              #=> [4, 5]

          # ці ўваходзіць значэньне ў дыяпазон:
          (1..5) === 3                #=> true
          ('A'..'Z').include?('a')    #=> false  (акрамя мэтаду include? можа ўжывацца яшчэ і member?)

          # перабор кожнага элемэнту:
          sum = 0
          (1..5).each do |i|
            sum += i
          end
          puts sum                    #=> 15

          # перабор кожнага n-га элемэнту:
          (1..5).step(2) do |i|
            print i.to_s + ' '
          end                         #=> 1 3 5

          # пераўтварэньне ў масіў з выдаленьнем значэньняў па ўмове:
          (1..9).reject { |i| i < 5 } #=> [5, 6, 7, 8, 9]
        ]]></script>

  <h2 id="Types_Symbols">Сымбалі</h2>
  <p>Інтэпрэтатар Ruby рэалізуе табліцу так званых сымбаляў (<i>Symbols</i>), у каторай ён захоўвае імёны ўсіх клясаў, мэтадаў і зьменных. Гэта дазваляе пазьбегнуць некаторых цяжкіх апэрацыяў параўнаньня сымбальных чародаў (<i>Strings</i>): інтэрпрэтатар атрымлівае доступ да, напрыклад, мэтаду па яго парадкаваму нумару ў табліцы, а не па яго імені.</p>
  <p>У Ruby ідэя сымбаляў рэалізавана нават яшчэ на крок далей&nbsp;&mdash; да сымбаляў можна зьвяртацца ў самой праграме. Яны выглядаюць амаль як лякальныя зьменныя, але перад імі ставіцца двукроп&#8217;е і азначаюць яны палегчаныя радкі&nbsp;&mdash; стварыўшыся аднойчы, яны застаюцца ў памяці да канца працы праграмы і пры наступным выкарыстаньні проста бяруцца з памяці, а не ствараюцца па-новай. Вобласьць іх ужываньня&nbsp;&mdash; унутры праграмы, то бок гэта ня тыя радкі, каторыя прызначаныя для паказу карыстальніку. Прыклады:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          :a, :b, ці :ponce_de_leon
        ]]></script>
  <p>Наступны прыклад правярае ці мае аб'ект <code>o</code> вызначэньне мэтаду <code class="method">size</code>, і калі так, выклікае гэты мэтад:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          name = :size
          if o.respond_to? name
            o.send(name)
          end
        ]]></script>
  <p>Сымбалі можна пераўтвараць у чароды і наадварот:</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          str = "string"              #=> str - сымбальная чарада "string"
          sym = str.to_sym            #=> sym - сымбаль :string
          str = sym.to_s              #=> адваротнае пераўтварэньне
        ]]></script>
  <p>Важнай асаблівасьцю зьяўляецца тое, што дзьве сымбальныя чароды могуць утрымліваць аднолькавы зьмест, але зьяўляцца двумя рознымі аб'ектамі, а для сымбаляў гэта ня так. Два радкі з аднолькавым зьместам пры канвертацыі ў сымбаль дадуць адзін і той жа аб'ект.</p>

  <h2 id="Types_BooleanNil"><code class="keyword">true</code>, <code class="keyword">false</code>, <code class="keyword">nil</code></h2>
  <p>Ключавыя словы <code class="keyword">true</code> і <code class="keyword">false</code> прадстаўляюць булеўскія значэньні. Прычым асобнай клясы <code class="class">Boolean</code> у Ruby не існуе. Выкарыстаньне <code class="keyword">true</code> эквівалентна выкарыстаньню <i>singleton</i>-экзэпляра клясы <code class="class">TrueClass</code>, а выкарыстаньне <code class="keyword">false</code> эквівалентна выкарыстаньню <i>singleton</i>-экзэпляра клясы <code class="class">FalseClass</code>. <code class="keyword">nil</code>&nbsp;&mdash; гэта адмысловы <i>singleton</i>-экзэпляр клясы <code class="class">NilClass</code>, каторы прадстаўляе пусты ці &laquo;неіснуючы&raquo; аб'ект.</p>
  <p>Трэба памятаць, што <code class="keyword">true</code>, <code class="keyword">false</code> і <code class="keyword">nil</code>&nbsp;&mdash; аб'екты, не лічбы. Гэта азначае, што <code class="keyword">false</code> і <code class="keyword">nil</code> ня тое ж самае, што <code>0</code>, а <code class="keyword">true</code> ня тое ж самае, што <code>1</code>. У месцах, дзе патрабуецца булеўскае значэньне, <code class="keyword">nil</code> трактуецца як <code class="keyword">false</code>, а значэньні адрозныя ад <code class="keyword">nil</code> і <code class="keyword">false</code> трактуюцца як <code class="keyword">true</code>.</p>
</section>

<section>
  <h1 id="Methods">Мэтады, працэдуры, лямбды</h1>
  <p><i>RSpec</i>&nbsp;&ndash; гэта фрэймворк <i>Unit</i>-тэставаньня і функцыянальнага тэставаньня для <i>Ruby</i>. </p>
</section>

<!--TODO-->
<h2 id="Types_Regexp">Рэгулярныя выразы</h2>
<p>Рэгулярныя выразы (<i>regexp</i>)&nbsp;&mdash; пасьлядоўнасьць сымбаляў, заключаных паміж слэшаў:</p>
<script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        /ruby/, /[0-9]+/ ці /^\d{3}-\d{3}-\d{4}/
        ]]></script>
<p>Яны прызначаны для хуткага пошуку словаў ці патэрнаў у тэксьце.</p>
<!--TODO-->

<section>
  <h1 id="RSpec">RSpec</h1>
  <p><i>RSpec</i>&nbsp;&ndash; гэта фрэймворк <i>Unit</i>-тэставаньня і функцыянальнага тэставаньня для <i>Ruby</i>. </p>

  блёк describe апісвае паводзіны клясы
  <br />
  тэсты запісваюцца пры дапамозе блёку it
  <br />
  блёкі before і after - выконваюцца да і пасьля тэстаў. :all - аднойчы перад усімі тэстамі, :each - перад кожным тэстам

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
          describe MyClass do
            describe ".class_method_1" do
            end

            describe "#instance_method_1" do
            end
          end
        ]]></script>


  <p><a href="http://marakana.com/s/post/1145/efficient_rail_test-driven_development_course">http://marakana.com/s/post/1145/efficient_rail_test-driven_development_course</a></p>
  <p><a href="http://betterspecs.org/">http://betterspecs.org/</a></p>
  <p><a href="http://benscheirman.com/2011/05/dry-up-your-rspec-files-with-subject-let-blocks">http://benscheirman.com/2011/05/dry-up-your-rspec-files-with-subject-let-blocks</a></p>
  <p><a href="http://eggsonbread.com/2010/03/28/my-rspec-best-practices-and-tips/">http://eggsonbread.com/2010/03/28/my-rspec-best-practices-and-tips/</a></p>
  <p><a href="http://blog.emson.co.uk/2008/06/understanding-rspec-stories-a-tutorial/">http://blog.emson.co.uk/2008/06/understanding-rspec-stories-a-tutorial/</a></p>
  <p><a href="http://blog.davidchelimsky.net/category/rspec/">http://blog.davidchelimsky.net/category/rspec/</a></p>
  <p><a href="http://rubydoc.info/gems/rspec-core">http://rubydoc.info/gems/rspec-core</a></p>
  <p><a href="http://rubydoc.info/find/github?q=RSpec">http://rubydoc.info/find/github?q=RSpec</a></p>
</section>

<section>
  <h1 id="Gems">Gems</h1>
  <div class="refs">
    <ul>
      <li><a href="http://rubygems.org/">Home</a></li>
      <li><a href="http://docs.rubygems.org/">Docs</a></li>
    </ul>
  </div>
  <p><a href="http://rubygems.org/gems/airbrake">airbrake - Send your application errors to our hosted service and reclaim your inbox.</a></p>
  <p>Pry: адладка тэстаў. </p>
  <script type="syntaxhighlighter" class="brush: ruby; highlight: [2,4]"><![CDATA[
          describe 'System Status (Resource Monitor)' do
            require 'pry'
            before(:all) do
              binding.pry
              @data = $dut.execute_ok('support_info', 'status', {})
              @info = @data[:info]
            end
          ...
        ]]></script>
  <p>Выкананьне тэсту спыніцца на 4 радку з прапановай irb.</p>

  <h2 id="Gems_DevKit">DevKit</h2>
  <div class="refs">
    <ul>
      <li><a href="http://rubyinstaller.org/add-ons/devkit/">Home</a></li>
      <li><a href="https://github.com/oneclick/rubyinstaller/wiki/development-kit/">Wiki</a></li>
    </ul>
  </div>
  <p>Большасьць гемаў даступны ў бінарным выглядзе і для іх усталёўкі дастаткова набраць <code>gem install &lt;GEM_NAME&gt;</code>. Але гэта тычыцца ня ўсіх гемаў. Некаторыя зь іх, так называемыя натыўныя, даступны толькі ў выглядзе зыходнікаў (напр. на C/C++) і для іх "зборкі" патрэбна пашырэньне да <i>Ruby</i> пад назвай <i>Development Kit</i> (скарочана <i>DevKit</i>).</p>

  <h3 id="Gems_DevKit_install">Усталёўка</h3>
  <p>Па-першае спампоўваем архіў усталёўшчыка <code>DevKit-tdm-32-4.5.1-20101214-1400-sfx.exe</code> (ці больш актуальную вэрсію) на старонцы <a href="https://github.com/oneclick/rubyinstaller/downloads/">https://github.com/oneclick/rubyinstaller/downloads</a>.</p>
  <p>Запускаем спампаваны файл і пазначаем тэчку для распакоўкі, напр. <code>&lt;RUBY_HOME&gt;\devkit</code>.</p>
  <p>Адкрываем акно каманднага радку <code>cmd</code> і пераходзім у ім у пазначаную вышэй для распакоўкі тэчку.</p>
  <p>У акне каманднага радку пасьлядоўна запускаем наступныя каманды:</p>
  <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        ruby dk.rb init
        ]]></script>
  <p>Вынік каторай будзе прыкладна такім:</p>
  <p><img alt="ruby dk.rb init" title="ruby dk.rb init" src="../images/devkit1.png"/></p>
  <p>Далей:</p>
  <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        ruby dk.rb review
        ]]></script>
  <p>Вынік каторай будзе прыкладна такім:</p>
  <p><img alt="ruby dk.rb review" title="ruby dk.rb review" src="../images/devkit2.png"/></p>
  <p>На гэтым этапе трэба пераканацца, што ўсталёўшчык правільна падхапіў шлях да вашай <i>Ruby</i>-усталёўкі. Калі шлях ня правільны, тады трэба адпаведна падправіць файл <code>&lt;RUBY_HOME&gt;\devkit\config.yml</code>.</p>
  <p>Ну і напрыканцы непасрэдна ўсталёўка:</p>
  <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        ruby dk.rb install
        ]]></script>
  <p>Вынік каторай будзе прыкладна такім:</p>
  <p><img alt="ruby dk.rb install" title="ruby dk.rb install" width="920px" src="../images/devkit3.png"/></p>

  <h3 id="Gems_DevKit_Check">Праверка</h3>
  <p>Запусьціць усталёўку натыўнага гема і тым самым спраўдзіць ці правільна ўсталяваўся <code>DevKit</code> можна наступным чынам:</p>
  <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        gem install ruby-debug19 --platform=ruby
        ]]></script>
</section>

<section>
  <h1>Вывучыць крыніцы</h1>

  <p><a href="https://github.com/eventmachine/eventmachine">Eventmachine: Event-Driven I/O Framework/Engine</a></p>
  <p><a href="http://rubysource.com/net-to-ruby-learning-how-to-write-tests-part-ii/?utm_medium=email&utm_campaign=RubySource+20th+December&utm_content=RubySource+20th+December+CID_f2af5bc20b708cababf91ab81601f637&utm_source=Newsletter&utm_term=NET+to+Ruby+Learning+How+to+Write+Tests+Part+II">NET to Ruby: Learning How to Write Tests, Part II</a>&nbsp;&mdash; частку гэтага матэрыялу варта перанесьці ў даведнік па Rails</p>
  <p><a href="http://rubysource.com/functional-programming-techniques-with-ruby-part-i/?utm_medium=email&utm_campaign=RubySource+21st+feb&utm_content=RubySource+21st+feb+CID_fccd7cb097c88cc1751a6adfa2a736c3&utm_source=Newsletter&utm_term=Functional+Programming+Techniques+with+Ruby">Functional Programming Techniques With Ruby: Part I</a></p>
  <p><a href="http://rubysource.com/using-a-graph-database-with-ruby-part-i-introduction/?utm_medium=email&utm_campaign=RubySource+June+26+2012&utm_content=RubySource+June+26+2012+CID_060309c63435e60d57d8bbf94d827e8e&utm_source=Newsletter&utm_term=Using+a+Graph+Database+with+Ruby+Part+I">Using a Graph Database with Ruby. Part I: Introduction</a></p>

</section>
