---
title: Даведнік па агульных прынцыпах праграмаваньня
description: Даведнік па агульных прынцыпах праграмаваньня па-беларуску
disqus_shortname: coding-be
---

<section>
  <p><a href="https://webpro.github.io/programming-principles/">Programming Principles</a></p>
  <p><a href="http://code.tutsplus.com/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">SOLID: Part 1 - The Single Responsibility Principle</a></p>
  <p><a href="http://drboolean.gitbooks.io/mostly-adequate-guide/">Mostly Adequate Guide to functional programming</a></p>
  <p><a href="https://blog.codinghorror.com/code-smells/">Code Smells</a></p>
  <p><a href="https://github.com/kamranahmedse/design-patterns-for-humans">Design patterns for humans</a></p>
</section>

<section>
  <h1 id="Reactive">Рэактыўнае праграмаваньне</h1>
  <div class="refs">
    <ul>
      <li><a href="http://www.reactivemanifesto.org/">Маніфэст</a></li>
    </ul>
  </div>
  <p><a href="https://class.coursera.org/reactive-002/lecture">Курс на Coursera ад Мартина Одерски</a></p>
  <p>Усяго некалькі гадоў назад вялікія праграмы працавалі на дзесятку сэрвэраў, мелі водгук ў некалькі сэкундаў, падтрымку ў некалькі гадзінаў і гігабайты даных. Сёньняшнія праграмы дэплояцца на ўсё, што заўгодна, пачынаючы ад мабільных прыладаў, да воблачных кластэраў, якія працуюць на тысячах шмат-ядровых працэсараў. Колькасьць даных вымяраецца ў пэтабайтах (10<sup>15</sup> байт, альбо 1024 тэрабайт). Адпаведна, учорашнія падыходы да распрацоўкі проста не адпавядаюць сёньняшнім патрабаваньням.</p>
  <p>Узгоднены, пасьлядоўны падыход павінен ужывацца з наступнымі складальнікамі.</p>

  <h2 id="Reactive_Responsive">Responsive</h2>
  <p><strong>Хуткі водгук</strong> праграмы&nbsp;&ndash; краевугольны камень прыязных адносінаў да карыстальнікаў. Стабільна хуткі водгук вызначае высокую якасьць сэрвісу, спрашчае апрацоўку памылак, падвышае задавальненьне карыстальнікаў і спрыяе далейшым ітэрацыям.</p>

  <h2 id="Reactive_Resilient">Resilient</h2>
  <p><strong>Устойлівасьць да адмовы</strong>&nbsp;&ndash; здольнасьць праграмы заставацца <i>responsive</i> пры сутыкненьні з памылковай сытуацыяй. Кліент праграмы не павінен абцяжарвацца праблемай апрацоўкі яе памылак.</p>

  <h2 id="Reactive_Elastic">Elastic</h2>
  <p>Праграма павінна быць <strong>элястычнай</strong>&nbsp;&ndash; здольнасьць праграмы заставацца <i>responsive</i> нават пры павялічаных нагрузках. Рэактыўная праграма павінна вызваляць рэсурсы пры паніжэньні нагрузкі і наадварот запытваць дадатковыя рэсурсы пры павялічэньні нагрузкі.</p>

  <h2 id="Reactive_MessageDriven">Message Driven</h2>
  <p>Праграма павінна засноўвацца на <strong>асынхронным (<i>non blocking</i>) абмене паведамленьняў (падзеяў)</strong>. Гэта дазваляе ўсталёўваць межы паміж кампанэнтамі, зьмяншаць узаемазалежнасьці і павялічваць ізаляцыю кампанэнтаў аднаго ад іншага. Пры такім падыходзе памылкі таксама перадаюцца паміж кампанэнтамі ў якасьці паведамленьняў (падзеяў).</p>
</section>

<section>
  <h1 id="API" data-content-item-open>Распрацоўка API</h1>
  <div class="refs">
    <ul>
      <li><a href="http://swagger.io/">Swagger</a></li>
      <li><a href="https://www.openapis.org/">Open API</a></li>
      <li><a href="https://apiary.io/">Apiary</a></li>
      <li><a href="http://apidocjs.com/">APIDoc</a></li>
    </ul>
  </div>
  <p><a href="https://yahooeng.tumblr.com/post/142418165386/simple-workflow-for-building-web-service-apis">Simple workflow for building web service APIs</a></p>
  <p><a href="https://github.com/Kikobeats/awesome-api">A curated list of awesome resources for design and implement RESTful APIs</a></p>
  <p><a href="https://blog.qmo.io/ultimate-guide-to-api-design/#taskautomators">The Ultimate Guide to API Design</a></p>
  <p><a href="http://editor.swagger.io/#/">Swagger Editor</a></p>
  <p><a href="https://github.com/lucybot/lucy-console/tree/static-site">LucyBot API Console</a></p>
</section>

<section>
  <h1 id="Microservices" data-content-item-open>Мікрасэрвісы</h1>
  <p><a href="https://www.tigerteam.dk/2014/micro-services-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-1/">Microservices: It’s not (only) the size that matters, it’s (also) how you use them (Tigerteam series)</a></p>
  <p><a href="https://www.nginx.com/blog/introduction-to-microservices/">Introduction to Microservices (NGINX series)</a></p>
  <p>An Introduction to Microservices (OAuth series): <a href="https://auth0.com/blog/an-introduction-to-microservices-part-1/">Part 1</a>, <a href="https://auth0.com/blog/an-introduction-to-microservices-part-2-API-gateway/">Part 2</a>, <a href="https://auth0.com/blog/an-introduction-to-microservices-part-3-the-service-registry/">Part 3</a>, <a href="https://auth0.com/blog/introduction-to-microservices-part-4-dependencies/">Part 4</a>.</p>
  <p><a href="http://www.vinaysahni.com/best-practices-for-building-a-microservice-architecture">Best Practices for Building a Microservice Architecture</a></p>
  <p>Лякальная кніга <i>Building microservices</i></p>
  <p>Курс Адама Біна</p>

  <h2 id="Microservices_Architecture" data-content-item-open>Архітэктура</h2>
  <div class="refs">
    <ul>
      <li><a href="http://martinfowler.com/microservices/">martinfowler.com</a></li>
      <li><a href="http://microservices.io/patterns/microservices.html">microservices.io</a></li>
      <li><a href="http://www.mammatustech.com/java-microservices-architecture">mammatustech.com</a></li>
    </ul>
  </div>
  <p>Калі коратка, то мікрасэрвісны архітэктурны стыль&nbsp;&ndash; гэта падыход у распрацоўцы праграмы, як <strong>сукупнасьці невялікіх сэрвісаў</strong>, кожны зь якіх <strong>працуе ў межах свайго працэсу</strong> (напр. <i>Docker</i>), якія <strong>асынхронна камунікуюць</strong> паміж сабою пры дапамозе <strong>легкаважнага мэханізму</strong>, як <i>WebSockets</i> альбо <i>HTTP resource API</i>, пры гэтым мовай камунікацыі зьяўляецца <i>JSON</i>. Кожны з сэрвісаў распрацоўваецца вакол вырашэньня <strong>вузкай бізнэс задачы</strong>. Яны цалкам <strong>аўтаматычна і незалежна адзін ад іншага разгортваюцца ў працоўным асяродку</strong>. </p>

  <h3 id="Microservices_Architecture_DiffWithLibs">Адрозьненьне ад бібліятэк</h3>
  <p>Мікрасэрвісы, як і бібліятэкі (<i>library</i>), зьяўляюцца састаўнымі часткамі праграмы/сыстэмы, іншымі словамі&nbsp;&ndash; яе кампанэнтамі. Калі бібліятэкі зьяўляюцца неад'емнай часткай праграмы і зьвяртаньне да іх адбываецца праз <i>in-memory</i> функцыянальныя выклікі, то мікрасэрвісы гэта кампанэнты, якія працуюць за межамі сыстэмнага працэсу (строга кажучы кожны ў сваім асобным працэсе), і камунікацыя зь імі і паміж імі адбываецца пры дапамозе <i>HTTP</i> запытаў, шыны паведамленьняў, альбо аддаленых працэдурных выклікаў (<i>RPC</i>).</p>

  <h3 id="Microservices_Architecture_ProsCons">Перавагі і недахопы</h3>
  <div class="refs">
    <ul>
      <li><a href="http://martinfowler.com/articles/microservice-trade-offs.html">martinfowler.com</a></li>
    </ul>
  </div>
  <p>Перавагі мікрасэрвісаў:</p>
  <ul>
    <li><strong>Строгія межы модуляў</strong>: мікрасэрвісы будуюцца па модульным прынцыпе, што асабліва важна для вялікіх камандаў (праграмаў).</li>
    <li><strong>Незалежнае разгортваньне</strong>: простыя і невялікія сэрвісы прасьцей разгортваць у працоўным асяродку, а раз яны незалежныя адзін ад іншага, збой/памылка ў адным сэрвісе ня можа «пакласьці» ўсю сыстэму/праграму.</li>
    <li><strong>Разнастайнасьць тэхналёгій</strong>: раз мікрасэрвісы незалежныя, ніякіх праблем ці складанасьцяў інтэграцыі ня выклікае выкарыстаньне розных моваў праграмаваньня, розных фрэймворкаў альбо тэхналёгіяў захоўваньня даных.</li>
  </ul>
  <p>Недахопы мікрасэрвісаў:</p>
  <ul>
    <li><strong>Разьмеркаванасьць</strong>: гэта зьяўляецца як перавагай (такая праграма ці інфраструктура больш гнуткая і скаліруемая) гэтак і недахопам&nbsp;&ndash; разьмеркаваныя сыстэмы складаней распрацоўваць, адлеглыя выклікі марудныя і заўсёды маюць рызыку няўдачы/памылкі.</li>
    <li><strong>Выпадковая альбо няпэўная/магчымая суцэльнасьць</strong> (<i>consistency</i>): падтрымліваць строгую суцэльнасьць разьмеркаваных сыстэмаў вельмі складана, таму ўсе вымушаныя мець справу з выпадковай/няпэўнай суцэльнасьцю.</li>
    <li><strong>Апэрацыйная складанасьць</strong>: каманда DevOps павінна быць вопытнай і прафэсійнай, каб кіраваць вялікай колькасьцю сэрвісаў, якія рэгулярна разгортваюцца.</li>
  </ul>

  <h3 id="Microservices_Architecture_RelatedPatterns">Related Patterns</h3>
  <p>Існуе шэраг іншых патэрнаў дызайну, якія непасрэдна злучаныя з патэрнам мікрасэрвісаў:</p>
  <ul>
    <li><a href="http://microservices.io/patterns/monolithic.html">маналітная архітэктура</a>&nbsp;&ndash; архітэктура ў процівагу мікрасэрвісам;</li>
    <li><a href="http://microservices.io/patterns/apigateway.html">шлюз для <i>API</i></a>&nbsp;&ndash; вызначае якім чынам кліенты атрымліваюць доступ да сэрвісаў;</li>
    <li>выяўленьне сэрвісаў <a href="http://microservices.io/patterns/client-side-discovery.html">на баку кліента</a> і <a href="http://microservices.io/patterns/server-side-discovery.html">на баку сэрвэра</a>&nbsp;&ndash; напраўляе запыт кліента да даступнага экзэмпляра сэрвісу;</li>
    <li><a href=""></a>Messaging і RPC&nbsp;&ndash; два магчымыя спосабы камунікацыі паміж сэрвісамі;</li>
    <li><a href="http://microservices.io/patterns/deployment/single-service-per-host.html">адзін сэрвіс на хост</a> і <a href="http://microservices.io/patterns/deployment/multiple-services-per-host.html">шмат сэрвісаў на хост</a>&nbsp;&ndash; дзьве магчымыя стратэгіі разгортваньня;</li>
    <li><a href="http://microservices.io/patterns/data/database-per-service.html">уласная база для кожнага сэрвісу</a>&nbsp;&ndash; вызначае якім чынам сэрвіс захоўвае і апэрыруе з данымі;</li>
    <li><a href="http://microservices.io/patterns/microservice-chassis.html">Microservice chassis</a>&nbsp;&ndash; пабудова мікрасэрвісаў пры дапамозе адпаведных фрэймворкаў.</li>
  </ul>
  <img src="PatternsRelatedToMicroservices.jpg">

  <h3 id="Microservices_Architecture_Antipatterns">Антышаблёны і падводныя камяні</h3>
  <div class="refs">
    <ul>
      <li><a href="https://www.oreilly.com/ideas/microservices-antipatterns-and-pitfalls">O'Reilly</a></li>
    </ul>
  </div>

  <h4 id="Microservices_Architecture_Antipatterns_DataDrivenMigration">Антышаблён «Data-Driven Migration»</h4>
  <p>Калі ідзе працэс разьбіўкі маналітнай праграмы на мікрасэрвісы, існуе спакуса адразу ўсё рабіць «як трэба», пэ-фэншую так бы мовіць. У тым ліку дзяліць на кавалкі ня толькі лёгіку, але і даныя (кожнаму з выдзеленых <i>Service Component</i> адразу зрабілі асобныя базы):</p>
  <img src="https://d3ansictanv2wj.cloudfront.net/mapr_0101-1691c33f307ff43a4a6756e744196034.png" width="100%">
  <p>Але праблема ў тым, што працэс разьбіўкі маналітнай праграмы на мікрасэрвісы&nbsp;&ndash; не заўсёды адназначны і відавочны. Мы можам спачатку зрабіць разьбіўку адным чынам, а потым убачыць, што зрабілі ня слушна і перайначыць яе:</p>
  <img src="https://d3ansictanv2wj.cloudfront.net/mapr_0102-d855332b87b6d933ed19a6e1e63f988c.png" width="100%">
  <p>Дык вось, перарабляць разьбіўку лёгікі даволі проста, а вось зьмяняць схемы, базы даных і рабіць міграцыю даных&nbsp;&ndash; працэс даволі складаны і працаёмкі. Таму рабіць міграцыю даных лепш на позьніх этапах, калі разьбіўка лёгікі ўжо замацавалася і прайшла выпрабаваньне:</p>
  <img src="https://d3ansictanv2wj.cloudfront.net/mapr_0103-a1612b6cf55fa76e3bf16720379b5092.png" width="100%">

  <h4 id="Microservices_Architecture_Antipatterns_Timeout">Антышаблён «Timeout»</h4>
  <p>Адна з неад'емных праблем, злучаных з рэалізацыяй разьмеркаванай праграмы&nbsp;&ndash; гэта аддаленыя выклікі, ці дакладней сказаць магчымасьць таго, что аддалены сэрвіс можа выконвацца няпэўны час. Праблема нават ня ў тым, што ён можа быць увогуле недасяжным, таму што мы адразу атрымаем адмоўны адказ, а менавіта доўгі час выкананьня. Адным са шляхоў вырашэньня дадзенай праблемы зьяўляецца пазначэньня таймаўтаў. Але таймаўты самі могуць быць праблемай. Напрыклад, існуе практыка выстаўляць значэньне таймаўта як падвойны час сярэдне-максымальнага выкананьня пэўнай задачы:</p>
  <img src="https://d3ansictanv2wj.cloudfront.net/mapr_0202-24f51f9c4f7e334861b69ca641e5c605.png" width="100%">
  <p>Выйсьцем з гэтай праблемы зьяўляецца рэалізацыя шаблёна «Разрыў Ланцугу» («Circuit Breaker»):</p>
  <img src="https://d3ansictanv2wj.cloudfront.net/mapr_0203-f6181a9a1ef2e1cf22272aa45b15c0fd.png" width="100%">

  <h3 id="Microservices_Architecture_JSON">JSON</h3>
  <p>Стандарт для сеціўных праграмаў&nbsp;&ndash; гэта <i>JSON</i>. Ніякага <i>XML</i>, <i>SOAP</i>, <i>WSDL</i> альбо <i>WADL</i>. Толькі <i>JSON</i>! Можна прадстаўляць нешта ў дадатак да <i>JSON</i>, але <i>JSON</i>&nbsp;&ndash; гэта мінімум.</p>

  <h3 id="Microservices_Architecture_CallSpeed">Асынхронныя выклікі і WebSocket</h3>
  <p>Пры разьбіўцы праграмы на невялікія сэрвісы, мы павялічваем колькасьць аддаленых выклікаў. А праблема, злучаная з аддаленымі выклікамі,&nbsp;&ndash; гэта хуткасьць выкананьня. Таму трэба прытрымлівацца пэўных правілаў:</p>
  <ul>
    <li>Па-першае, сэрвіс павінен будавацца вакол даменнай вобласьці, каб даныя, якія адносяцца да гэтай вобласьці, знаходзіліся ў межах аднаго сэрвісу, для памяншэньня колькасьці аддаленых выклікаў.</li>
    <li>Нельга ў пошуках меншай колькасьці выклікаў рабіць грувасткі <i>API</i>, калі адзін мэтад прымае стос усялякіх даных, робіць складаныя вылічэньні, і вяртае складаныя аб'екты. Гэта парушае фундамэнтальны прынцып мікрасэрвісаў.</li>
    <li>ужываць <a href="#Reactive">рэактыўнае праграмаваньне</a>&nbsp;&ndash; асынхронныя выклікі, групаваньне малых выклікаў і агрэгацыя сэрвісаў, неразумныя хуткія каналы сувязі, <i>WebSocket</i>/<i>JSON</i>.</li>
  </ul>

  <h3 id="Microservices_Architecture_DataConsistency">Цэласнасьць даных</h3>
  <p><a href="http://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/">The Hardest Part About Microservices: Your Data</a></p>
  <p><a href="https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/">Turning the database inside-out with Apache Samza</a></p>
  <p>Адна з самых вялікіх цяжкасьцей пры рэалізацыі мікрасэрвісаў&nbsp;&ndash; гэта падтрымка цэласнасьці даных і забесьпячэньне транзакцыйнасьці. Гэта зьвязана з тым, што па ідэі кожны мікрасэрвіс павінен быць цалкам незалежны ад іншых, у тым ліку і яго даныя. Але ў рэальным жыцьці даныя ўзаемазалежныя: балянс карыстальніка (<i>customer service</i>), павінен зьменшыцца толькі ў тым выпадку, калі яго замова (<i>order service</i>) была цалкам праведзеная. Але калі гэта незалежныя сэрвісы, якім чынам забясьпечыць цэласнасьць гэтых даных? Што калі мы спачатку зьменшылі балянс, а потым даслалі сэрвісу замоваў, каб ён завяршыў замову, але паведамленьне згубілася, пры завяршэньні замовы здарылася памылка, ці яшчэ што. Ну і калі наадварот, мы спачатку завяршаем замову, а потым дасылаем паведамленьне аб зьмяншэньні балянсу, могуць здарыцца падобныя нечаканыя сытуацыі.</p>

  <h2 id="Microservices_Tools">Інструмэнты</h2>
  <p>Developing high-speed microservices (tools needed): Docker, Rocket, Vagrant, EC2, boto, Chef, Puppet, testing, perf testing.</p>
  <p>Service discovery and health: Consul, etcd, Zookeeper, Nagios, Sensu, SmartStack, Serf, StatsD.</p>
  <p>Event Sourcing and CQRS: <a href="http://www.axonframework.org/">Axon Framework</a>, <a href="https://eventsourcing.com/es4j/">Eventsourcing for Java (es4j)</a></p>

  <h3 id="Microservices_Tools_Serverless">Serverless</h3>
  <div class="refs">
    <ul>
      <li><a href="http://serverless.com/">Home</a></li>
    </ul>
  </div>
  <p><a href="http://serverless-stack.com/">Serverless Stack is a comprehensive guide to creating full-stack serverless applications.</a></p>
</section>

<section>
  <h1 id="Authentication" data-content-item-open>Authentication</h1>
  <p><a href="https://github.com/teesloane/Auth-Boss#session-based-authentication">Auth Boss. Learn about different authentication methodologies on the web.</a></p>
</section>

<section>
  <h1 id="Tools" data-content-item-open>Інструмэнты</h1>

  <h2 id="Tools_APITesting">API Testing</h2>
  <p><a href="https://www.soapui.org/about-soapui/what-is-soapui.html">SoapUI</a> allows you to easily and rapidly create and execute automated functional, regression, compliance, and load tests.</p>

  <h2 id="Tools_CodeReview">Code review</h2>
  <p><a href="http://codereviewer.org/about/why-codereviewer.html">CodeReviewer</a>&nbsp;&ndash; free tool designed for small teams to manage code review.</p>

  <h2 id="Tools_UML">yUML</h2>
  <p><a href="http://yuml.me/">yUML</a>&nbsp;&ndash; сеціўная праграма для маляваньня <i>UML</i>-дыяграм.</p>
</section>
